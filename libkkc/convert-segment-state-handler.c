/* convert-segment-state-handler.c generated by valac 0.24.0.131-42e78, the Vala compiler
 * generated from convert-segment-state-handler.vala, do not modify */

/*
 * Copyright (C) 2011-2014 Daiki Ueno <ueno@gnu.org>
 * Copyright (C) 2011-2014 Red Hat, Inc.
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */

#include <glib.h>
#include <glib-object.h>
#include <stdlib.h>
#include <string.h>
#include <gee.h>


#define KKC_TYPE_STATE_HANDLER (kkc_state_handler_get_type ())
#define KKC_STATE_HANDLER(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), KKC_TYPE_STATE_HANDLER, KkcStateHandler))
#define KKC_STATE_HANDLER_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), KKC_TYPE_STATE_HANDLER, KkcStateHandlerClass))
#define KKC_IS_STATE_HANDLER(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), KKC_TYPE_STATE_HANDLER))
#define KKC_IS_STATE_HANDLER_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), KKC_TYPE_STATE_HANDLER))
#define KKC_STATE_HANDLER_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), KKC_TYPE_STATE_HANDLER, KkcStateHandlerClass))

typedef struct _KkcStateHandler KkcStateHandler;
typedef struct _KkcStateHandlerClass KkcStateHandlerClass;
typedef struct _KkcStateHandlerPrivate KkcStateHandlerPrivate;

#define KKC_TYPE_STATE (kkc_state_get_type ())
#define KKC_STATE(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), KKC_TYPE_STATE, KkcState))
#define KKC_STATE_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), KKC_TYPE_STATE, KkcStateClass))
#define KKC_IS_STATE(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), KKC_TYPE_STATE))
#define KKC_IS_STATE_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), KKC_TYPE_STATE))
#define KKC_STATE_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), KKC_TYPE_STATE, KkcStateClass))

typedef struct _KkcState KkcState;
typedef struct _KkcStateClass KkcStateClass;

#define KKC_TYPE_KEY_EVENT (kkc_key_event_get_type ())
#define KKC_KEY_EVENT(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), KKC_TYPE_KEY_EVENT, KkcKeyEvent))
#define KKC_KEY_EVENT_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), KKC_TYPE_KEY_EVENT, KkcKeyEventClass))
#define KKC_IS_KEY_EVENT(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), KKC_TYPE_KEY_EVENT))
#define KKC_IS_KEY_EVENT_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), KKC_TYPE_KEY_EVENT))
#define KKC_KEY_EVENT_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), KKC_TYPE_KEY_EVENT, KkcKeyEventClass))

typedef struct _KkcKeyEvent KkcKeyEvent;
typedef struct _KkcKeyEventClass KkcKeyEventClass;

#define KKC_TYPE_CONVERT_SEGMENT_STATE_HANDLER (kkc_convert_segment_state_handler_get_type ())
#define KKC_CONVERT_SEGMENT_STATE_HANDLER(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), KKC_TYPE_CONVERT_SEGMENT_STATE_HANDLER, KkcConvertSegmentStateHandler))
#define KKC_CONVERT_SEGMENT_STATE_HANDLER_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), KKC_TYPE_CONVERT_SEGMENT_STATE_HANDLER, KkcConvertSegmentStateHandlerClass))
#define KKC_IS_CONVERT_SEGMENT_STATE_HANDLER(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), KKC_TYPE_CONVERT_SEGMENT_STATE_HANDLER))
#define KKC_IS_CONVERT_SEGMENT_STATE_HANDLER_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), KKC_TYPE_CONVERT_SEGMENT_STATE_HANDLER))
#define KKC_CONVERT_SEGMENT_STATE_HANDLER_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), KKC_TYPE_CONVERT_SEGMENT_STATE_HANDLER, KkcConvertSegmentStateHandlerClass))

typedef struct _KkcConvertSegmentStateHandler KkcConvertSegmentStateHandler;
typedef struct _KkcConvertSegmentStateHandlerClass KkcConvertSegmentStateHandlerClass;
typedef struct _KkcConvertSegmentStateHandlerPrivate KkcConvertSegmentStateHandlerPrivate;
typedef struct _KkcStatePrivate KkcStatePrivate;

#define KKC_TYPE_LANGUAGE_MODEL (kkc_language_model_get_type ())
#define KKC_LANGUAGE_MODEL(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), KKC_TYPE_LANGUAGE_MODEL, KkcLanguageModel))
#define KKC_LANGUAGE_MODEL_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), KKC_TYPE_LANGUAGE_MODEL, KkcLanguageModelClass))
#define KKC_IS_LANGUAGE_MODEL(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), KKC_TYPE_LANGUAGE_MODEL))
#define KKC_IS_LANGUAGE_MODEL_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), KKC_TYPE_LANGUAGE_MODEL))
#define KKC_LANGUAGE_MODEL_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), KKC_TYPE_LANGUAGE_MODEL, KkcLanguageModelClass))

typedef struct _KkcLanguageModel KkcLanguageModel;
typedef struct _KkcLanguageModelClass KkcLanguageModelClass;

#define KKC_TYPE_DECODER (kkc_decoder_get_type ())
#define KKC_DECODER(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), KKC_TYPE_DECODER, KkcDecoder))
#define KKC_DECODER_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), KKC_TYPE_DECODER, KkcDecoderClass))
#define KKC_IS_DECODER(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), KKC_TYPE_DECODER))
#define KKC_IS_DECODER_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), KKC_TYPE_DECODER))
#define KKC_DECODER_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), KKC_TYPE_DECODER, KkcDecoderClass))

typedef struct _KkcDecoder KkcDecoder;
typedef struct _KkcDecoderClass KkcDecoderClass;

#define KKC_TYPE_SEGMENT_LIST (kkc_segment_list_get_type ())
#define KKC_SEGMENT_LIST(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), KKC_TYPE_SEGMENT_LIST, KkcSegmentList))
#define KKC_SEGMENT_LIST_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), KKC_TYPE_SEGMENT_LIST, KkcSegmentListClass))
#define KKC_IS_SEGMENT_LIST(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), KKC_TYPE_SEGMENT_LIST))
#define KKC_IS_SEGMENT_LIST_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), KKC_TYPE_SEGMENT_LIST))
#define KKC_SEGMENT_LIST_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), KKC_TYPE_SEGMENT_LIST, KkcSegmentListClass))

typedef struct _KkcSegmentList KkcSegmentList;
typedef struct _KkcSegmentListClass KkcSegmentListClass;

#define KKC_TYPE_CANDIDATE_LIST (kkc_candidate_list_get_type ())
#define KKC_CANDIDATE_LIST(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), KKC_TYPE_CANDIDATE_LIST, KkcCandidateList))
#define KKC_CANDIDATE_LIST_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), KKC_TYPE_CANDIDATE_LIST, KkcCandidateListClass))
#define KKC_IS_CANDIDATE_LIST(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), KKC_TYPE_CANDIDATE_LIST))
#define KKC_IS_CANDIDATE_LIST_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), KKC_TYPE_CANDIDATE_LIST))
#define KKC_CANDIDATE_LIST_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), KKC_TYPE_CANDIDATE_LIST, KkcCandidateListClass))

typedef struct _KkcCandidateList KkcCandidateList;
typedef struct _KkcCandidateListClass KkcCandidateListClass;

#define KKC_TYPE_DICTIONARY_LIST (kkc_dictionary_list_get_type ())
#define KKC_DICTIONARY_LIST(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), KKC_TYPE_DICTIONARY_LIST, KkcDictionaryList))
#define KKC_DICTIONARY_LIST_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), KKC_TYPE_DICTIONARY_LIST, KkcDictionaryListClass))
#define KKC_IS_DICTIONARY_LIST(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), KKC_TYPE_DICTIONARY_LIST))
#define KKC_IS_DICTIONARY_LIST_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), KKC_TYPE_DICTIONARY_LIST))
#define KKC_DICTIONARY_LIST_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), KKC_TYPE_DICTIONARY_LIST, KkcDictionaryListClass))

typedef struct _KkcDictionaryList KkcDictionaryList;
typedef struct _KkcDictionaryListClass KkcDictionaryListClass;

#define KKC_TYPE_ROM_KANA_CONVERTER (kkc_rom_kana_converter_get_type ())
#define KKC_ROM_KANA_CONVERTER(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), KKC_TYPE_ROM_KANA_CONVERTER, KkcRomKanaConverter))
#define KKC_ROM_KANA_CONVERTER_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), KKC_TYPE_ROM_KANA_CONVERTER, KkcRomKanaConverterClass))
#define KKC_IS_ROM_KANA_CONVERTER(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), KKC_TYPE_ROM_KANA_CONVERTER))
#define KKC_IS_ROM_KANA_CONVERTER_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), KKC_TYPE_ROM_KANA_CONVERTER))
#define KKC_ROM_KANA_CONVERTER_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), KKC_TYPE_ROM_KANA_CONVERTER, KkcRomKanaConverterClass))

typedef struct _KkcRomKanaConverter KkcRomKanaConverter;
typedef struct _KkcRomKanaConverterClass KkcRomKanaConverterClass;

#define KKC_TYPE_ROM_KANA_CHARACTER_LIST (kkc_rom_kana_character_list_get_type ())
#define KKC_ROM_KANA_CHARACTER_LIST(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), KKC_TYPE_ROM_KANA_CHARACTER_LIST, KkcRomKanaCharacterList))
#define KKC_ROM_KANA_CHARACTER_LIST_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), KKC_TYPE_ROM_KANA_CHARACTER_LIST, KkcRomKanaCharacterListClass))
#define KKC_IS_ROM_KANA_CHARACTER_LIST(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), KKC_TYPE_ROM_KANA_CHARACTER_LIST))
#define KKC_IS_ROM_KANA_CHARACTER_LIST_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), KKC_TYPE_ROM_KANA_CHARACTER_LIST))
#define KKC_ROM_KANA_CHARACTER_LIST_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), KKC_TYPE_ROM_KANA_CHARACTER_LIST, KkcRomKanaCharacterListClass))

typedef struct _KkcRomKanaCharacterList KkcRomKanaCharacterList;
typedef struct _KkcRomKanaCharacterListClass KkcRomKanaCharacterListClass;

#define KKC_TYPE_CANDIDATE (kkc_candidate_get_type ())
#define KKC_CANDIDATE(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), KKC_TYPE_CANDIDATE, KkcCandidate))
#define KKC_CANDIDATE_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), KKC_TYPE_CANDIDATE, KkcCandidateClass))
#define KKC_IS_CANDIDATE(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), KKC_TYPE_CANDIDATE))
#define KKC_IS_CANDIDATE_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), KKC_TYPE_CANDIDATE))
#define KKC_CANDIDATE_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), KKC_TYPE_CANDIDATE, KkcCandidateClass))

typedef struct _KkcCandidate KkcCandidate;
typedef struct _KkcCandidateClass KkcCandidateClass;
#define _g_object_unref0(var) ((var == NULL) ? NULL : (var = (g_object_unref (var), NULL)))

#define KKC_TYPE_CONVERT_SENTENCE_STATE_HANDLER (kkc_convert_sentence_state_handler_get_type ())
#define KKC_CONVERT_SENTENCE_STATE_HANDLER(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), KKC_TYPE_CONVERT_SENTENCE_STATE_HANDLER, KkcConvertSentenceStateHandler))
#define KKC_CONVERT_SENTENCE_STATE_HANDLER_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), KKC_TYPE_CONVERT_SENTENCE_STATE_HANDLER, KkcConvertSentenceStateHandlerClass))
#define KKC_IS_CONVERT_SENTENCE_STATE_HANDLER(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), KKC_TYPE_CONVERT_SENTENCE_STATE_HANDLER))
#define KKC_IS_CONVERT_SENTENCE_STATE_HANDLER_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), KKC_TYPE_CONVERT_SENTENCE_STATE_HANDLER))
#define KKC_CONVERT_SENTENCE_STATE_HANDLER_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), KKC_TYPE_CONVERT_SENTENCE_STATE_HANDLER, KkcConvertSentenceStateHandlerClass))

typedef struct _KkcConvertSentenceStateHandler KkcConvertSentenceStateHandler;
typedef struct _KkcConvertSentenceStateHandlerClass KkcConvertSentenceStateHandlerClass;

#define KKC_TYPE_KANA_MODE (kkc_kana_mode_get_type ())
#define _g_free0(var) (var = (g_free (var), NULL))
#define _g_type_class_unref0(var) ((var == NULL) ? NULL : (var = (g_type_class_unref (var), NULL)))

struct _KkcStateHandler {
	GObject parent_instance;
	KkcStateHandlerPrivate * priv;
};

struct _KkcStateHandlerClass {
	GObjectClass parent_class;
	gboolean (*process_key_event) (KkcStateHandler* self, KkcState* state, KkcKeyEvent* key);
};

struct _KkcConvertSegmentStateHandler {
	KkcStateHandler parent_instance;
	KkcConvertSegmentStateHandlerPrivate * priv;
};

struct _KkcConvertSegmentStateHandlerClass {
	KkcStateHandlerClass parent_class;
};

struct _KkcState {
	GObject parent_instance;
	KkcStatePrivate * priv;
	GType handler_type;
	KkcLanguageModel* model;
	KkcDecoder* decoder;
	KkcSegmentList* segments;
	KkcCandidateList* candidates;
	KkcDictionaryList* dictionaries;
	KkcRomKanaConverter* rom_kana_converter;
	KkcRomKanaCharacterList* input_characters;
	gint input_characters_cursor_pos;
	GString* selection;
	GString* output;
	gboolean quoted;
	KkcKeyEvent* this_command_key;
	KkcKeyEvent* last_command_key;
	gchar* overriding_input;
	GeeIterator* completion_iterator;
};

struct _KkcStateClass {
	GObjectClass parent_class;
};

typedef gboolean (*KkcCommandCallback) (const gchar* command, KkcState* state, KkcKeyEvent* key, void* user_data);
typedef enum  {
	KKC_KANA_MODE_HIRAGANA,
	KKC_KANA_MODE_KATAKANA,
	KKC_KANA_MODE_HANKAKU_KATAKANA,
	KKC_KANA_MODE_LATIN,
	KKC_KANA_MODE_WIDE_LATIN
} KkcKanaMode;


static gpointer kkc_convert_segment_state_handler_parent_class = NULL;

GType kkc_state_handler_get_type (void) G_GNUC_CONST;
GType kkc_state_get_type (void) G_GNUC_CONST;
GType kkc_key_event_get_type (void) G_GNUC_CONST;
GType kkc_convert_segment_state_handler_get_type (void) G_GNUC_CONST;
enum  {
	KKC_CONVERT_SEGMENT_STATE_HANDLER_DUMMY_PROPERTY
};
static gboolean kkc_convert_segment_state_handler_do_next_candidate (KkcConvertSegmentStateHandler* self, const gchar* command, KkcState* state, KkcKeyEvent* key);
GType kkc_language_model_get_type (void) G_GNUC_CONST;
GType kkc_decoder_get_type (void) G_GNUC_CONST;
GType kkc_segment_list_get_type (void) G_GNUC_CONST;
GType kkc_candidate_list_get_type (void) G_GNUC_CONST;
GType kkc_dictionary_list_get_type (void) G_GNUC_CONST;
GType kkc_rom_kana_converter_get_type (void) G_GNUC_CONST;
GType kkc_rom_kana_character_list_get_type (void) G_GNUC_CONST;
gboolean kkc_candidate_list_cursor_down (KkcCandidateList* self);
static gboolean kkc_convert_segment_state_handler_do_previous_candidate (KkcConvertSegmentStateHandler* self, const gchar* command, KkcState* state, KkcKeyEvent* key);
gboolean kkc_candidate_list_cursor_up (KkcCandidateList* self);
static gboolean kkc_convert_segment_state_handler_do_purge_candidate (KkcConvertSegmentStateHandler* self, const gchar* command, KkcState* state, KkcKeyEvent* key);
gint kkc_candidate_list_get_cursor_pos (KkcCandidateList* self);
GType kkc_candidate_get_type (void) G_GNUC_CONST;
KkcCandidate* kkc_candidate_list_get (KkcCandidateList* self, gint index);
void kkc_state_purge_candidate (KkcState* self, KkcCandidate* candidate);
void kkc_state_reset (KkcState* self);
static gboolean kkc_convert_segment_state_handler_do_select_unhandled (KkcConvertSegmentStateHandler* self, const gchar* command, KkcState* state, KkcKeyEvent* key);
void kkc_candidate_list_select (KkcCandidateList* self);
GType kkc_convert_sentence_state_handler_get_type (void) G_GNUC_CONST;
static gboolean kkc_convert_segment_state_handler_do_clear_unhandled (KkcConvertSegmentStateHandler* self, const gchar* command, KkcState* state, KkcKeyEvent* key);
void kkc_candidate_list_clear (KkcCandidateList* self);
static gboolean kkc_convert_segment_state_handler_real_process_key_event (KkcStateHandler* base, KkcState* state, KkcKeyEvent* key);
gboolean kkc_state_handler_dispatch_command (KkcStateHandler* self, KkcState* state, KkcKeyEvent* key);
KkcConvertSegmentStateHandler* kkc_convert_segment_state_handler_new (void);
KkcConvertSegmentStateHandler* kkc_convert_segment_state_handler_construct (GType object_type);
KkcStateHandler* kkc_state_handler_construct (GType object_type);
static GObject * kkc_convert_segment_state_handler_constructor (GType type, guint n_construct_properties, GObjectConstructParam * construct_properties);
void kkc_state_handler_register_command_callback (KkcStateHandler* self, const gchar* command, KkcCommandCallback cb, void* cb_target);
static gboolean _kkc_convert_segment_state_handler_do_next_candidate_kkc_command_callback (const gchar* command, KkcState* state, KkcKeyEvent* key, gpointer self);
static gboolean _kkc_convert_segment_state_handler_do_previous_candidate_kkc_command_callback (const gchar* command, KkcState* state, KkcKeyEvent* key, gpointer self);
static gboolean _kkc_convert_segment_state_handler_do_purge_candidate_kkc_command_callback (const gchar* command, KkcState* state, KkcKeyEvent* key, gpointer self);
static gboolean _kkc_convert_segment_state_handler_do_clear_unhandled_kkc_command_callback (const gchar* command, KkcState* state, KkcKeyEvent* key, gpointer self);
static gboolean _kkc_convert_segment_state_handler_do_select_unhandled_kkc_command_callback (const gchar* command, KkcState* state, KkcKeyEvent* key, gpointer self);
GType kkc_kana_mode_get_type (void) G_GNUC_CONST;
static GEnumValue* _g_enum_value_dup (GEnumValue* self);


static gboolean kkc_convert_segment_state_handler_do_next_candidate (KkcConvertSegmentStateHandler* self, const gchar* command, KkcState* state, KkcKeyEvent* key) {
	gboolean result = FALSE;
	KkcState* _tmp0_ = NULL;
	KkcCandidateList* _tmp1_ = NULL;
	g_return_val_if_fail (self != NULL, FALSE);
	g_return_val_if_fail (state != NULL, FALSE);
	g_return_val_if_fail (key != NULL, FALSE);
	_tmp0_ = state;
	_tmp1_ = _tmp0_->candidates;
	kkc_candidate_list_cursor_down (_tmp1_);
	result = TRUE;
	return result;
}


static gboolean kkc_convert_segment_state_handler_do_previous_candidate (KkcConvertSegmentStateHandler* self, const gchar* command, KkcState* state, KkcKeyEvent* key) {
	gboolean result = FALSE;
	KkcState* _tmp0_ = NULL;
	KkcCandidateList* _tmp1_ = NULL;
	g_return_val_if_fail (self != NULL, FALSE);
	g_return_val_if_fail (state != NULL, FALSE);
	g_return_val_if_fail (key != NULL, FALSE);
	_tmp0_ = state;
	_tmp1_ = _tmp0_->candidates;
	kkc_candidate_list_cursor_up (_tmp1_);
	result = TRUE;
	return result;
}


static gboolean kkc_convert_segment_state_handler_do_purge_candidate (KkcConvertSegmentStateHandler* self, const gchar* command, KkcState* state, KkcKeyEvent* key) {
	gboolean result = FALSE;
	KkcState* _tmp0_ = NULL;
	KkcCandidateList* _tmp1_ = NULL;
	gint _tmp2_ = 0;
	gint _tmp3_ = 0;
	g_return_val_if_fail (self != NULL, FALSE);
	g_return_val_if_fail (state != NULL, FALSE);
	g_return_val_if_fail (key != NULL, FALSE);
	_tmp0_ = state;
	_tmp1_ = _tmp0_->candidates;
	_tmp2_ = kkc_candidate_list_get_cursor_pos (_tmp1_);
	_tmp3_ = _tmp2_;
	if (_tmp3_ >= 0) {
		KkcCandidate* candidate = NULL;
		KkcState* _tmp4_ = NULL;
		KkcCandidateList* _tmp5_ = NULL;
		KkcCandidate* _tmp6_ = NULL;
		KkcState* _tmp7_ = NULL;
		KkcCandidate* _tmp8_ = NULL;
		KkcState* _tmp9_ = NULL;
		_tmp4_ = state;
		_tmp5_ = _tmp4_->candidates;
		_tmp6_ = kkc_candidate_list_get (_tmp5_, -1);
		candidate = _tmp6_;
		_tmp7_ = state;
		_tmp8_ = candidate;
		kkc_state_purge_candidate (_tmp7_, _tmp8_);
		_tmp9_ = state;
		kkc_state_reset (_tmp9_);
		_g_object_unref0 (candidate);
	}
	result = TRUE;
	return result;
}


static gboolean kkc_convert_segment_state_handler_do_select_unhandled (KkcConvertSegmentStateHandler* self, const gchar* command, KkcState* state, KkcKeyEvent* key) {
	gboolean result = FALSE;
	KkcState* _tmp0_ = NULL;
	KkcCandidateList* _tmp1_ = NULL;
	gint _tmp2_ = 0;
	gint _tmp3_ = 0;
	KkcState* _tmp6_ = NULL;
	g_return_val_if_fail (self != NULL, FALSE);
	g_return_val_if_fail (state != NULL, FALSE);
	g_return_val_if_fail (key != NULL, FALSE);
	_tmp0_ = state;
	_tmp1_ = _tmp0_->candidates;
	_tmp2_ = kkc_candidate_list_get_cursor_pos (_tmp1_);
	_tmp3_ = _tmp2_;
	if (_tmp3_ >= 0) {
		KkcState* _tmp4_ = NULL;
		KkcCandidateList* _tmp5_ = NULL;
		_tmp4_ = state;
		_tmp5_ = _tmp4_->candidates;
		kkc_candidate_list_select (_tmp5_);
	}
	_tmp6_ = state;
	_tmp6_->handler_type = KKC_TYPE_CONVERT_SENTENCE_STATE_HANDLER;
	result = FALSE;
	return result;
}


static gboolean kkc_convert_segment_state_handler_do_clear_unhandled (KkcConvertSegmentStateHandler* self, const gchar* command, KkcState* state, KkcKeyEvent* key) {
	gboolean result = FALSE;
	KkcState* _tmp0_ = NULL;
	KkcCandidateList* _tmp1_ = NULL;
	KkcState* _tmp2_ = NULL;
	g_return_val_if_fail (self != NULL, FALSE);
	g_return_val_if_fail (state != NULL, FALSE);
	g_return_val_if_fail (key != NULL, FALSE);
	_tmp0_ = state;
	_tmp1_ = _tmp0_->candidates;
	kkc_candidate_list_clear (_tmp1_);
	_tmp2_ = state;
	_tmp2_->handler_type = KKC_TYPE_CONVERT_SENTENCE_STATE_HANDLER;
	result = FALSE;
	return result;
}


static gboolean kkc_convert_segment_state_handler_real_process_key_event (KkcStateHandler* base, KkcState* state, KkcKeyEvent* key) {
	KkcConvertSegmentStateHandler * self;
	gboolean result = FALSE;
	KkcState* _tmp0_ = NULL;
	KkcKeyEvent* _tmp1_ = NULL;
	gboolean _tmp2_ = FALSE;
	self = (KkcConvertSegmentStateHandler*) base;
	g_return_val_if_fail (state != NULL, FALSE);
	g_return_val_if_fail (key != NULL, FALSE);
	_tmp0_ = state;
	_tmp1_ = key;
	_tmp2_ = kkc_state_handler_dispatch_command ((KkcStateHandler*) self, _tmp0_, _tmp1_);
	result = _tmp2_;
	return result;
}


KkcConvertSegmentStateHandler* kkc_convert_segment_state_handler_construct (GType object_type) {
	KkcConvertSegmentStateHandler * self = NULL;
	self = (KkcConvertSegmentStateHandler*) kkc_state_handler_construct (object_type);
	return self;
}


KkcConvertSegmentStateHandler* kkc_convert_segment_state_handler_new (void) {
	return kkc_convert_segment_state_handler_construct (KKC_TYPE_CONVERT_SEGMENT_STATE_HANDLER);
}


static gboolean _kkc_convert_segment_state_handler_do_next_candidate_kkc_command_callback (const gchar* command, KkcState* state, KkcKeyEvent* key, gpointer self) {
	gboolean result;
	result = kkc_convert_segment_state_handler_do_next_candidate ((KkcConvertSegmentStateHandler*) self, command, state, key);
	return result;
}


static gboolean _kkc_convert_segment_state_handler_do_previous_candidate_kkc_command_callback (const gchar* command, KkcState* state, KkcKeyEvent* key, gpointer self) {
	gboolean result;
	result = kkc_convert_segment_state_handler_do_previous_candidate ((KkcConvertSegmentStateHandler*) self, command, state, key);
	return result;
}


static gboolean _kkc_convert_segment_state_handler_do_purge_candidate_kkc_command_callback (const gchar* command, KkcState* state, KkcKeyEvent* key, gpointer self) {
	gboolean result;
	result = kkc_convert_segment_state_handler_do_purge_candidate ((KkcConvertSegmentStateHandler*) self, command, state, key);
	return result;
}


static gboolean _kkc_convert_segment_state_handler_do_clear_unhandled_kkc_command_callback (const gchar* command, KkcState* state, KkcKeyEvent* key, gpointer self) {
	gboolean result;
	result = kkc_convert_segment_state_handler_do_clear_unhandled ((KkcConvertSegmentStateHandler*) self, command, state, key);
	return result;
}


static gboolean _kkc_convert_segment_state_handler_do_select_unhandled_kkc_command_callback (const gchar* command, KkcState* state, KkcKeyEvent* key, gpointer self) {
	gboolean result;
	result = kkc_convert_segment_state_handler_do_select_unhandled ((KkcConvertSegmentStateHandler*) self, command, state, key);
	return result;
}


static GEnumValue* _g_enum_value_dup (GEnumValue* self) {
	GEnumValue* dup;
	dup = g_new0 (GEnumValue, 1);
	memcpy (dup, self, sizeof (GEnumValue));
	return dup;
}


static gpointer __g_enum_value_dup0 (gpointer self) {
	return self ? _g_enum_value_dup (self) : NULL;
}


static GObject * kkc_convert_segment_state_handler_constructor (GType type, guint n_construct_properties, GObjectConstructParam * construct_properties) {
	GObject * obj;
	GObjectClass * parent_class;
	KkcConvertSegmentStateHandler * self;
	GEnumClass* enum_class = NULL;
	GTypeClass* _tmp0_ = NULL;
	parent_class = G_OBJECT_CLASS (kkc_convert_segment_state_handler_parent_class);
	obj = parent_class->constructor (type, n_construct_properties, construct_properties);
	self = G_TYPE_CHECK_INSTANCE_CAST (obj, KKC_TYPE_CONVERT_SEGMENT_STATE_HANDLER, KkcConvertSegmentStateHandler);
	kkc_state_handler_register_command_callback ((KkcStateHandler*) self, "next-candidate", _kkc_convert_segment_state_handler_do_next_candidate_kkc_command_callback, self);
	kkc_state_handler_register_command_callback ((KkcStateHandler*) self, "previous-candidate", _kkc_convert_segment_state_handler_do_previous_candidate_kkc_command_callback, self);
	kkc_state_handler_register_command_callback ((KkcStateHandler*) self, "purge-candidate", _kkc_convert_segment_state_handler_do_purge_candidate_kkc_command_callback, self);
	kkc_state_handler_register_command_callback ((KkcStateHandler*) self, "abort", _kkc_convert_segment_state_handler_do_clear_unhandled_kkc_command_callback, self);
	kkc_state_handler_register_command_callback ((KkcStateHandler*) self, "next-segment", _kkc_convert_segment_state_handler_do_select_unhandled_kkc_command_callback, self);
	kkc_state_handler_register_command_callback ((KkcStateHandler*) self, "previous-segment", _kkc_convert_segment_state_handler_do_select_unhandled_kkc_command_callback, self);
	kkc_state_handler_register_command_callback ((KkcStateHandler*) self, "first-segment", _kkc_convert_segment_state_handler_do_select_unhandled_kkc_command_callback, self);
	kkc_state_handler_register_command_callback ((KkcStateHandler*) self, "last-segment", _kkc_convert_segment_state_handler_do_select_unhandled_kkc_command_callback, self);
	kkc_state_handler_register_command_callback ((KkcStateHandler*) self, "delete", _kkc_convert_segment_state_handler_do_clear_unhandled_kkc_command_callback, self);
	kkc_state_handler_register_command_callback ((KkcStateHandler*) self, "original-candidate", _kkc_convert_segment_state_handler_do_clear_unhandled_kkc_command_callback, self);
	_tmp0_ = g_type_class_ref (KKC_TYPE_KANA_MODE);
	enum_class = (GEnumClass*) _tmp0_;
	{
		gint i = 0;
		GEnumClass* _tmp1_ = NULL;
		gint _tmp2_ = 0;
		_tmp1_ = enum_class;
		_tmp2_ = _tmp1_->minimum;
		i = _tmp2_;
		{
			gboolean _tmp3_ = FALSE;
			_tmp3_ = TRUE;
			while (TRUE) {
				gint _tmp5_ = 0;
				GEnumClass* _tmp6_ = NULL;
				gint _tmp7_ = 0;
				GEnumValue* enum_value = NULL;
				GEnumClass* _tmp8_ = NULL;
				gint _tmp9_ = 0;
				GEnumValue* _tmp10_ = NULL;
				GEnumValue* _tmp11_ = NULL;
				GEnumValue* _tmp12_ = NULL;
				if (!_tmp3_) {
					gint _tmp4_ = 0;
					_tmp4_ = i;
					i = _tmp4_ + 1;
				}
				_tmp3_ = FALSE;
				_tmp5_ = i;
				_tmp6_ = enum_class;
				_tmp7_ = _tmp6_->maximum;
				if (!(_tmp5_ <= _tmp7_)) {
					break;
				}
				_tmp8_ = enum_class;
				_tmp9_ = i;
				_tmp10_ = g_enum_get_value (_tmp8_, _tmp9_);
				_tmp11_ = __g_enum_value_dup0 (_tmp10_);
				enum_value = _tmp11_;
				_tmp12_ = enum_value;
				if (_tmp12_ != NULL) {
					GEnumValue* _tmp13_ = NULL;
					const gchar* _tmp14_ = NULL;
					gchar* _tmp15_ = NULL;
					gchar* _tmp16_ = NULL;
					_tmp13_ = enum_value;
					_tmp14_ = (*_tmp13_).value_nick;
					_tmp15_ = g_strconcat ("convert-", _tmp14_, NULL);
					_tmp16_ = _tmp15_;
					kkc_state_handler_register_command_callback ((KkcStateHandler*) self, _tmp16_, _kkc_convert_segment_state_handler_do_clear_unhandled_kkc_command_callback, self);
					_g_free0 (_tmp16_);
				}
				_g_free0 (enum_value);
			}
		}
	}
	kkc_state_handler_register_command_callback ((KkcStateHandler*) self, NULL, _kkc_convert_segment_state_handler_do_select_unhandled_kkc_command_callback, self);
	_g_type_class_unref0 (enum_class);
	return obj;
}


static void kkc_convert_segment_state_handler_class_init (KkcConvertSegmentStateHandlerClass * klass) {
	kkc_convert_segment_state_handler_parent_class = g_type_class_peek_parent (klass);
	((KkcStateHandlerClass *) klass)->process_key_event = kkc_convert_segment_state_handler_real_process_key_event;
	G_OBJECT_CLASS (klass)->constructor = kkc_convert_segment_state_handler_constructor;
}


static void kkc_convert_segment_state_handler_instance_init (KkcConvertSegmentStateHandler * self) {
}


GType kkc_convert_segment_state_handler_get_type (void) {
	static volatile gsize kkc_convert_segment_state_handler_type_id__volatile = 0;
	if (g_once_init_enter (&kkc_convert_segment_state_handler_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (KkcConvertSegmentStateHandlerClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) kkc_convert_segment_state_handler_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (KkcConvertSegmentStateHandler), 0, (GInstanceInitFunc) kkc_convert_segment_state_handler_instance_init, NULL };
		GType kkc_convert_segment_state_handler_type_id;
		kkc_convert_segment_state_handler_type_id = g_type_register_static (KKC_TYPE_STATE_HANDLER, "KkcConvertSegmentStateHandler", &g_define_type_info, 0);
		g_once_init_leave (&kkc_convert_segment_state_handler_type_id__volatile, kkc_convert_segment_state_handler_type_id);
	}
	return kkc_convert_segment_state_handler_type_id__volatile;
}



