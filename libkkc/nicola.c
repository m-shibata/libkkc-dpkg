/* nicola.c generated by valac 0.21.1.40-3bbfb, the Vala compiler
 * generated from nicola.vala, do not modify */

/*
 * Copyright (C) 2011-2013 Daiki Ueno <ueno@gnu.org>
 * Copyright (C) 2011-2013 Red Hat, Inc.
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */

#include <glib.h>
#include <glib-object.h>
#include <gee.h>
#include <stdlib.h>
#include <string.h>
#include <gobject/gvaluecollector.h>


#define KKC_TYPE_KEY_EVENT_FILTER (kkc_key_event_filter_get_type ())
#define KKC_KEY_EVENT_FILTER(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), KKC_TYPE_KEY_EVENT_FILTER, KkcKeyEventFilter))
#define KKC_KEY_EVENT_FILTER_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), KKC_TYPE_KEY_EVENT_FILTER, KkcKeyEventFilterClass))
#define KKC_IS_KEY_EVENT_FILTER(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), KKC_TYPE_KEY_EVENT_FILTER))
#define KKC_IS_KEY_EVENT_FILTER_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), KKC_TYPE_KEY_EVENT_FILTER))
#define KKC_KEY_EVENT_FILTER_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), KKC_TYPE_KEY_EVENT_FILTER, KkcKeyEventFilterClass))

typedef struct _KkcKeyEventFilter KkcKeyEventFilter;
typedef struct _KkcKeyEventFilterClass KkcKeyEventFilterClass;
typedef struct _KkcKeyEventFilterPrivate KkcKeyEventFilterPrivate;

#define KKC_TYPE_KEY_EVENT (kkc_key_event_get_type ())
#define KKC_KEY_EVENT(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), KKC_TYPE_KEY_EVENT, KkcKeyEvent))
#define KKC_KEY_EVENT_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), KKC_TYPE_KEY_EVENT, KkcKeyEventClass))
#define KKC_IS_KEY_EVENT(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), KKC_TYPE_KEY_EVENT))
#define KKC_IS_KEY_EVENT_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), KKC_TYPE_KEY_EVENT))
#define KKC_KEY_EVENT_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), KKC_TYPE_KEY_EVENT, KkcKeyEventClass))

typedef struct _KkcKeyEvent KkcKeyEvent;
typedef struct _KkcKeyEventClass KkcKeyEventClass;

#define KKC_TYPE_NICOLA_KEY_EVENT_FILTER (kkc_nicola_key_event_filter_get_type ())
#define KKC_NICOLA_KEY_EVENT_FILTER(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), KKC_TYPE_NICOLA_KEY_EVENT_FILTER, KkcNicolaKeyEventFilter))
#define KKC_NICOLA_KEY_EVENT_FILTER_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), KKC_TYPE_NICOLA_KEY_EVENT_FILTER, KkcNicolaKeyEventFilterClass))
#define KKC_IS_NICOLA_KEY_EVENT_FILTER(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), KKC_TYPE_NICOLA_KEY_EVENT_FILTER))
#define KKC_IS_NICOLA_KEY_EVENT_FILTER_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), KKC_TYPE_NICOLA_KEY_EVENT_FILTER))
#define KKC_NICOLA_KEY_EVENT_FILTER_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), KKC_TYPE_NICOLA_KEY_EVENT_FILTER, KkcNicolaKeyEventFilterClass))

typedef struct _KkcNicolaKeyEventFilter KkcNicolaKeyEventFilter;
typedef struct _KkcNicolaKeyEventFilterClass KkcNicolaKeyEventFilterClass;
typedef struct _KkcNicolaKeyEventFilterPrivate KkcNicolaKeyEventFilterPrivate;

#define KKC_NICOLA_KEY_EVENT_FILTER_TYPE_TIMED_ENTRY (kkc_nicola_key_event_filter_timed_entry_get_type ())
#define KKC_NICOLA_KEY_EVENT_FILTER_TIMED_ENTRY(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), KKC_NICOLA_KEY_EVENT_FILTER_TYPE_TIMED_ENTRY, KkcNicolaKeyEventFilterTimedEntry))
#define KKC_NICOLA_KEY_EVENT_FILTER_TIMED_ENTRY_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), KKC_NICOLA_KEY_EVENT_FILTER_TYPE_TIMED_ENTRY, KkcNicolaKeyEventFilterTimedEntryClass))
#define KKC_NICOLA_KEY_EVENT_FILTER_IS_TIMED_ENTRY(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), KKC_NICOLA_KEY_EVENT_FILTER_TYPE_TIMED_ENTRY))
#define KKC_NICOLA_KEY_EVENT_FILTER_IS_TIMED_ENTRY_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), KKC_NICOLA_KEY_EVENT_FILTER_TYPE_TIMED_ENTRY))
#define KKC_NICOLA_KEY_EVENT_FILTER_TIMED_ENTRY_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), KKC_NICOLA_KEY_EVENT_FILTER_TYPE_TIMED_ENTRY, KkcNicolaKeyEventFilterTimedEntryClass))

typedef struct _KkcNicolaKeyEventFilterTimedEntry KkcNicolaKeyEventFilterTimedEntry;
typedef struct _KkcNicolaKeyEventFilterTimedEntryClass KkcNicolaKeyEventFilterTimedEntryClass;
#define _g_object_unref0(var) ((var == NULL) ? NULL : (var = (g_object_unref (var), NULL)))

#define KKC_TYPE_MODIFIER_TYPE (kkc_modifier_type_get_type ())
typedef struct _KkcNicolaKeyEventFilterTimedEntryPrivate KkcNicolaKeyEventFilterTimedEntryPrivate;
#define _kkc_nicola_key_event_filter_timed_entry_unref0(var) ((var == NULL) ? NULL : (var = (kkc_nicola_key_event_filter_timed_entry_unref (var), NULL)))
#define _t_destroy_func0(var) (((var == NULL) || (t_destroy_func == NULL)) ? NULL : (var = (t_destroy_func (var), NULL)))
typedef struct _KkcNicolaKeyEventFilterParamSpecTimedEntry KkcNicolaKeyEventFilterParamSpecTimedEntry;

typedef gint64 (*KkcGetTime) (void* user_data);
struct _KkcKeyEventFilter {
	GObject parent_instance;
	KkcKeyEventFilterPrivate * priv;
};

struct _KkcKeyEventFilterClass {
	GObjectClass parent_class;
	KkcKeyEvent* (*filter_key_event) (KkcKeyEventFilter* self, KkcKeyEvent* key);
	void (*reset) (KkcKeyEventFilter* self);
};

struct _KkcNicolaKeyEventFilter {
	KkcKeyEventFilter parent_instance;
	KkcNicolaKeyEventFilterPrivate * priv;
	KkcGetTime get_time_func;
	gpointer get_time_func_target;
	GDestroyNotify get_time_func_target_destroy_notify;
	gint64 timeout;
	gint64 overlap;
	gint64 maxwait;
};

struct _KkcNicolaKeyEventFilterClass {
	KkcKeyEventFilterClass parent_class;
};

struct _KkcNicolaKeyEventFilterPrivate {
	GeeLinkedList* pending;
	guint timeout_id;
};

typedef enum  {
	KKC_MODIFIER_TYPE_NONE = 0,
	KKC_MODIFIER_TYPE_SHIFT_MASK = 1 << 0,
	KKC_MODIFIER_TYPE_LOCK_MASK = 1 << 1,
	KKC_MODIFIER_TYPE_CONTROL_MASK = 1 << 2,
	KKC_MODIFIER_TYPE_MOD1_MASK = 1 << 3,
	KKC_MODIFIER_TYPE_MOD2_MASK = 1 << 4,
	KKC_MODIFIER_TYPE_MOD3_MASK = 1 << 5,
	KKC_MODIFIER_TYPE_MOD4_MASK = 1 << 6,
	KKC_MODIFIER_TYPE_MOD5_MASK = 1 << 7,
	KKC_MODIFIER_TYPE_LSHIFT_MASK = 1 << 22,
	KKC_MODIFIER_TYPE_RSHIFT_MASK = 1 << 23,
	KKC_MODIFIER_TYPE_SUPER_MASK = 1 << 26,
	KKC_MODIFIER_TYPE_HYPER_MASK = 1 << 27,
	KKC_MODIFIER_TYPE_META_MASK = 1 << 28,
	KKC_MODIFIER_TYPE_RELEASE_MASK = 1 << 30
} KkcModifierType;

struct _KkcNicolaKeyEventFilterTimedEntry {
	GTypeInstance parent_instance;
	volatile int ref_count;
	KkcNicolaKeyEventFilterTimedEntryPrivate * priv;
	gpointer data;
	gint64 time;
};

struct _KkcNicolaKeyEventFilterTimedEntryClass {
	GTypeClass parent_class;
	void (*finalize) (KkcNicolaKeyEventFilterTimedEntry *self);
};

struct _KkcNicolaKeyEventFilterTimedEntryPrivate {
	GType t_type;
	GBoxedCopyFunc t_dup_func;
	GDestroyNotify t_destroy_func;
};

struct _KkcNicolaKeyEventFilterParamSpecTimedEntry {
	GParamSpec parent_instance;
};


static gpointer kkc_nicola_key_event_filter_parent_class = NULL;
static gpointer kkc_nicola_key_event_filter_timed_entry_parent_class = NULL;

GType kkc_key_event_filter_get_type (void) G_GNUC_CONST;
GType kkc_key_event_get_type (void) G_GNUC_CONST;
GType kkc_nicola_key_event_filter_get_type (void) G_GNUC_CONST;
static gpointer kkc_nicola_key_event_filter_timed_entry_ref (gpointer instance);
static void kkc_nicola_key_event_filter_timed_entry_unref (gpointer instance);
static GParamSpec* kkc_nicola_key_event_filter_param_spec_timed_entry (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags) G_GNUC_UNUSED;
static void kkc_nicola_key_event_filter_value_set_timed_entry (GValue* value, gpointer v_object) G_GNUC_UNUSED;
static void kkc_nicola_key_event_filter_value_take_timed_entry (GValue* value, gpointer v_object) G_GNUC_UNUSED;
static gpointer kkc_nicola_key_event_filter_value_get_timed_entry (const GValue* value) G_GNUC_UNUSED;
static GType kkc_nicola_key_event_filter_timed_entry_get_type (void) G_GNUC_CONST G_GNUC_UNUSED;
#define KKC_NICOLA_KEY_EVENT_FILTER_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), KKC_TYPE_NICOLA_KEY_EVENT_FILTER, KkcNicolaKeyEventFilterPrivate))
enum  {
	KKC_NICOLA_KEY_EVENT_FILTER_DUMMY_PROPERTY
};
static gint64 kkc_nicola_key_event_filter_get_time (void);
static gint64 _kkc_nicola_key_event_filter_get_time_kkc_get_time (gpointer self);
static gboolean kkc_nicola_key_event_filter_is_char (KkcKeyEvent* key);
gunichar kkc_key_event_get_unicode (KkcKeyEvent* self);
static gboolean kkc_nicola_key_event_filter_is_lshift (KkcKeyEvent* key);
const gchar* kkc_key_event_get_name (KkcKeyEvent* self);
static gboolean kkc_nicola_key_event_filter_is_rshift (KkcKeyEvent* key);
static gboolean kkc_nicola_key_event_filter_is_shift (KkcKeyEvent* key);
static KkcKeyEvent* kkc_nicola_key_event_filter_queue (KkcNicolaKeyEventFilter* self, KkcKeyEvent* key, gint64 time, gint64* wait);
GType kkc_modifier_type_get_type (void) G_GNUC_CONST;
KkcModifierType kkc_key_event_get_modifiers (KkcKeyEvent* self);
guint kkc_key_event_get_keyval (KkcKeyEvent* self);
static gint64 kkc_nicola_key_event_filter_get_next_wait (KkcNicolaKeyEventFilter* self, KkcKeyEvent* key, gint64 time);
static KkcNicolaKeyEventFilterTimedEntry* kkc_nicola_key_event_filter_timed_entry_new (GType t_type, GBoxedCopyFunc t_dup_func, GDestroyNotify t_destroy_func, gconstpointer data, gint64 time);
static KkcNicolaKeyEventFilterTimedEntry* kkc_nicola_key_event_filter_timed_entry_construct (GType object_type, GType t_type, GBoxedCopyFunc t_dup_func, GDestroyNotify t_destroy_func, gconstpointer data, gint64 time);
static KkcKeyEvent* kkc_nicola_key_event_filter_dispatch_single (KkcNicolaKeyEventFilter* self, gint64 time);
static void kkc_nicola_key_event_filter_apply_shift (KkcNicolaKeyEventFilter* self, KkcKeyEvent* s, KkcKeyEvent* c);
void kkc_key_event_set_modifiers (KkcKeyEvent* self, KkcModifierType value);
static KkcKeyEvent* kkc_nicola_key_event_filter_dispatch (KkcNicolaKeyEventFilter* self, gint64 time);
static KkcKeyEvent* kkc_nicola_key_event_filter_decompose_shifted (KkcNicolaKeyEventFilter* self, KkcKeyEvent* key);
static gboolean kkc_nicola_key_event_filter_timeout_func (KkcNicolaKeyEventFilter* self);
KkcKeyEvent* kkc_key_event_new_from_x_event (guint keyval, guint keycode, KkcModifierType modifiers);
KkcKeyEvent* kkc_key_event_construct_from_x_event (GType object_type, guint keyval, guint keycode, KkcModifierType modifiers);
static KkcKeyEvent* kkc_nicola_key_event_filter_real_filter_key_event (KkcKeyEventFilter* base, KkcKeyEvent* key);
static gboolean _kkc_nicola_key_event_filter_timeout_func_gsource_func (gpointer self);
static void kkc_nicola_key_event_filter_real_reset (KkcKeyEventFilter* base);
KkcNicolaKeyEventFilter* kkc_nicola_key_event_filter_new (void);
KkcNicolaKeyEventFilter* kkc_nicola_key_event_filter_construct (GType object_type);
KkcKeyEventFilter* kkc_key_event_filter_construct (GType object_type);
#define KKC_NICOLA_KEY_EVENT_FILTER_TIMED_ENTRY_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), KKC_NICOLA_KEY_EVENT_FILTER_TYPE_TIMED_ENTRY, KkcNicolaKeyEventFilterTimedEntryPrivate))
enum  {
	KKC_NICOLA_KEY_EVENT_FILTER_TIMED_ENTRY_DUMMY_PROPERTY
};
static void kkc_nicola_key_event_filter_timed_entry_finalize (KkcNicolaKeyEventFilterTimedEntry* obj);
static void kkc_nicola_key_event_filter_finalize (GObject* obj);


static gint64 _kkc_nicola_key_event_filter_get_time_kkc_get_time (gpointer self) {
	gint64 result;
	result = kkc_nicola_key_event_filter_get_time ();
	return result;
}


static gint64 kkc_nicola_key_event_filter_get_time (void) {
	gint64 result = 0LL;
	GTimeVal tv = {0};
	GTimeVal _tmp0_ = {0};
	glong _tmp1_ = 0L;
	GTimeVal _tmp2_ = {0};
	glong _tmp3_ = 0L;
	g_get_current_time (&tv);
	_tmp0_ = tv;
	_tmp1_ = _tmp0_.tv_sec;
	_tmp2_ = tv;
	_tmp3_ = _tmp2_.tv_usec;
	result = (((gint64) _tmp1_) * 1000000) + _tmp3_;
	return result;
}


static gboolean kkc_nicola_key_event_filter_is_char (KkcKeyEvent* key) {
	gboolean result = FALSE;
	KkcKeyEvent* _tmp0_ = NULL;
	gunichar _tmp1_ = 0U;
	gunichar _tmp2_ = 0U;
	g_return_val_if_fail (key != NULL, FALSE);
	_tmp0_ = key;
	_tmp1_ = kkc_key_event_get_unicode (_tmp0_);
	_tmp2_ = _tmp1_;
	result = _tmp2_ != ((gunichar) 0);
	return result;
}


static gboolean kkc_nicola_key_event_filter_is_lshift (KkcKeyEvent* key) {
	gboolean result = FALSE;
	KkcKeyEvent* _tmp0_ = NULL;
	const gchar* _tmp1_ = NULL;
	const gchar* _tmp2_ = NULL;
	g_return_val_if_fail (key != NULL, FALSE);
	_tmp0_ = key;
	_tmp1_ = kkc_key_event_get_name (_tmp0_);
	_tmp2_ = _tmp1_;
	result = g_strcmp0 (_tmp2_, "Muhenkan") == 0;
	return result;
}


static gboolean kkc_nicola_key_event_filter_is_rshift (KkcKeyEvent* key) {
	gboolean result = FALSE;
	KkcKeyEvent* _tmp0_ = NULL;
	const gchar* _tmp1_ = NULL;
	const gchar* _tmp2_ = NULL;
	g_return_val_if_fail (key != NULL, FALSE);
	_tmp0_ = key;
	_tmp1_ = kkc_key_event_get_name (_tmp0_);
	_tmp2_ = _tmp1_;
	result = g_strcmp0 (_tmp2_, "Henkan") == 0;
	return result;
}


static gboolean kkc_nicola_key_event_filter_is_shift (KkcKeyEvent* key) {
	gboolean result = FALSE;
	gboolean _tmp0_ = FALSE;
	KkcKeyEvent* _tmp1_ = NULL;
	gboolean _tmp2_ = FALSE;
	gboolean _tmp5_ = FALSE;
	g_return_val_if_fail (key != NULL, FALSE);
	_tmp1_ = key;
	_tmp2_ = kkc_nicola_key_event_filter_is_lshift (_tmp1_);
	if (_tmp2_) {
		_tmp0_ = TRUE;
	} else {
		KkcKeyEvent* _tmp3_ = NULL;
		gboolean _tmp4_ = FALSE;
		_tmp3_ = key;
		_tmp4_ = kkc_nicola_key_event_filter_is_rshift (_tmp3_);
		_tmp0_ = _tmp4_;
	}
	_tmp5_ = _tmp0_;
	result = _tmp5_;
	return result;
}


static gpointer _g_object_ref0 (gpointer self) {
	return self ? g_object_ref (self) : NULL;
}


static KkcKeyEvent* kkc_nicola_key_event_filter_queue (KkcNicolaKeyEventFilter* self, KkcKeyEvent* key, gint64 time, gint64* wait) {
	gint64 _vala_wait = 0LL;
	KkcKeyEvent* result = NULL;
	gboolean _tmp0_ = FALSE;
	gboolean _tmp1_ = FALSE;
	KkcKeyEvent* _tmp2_ = NULL;
	KkcModifierType _tmp3_ = 0;
	KkcModifierType _tmp4_ = 0;
	gboolean _tmp8_ = FALSE;
	gboolean _tmp18_ = FALSE;
	gboolean _tmp28_ = FALSE;
	GeeLinkedList* _tmp29_ = NULL;
	gint _tmp30_ = 0;
	gint _tmp31_ = 0;
	gboolean _tmp41_ = FALSE;
	GeeLinkedList* _tmp51_ = NULL;
	gint _tmp52_ = 0;
	gint _tmp53_ = 0;
	GeeLinkedList* _tmp67_ = NULL;
	KkcKeyEvent* _tmp68_ = NULL;
	gint64 _tmp69_ = 0LL;
	KkcNicolaKeyEventFilterTimedEntry* _tmp70_ = NULL;
	KkcNicolaKeyEventFilterTimedEntry* _tmp71_ = NULL;
	gint64 _tmp72_ = 0LL;
	g_return_val_if_fail (self != NULL, NULL);
	g_return_val_if_fail (key != NULL, NULL);
	_tmp2_ = key;
	_tmp3_ = kkc_key_event_get_modifiers (_tmp2_);
	_tmp4_ = _tmp3_;
	if ((_tmp4_ & KKC_MODIFIER_TYPE_RELEASE_MASK) != 0) {
		GeeLinkedList* _tmp5_ = NULL;
		gint _tmp6_ = 0;
		gint _tmp7_ = 0;
		_tmp5_ = self->priv->pending;
		_tmp6_ = gee_abstract_collection_get_size ((GeeCollection*) _tmp5_);
		_tmp7_ = _tmp6_;
		_tmp1_ = _tmp7_ > 0;
	} else {
		_tmp1_ = FALSE;
	}
	_tmp8_ = _tmp1_;
	if (_tmp8_) {
		GeeLinkedList* _tmp9_ = NULL;
		gpointer _tmp10_ = NULL;
		KkcNicolaKeyEventFilterTimedEntry* _tmp11_ = NULL;
		gconstpointer _tmp12_ = NULL;
		guint _tmp13_ = 0U;
		guint _tmp14_ = 0U;
		KkcKeyEvent* _tmp15_ = NULL;
		guint _tmp16_ = 0U;
		guint _tmp17_ = 0U;
		_tmp9_ = self->priv->pending;
		_tmp10_ = gee_abstract_list_get ((GeeAbstractList*) _tmp9_, 0);
		_tmp11_ = (KkcNicolaKeyEventFilterTimedEntry*) _tmp10_;
		_tmp12_ = _tmp11_->data;
		_tmp13_ = kkc_key_event_get_keyval ((KkcKeyEvent*) _tmp12_);
		_tmp14_ = _tmp13_;
		_tmp15_ = key;
		_tmp16_ = kkc_key_event_get_keyval (_tmp15_);
		_tmp17_ = _tmp16_;
		_tmp0_ = _tmp14_ == _tmp17_;
		_kkc_nicola_key_event_filter_timed_entry_unref0 (_tmp11_);
	} else {
		_tmp0_ = FALSE;
	}
	_tmp18_ = _tmp0_;
	if (_tmp18_) {
		KkcNicolaKeyEventFilterTimedEntry* entry = NULL;
		GeeLinkedList* _tmp19_ = NULL;
		gpointer _tmp20_ = NULL;
		KkcKeyEvent* _tmp21_ = NULL;
		gint64 _tmp22_ = 0LL;
		gint64 _tmp23_ = 0LL;
		GeeLinkedList* _tmp24_ = NULL;
		KkcNicolaKeyEventFilterTimedEntry* _tmp25_ = NULL;
		gconstpointer _tmp26_ = NULL;
		KkcKeyEvent* _tmp27_ = NULL;
		_tmp19_ = self->priv->pending;
		_tmp20_ = gee_abstract_list_get ((GeeAbstractList*) _tmp19_, 0);
		entry = (KkcNicolaKeyEventFilterTimedEntry*) _tmp20_;
		_tmp21_ = key;
		_tmp22_ = time;
		_tmp23_ = kkc_nicola_key_event_filter_get_next_wait (self, _tmp21_, _tmp22_);
		_vala_wait = _tmp23_;
		_tmp24_ = self->priv->pending;
		gee_abstract_collection_clear ((GeeAbstractCollection*) _tmp24_);
		_tmp25_ = entry;
		_tmp26_ = _tmp25_->data;
		_tmp27_ = _g_object_ref0 ((KkcKeyEvent*) _tmp26_);
		result = _tmp27_;
		_kkc_nicola_key_event_filter_timed_entry_unref0 (entry);
		if (wait) {
			*wait = _vala_wait;
		}
		return result;
	}
	_tmp29_ = self->priv->pending;
	_tmp30_ = gee_abstract_collection_get_size ((GeeCollection*) _tmp29_);
	_tmp31_ = _tmp30_;
	if (_tmp31_ > 0) {
		GeeLinkedList* _tmp32_ = NULL;
		gpointer _tmp33_ = NULL;
		KkcNicolaKeyEventFilterTimedEntry* _tmp34_ = NULL;
		gconstpointer _tmp35_ = NULL;
		guint _tmp36_ = 0U;
		guint _tmp37_ = 0U;
		KkcKeyEvent* _tmp38_ = NULL;
		guint _tmp39_ = 0U;
		guint _tmp40_ = 0U;
		_tmp32_ = self->priv->pending;
		_tmp33_ = gee_abstract_list_get ((GeeAbstractList*) _tmp32_, 0);
		_tmp34_ = (KkcNicolaKeyEventFilterTimedEntry*) _tmp33_;
		_tmp35_ = _tmp34_->data;
		_tmp36_ = kkc_key_event_get_keyval ((KkcKeyEvent*) _tmp35_);
		_tmp37_ = _tmp36_;
		_tmp38_ = key;
		_tmp39_ = kkc_key_event_get_keyval (_tmp38_);
		_tmp40_ = _tmp39_;
		_tmp28_ = _tmp37_ == _tmp40_;
		_kkc_nicola_key_event_filter_timed_entry_unref0 (_tmp34_);
	} else {
		_tmp28_ = FALSE;
	}
	_tmp41_ = _tmp28_;
	if (_tmp41_) {
		GeeLinkedList* _tmp42_ = NULL;
		gpointer _tmp43_ = NULL;
		KkcNicolaKeyEventFilterTimedEntry* _tmp44_ = NULL;
		gint64 _tmp45_ = 0LL;
		KkcKeyEvent* _tmp46_ = NULL;
		gint64 _tmp47_ = 0LL;
		gint64 _tmp48_ = 0LL;
		KkcKeyEvent* _tmp49_ = NULL;
		KkcKeyEvent* _tmp50_ = NULL;
		_tmp42_ = self->priv->pending;
		_tmp43_ = gee_abstract_list_get ((GeeAbstractList*) _tmp42_, 0);
		_tmp44_ = (KkcNicolaKeyEventFilterTimedEntry*) _tmp43_;
		_tmp45_ = time;
		_tmp44_->time = _tmp45_;
		_kkc_nicola_key_event_filter_timed_entry_unref0 (_tmp44_);
		_tmp46_ = key;
		_tmp47_ = time;
		_tmp48_ = kkc_nicola_key_event_filter_get_next_wait (self, _tmp46_, _tmp47_);
		_vala_wait = _tmp48_;
		_tmp49_ = key;
		_tmp50_ = _g_object_ref0 (_tmp49_);
		result = _tmp50_;
		if (wait) {
			*wait = _vala_wait;
		}
		return result;
	}
	_tmp51_ = self->priv->pending;
	_tmp52_ = gee_abstract_collection_get_size ((GeeCollection*) _tmp51_);
	_tmp53_ = _tmp52_;
	if (_tmp53_ > 2) {
		GeeListIterator* iter = NULL;
		GeeLinkedList* _tmp54_ = NULL;
		GeeListIterator* _tmp55_ = NULL;
		GeeListIterator* _tmp56_ = NULL;
		_tmp54_ = self->priv->pending;
		_tmp55_ = gee_abstract_list_list_iterator ((GeeAbstractList*) _tmp54_);
		iter = _tmp55_;
		_tmp56_ = iter;
		gee_bidir_iterator_last ((GeeBidirIterator*) _tmp56_);
		{
			gboolean _tmp57_ = FALSE;
			_tmp57_ = TRUE;
			while (TRUE) {
				gboolean _tmp58_ = FALSE;
				GeeListIterator* _tmp66_ = NULL;
				_tmp58_ = _tmp57_;
				if (!_tmp58_) {
					gboolean _tmp59_ = FALSE;
					GeeLinkedList* _tmp60_ = NULL;
					gint _tmp61_ = 0;
					gint _tmp62_ = 0;
					gboolean _tmp65_ = FALSE;
					_tmp60_ = self->priv->pending;
					_tmp61_ = gee_abstract_collection_get_size ((GeeCollection*) _tmp60_);
					_tmp62_ = _tmp61_;
					if (_tmp62_ > 2) {
						GeeListIterator* _tmp63_ = NULL;
						gboolean _tmp64_ = FALSE;
						_tmp63_ = iter;
						_tmp64_ = gee_bidir_iterator_previous ((GeeBidirIterator*) _tmp63_);
						_tmp59_ = _tmp64_;
					} else {
						_tmp59_ = FALSE;
					}
					_tmp65_ = _tmp59_;
					if (!_tmp65_) {
						break;
					}
				}
				_tmp57_ = FALSE;
				_tmp66_ = iter;
				gee_iterator_remove ((GeeIterator*) _tmp66_);
			}
		}
		_g_object_unref0 (iter);
	}
	_tmp67_ = self->priv->pending;
	_tmp68_ = key;
	_tmp69_ = time;
	_tmp70_ = kkc_nicola_key_event_filter_timed_entry_new (KKC_TYPE_KEY_EVENT, (GBoxedCopyFunc) g_object_ref, g_object_unref, _tmp68_, _tmp69_);
	_tmp71_ = _tmp70_;
	gee_abstract_list_insert ((GeeAbstractList*) _tmp67_, 0, _tmp71_);
	_kkc_nicola_key_event_filter_timed_entry_unref0 (_tmp71_);
	_tmp72_ = self->timeout;
	_vala_wait = _tmp72_;
	result = NULL;
	if (wait) {
		*wait = _vala_wait;
	}
	return result;
}


static gint64 kkc_nicola_key_event_filter_get_next_wait (KkcNicolaKeyEventFilter* self, KkcKeyEvent* key, gint64 time) {
	gint64 result = 0LL;
	GeeLinkedList* _tmp0_ = NULL;
	gint _tmp1_ = 0;
	gint _tmp2_ = 0;
	GeeLinkedList* _tmp17_ = NULL;
	gint _tmp18_ = 0;
	gint _tmp19_ = 0;
	g_return_val_if_fail (self != NULL, 0LL);
	g_return_val_if_fail (key != NULL, 0LL);
	_tmp0_ = self->priv->pending;
	_tmp1_ = gee_abstract_collection_get_size ((GeeCollection*) _tmp0_);
	_tmp2_ = _tmp1_;
	if (_tmp2_ > 0) {
		GeeListIterator* iter = NULL;
		GeeLinkedList* _tmp3_ = NULL;
		GeeListIterator* _tmp4_ = NULL;
		GeeListIterator* _tmp5_ = NULL;
		_tmp3_ = self->priv->pending;
		_tmp4_ = gee_abstract_list_list_iterator ((GeeAbstractList*) _tmp3_);
		iter = _tmp4_;
		_tmp5_ = iter;
		gee_bidir_iterator_last ((GeeBidirIterator*) _tmp5_);
		{
			gboolean _tmp6_ = FALSE;
			_tmp6_ = TRUE;
			while (TRUE) {
				gboolean _tmp7_ = FALSE;
				KkcNicolaKeyEventFilterTimedEntry* entry = NULL;
				GeeListIterator* _tmp10_ = NULL;
				gpointer _tmp11_ = NULL;
				gint64 _tmp12_ = 0LL;
				KkcNicolaKeyEventFilterTimedEntry* _tmp13_ = NULL;
				gint64 _tmp14_ = 0LL;
				gint64 _tmp15_ = 0LL;
				_tmp7_ = _tmp6_;
				if (!_tmp7_) {
					GeeListIterator* _tmp8_ = NULL;
					gboolean _tmp9_ = FALSE;
					_tmp8_ = iter;
					_tmp9_ = gee_bidir_iterator_previous ((GeeBidirIterator*) _tmp8_);
					if (!_tmp9_) {
						break;
					}
				}
				_tmp6_ = FALSE;
				_tmp10_ = iter;
				_tmp11_ = gee_iterator_get ((GeeIterator*) _tmp10_);
				entry = (KkcNicolaKeyEventFilterTimedEntry*) _tmp11_;
				_tmp12_ = time;
				_tmp13_ = entry;
				_tmp14_ = _tmp13_->time;
				_tmp15_ = self->timeout;
				if ((_tmp12_ - _tmp14_) > _tmp15_) {
					GeeListIterator* _tmp16_ = NULL;
					_tmp16_ = iter;
					gee_iterator_remove ((GeeIterator*) _tmp16_);
				}
				_kkc_nicola_key_event_filter_timed_entry_unref0 (entry);
			}
		}
		_g_object_unref0 (iter);
	}
	_tmp17_ = self->priv->pending;
	_tmp18_ = gee_abstract_collection_get_size ((GeeCollection*) _tmp17_);
	_tmp19_ = _tmp18_;
	if (_tmp19_ > 0) {
		gint64 _tmp20_ = 0LL;
		gint64 _tmp21_ = 0LL;
		GeeLinkedList* _tmp22_ = NULL;
		gpointer _tmp23_ = NULL;
		KkcNicolaKeyEventFilterTimedEntry* _tmp24_ = NULL;
		gint64 _tmp25_ = 0LL;
		gint64 _tmp26_ = 0LL;
		_tmp20_ = self->timeout;
		_tmp21_ = time;
		_tmp22_ = self->priv->pending;
		_tmp23_ = gee_abstract_list_last ((GeeAbstractList*) _tmp22_);
		_tmp24_ = (KkcNicolaKeyEventFilterTimedEntry*) _tmp23_;
		_tmp25_ = _tmp24_->time;
		_tmp26_ = _tmp20_ - (_tmp21_ - _tmp25_);
		_kkc_nicola_key_event_filter_timed_entry_unref0 (_tmp24_);
		result = _tmp26_;
		return result;
	} else {
		gint64 _tmp27_ = 0LL;
		_tmp27_ = self->maxwait;
		result = _tmp27_;
		return result;
	}
}


static KkcKeyEvent* kkc_nicola_key_event_filter_dispatch_single (KkcNicolaKeyEventFilter* self, gint64 time) {
	KkcKeyEvent* result = NULL;
	KkcNicolaKeyEventFilterTimedEntry* entry = NULL;
	GeeLinkedList* _tmp0_ = NULL;
	gpointer _tmp1_ = NULL;
	gint64 _tmp2_ = 0LL;
	KkcNicolaKeyEventFilterTimedEntry* _tmp3_ = NULL;
	gint64 _tmp4_ = 0LL;
	gint64 _tmp5_ = 0LL;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = self->priv->pending;
	_tmp1_ = gee_queue_peek ((GeeQueue*) _tmp0_);
	entry = (KkcNicolaKeyEventFilterTimedEntry*) _tmp1_;
	_tmp2_ = time;
	_tmp3_ = entry;
	_tmp4_ = _tmp3_->time;
	_tmp5_ = self->timeout;
	if ((_tmp2_ - _tmp4_) > _tmp5_) {
		GeeLinkedList* _tmp6_ = NULL;
		KkcNicolaKeyEventFilterTimedEntry* _tmp7_ = NULL;
		gconstpointer _tmp8_ = NULL;
		KkcKeyEvent* _tmp9_ = NULL;
		_tmp6_ = self->priv->pending;
		gee_abstract_collection_clear ((GeeAbstractCollection*) _tmp6_);
		_tmp7_ = entry;
		_tmp8_ = _tmp7_->data;
		_tmp9_ = _g_object_ref0 ((KkcKeyEvent*) _tmp8_);
		result = _tmp9_;
		_kkc_nicola_key_event_filter_timed_entry_unref0 (entry);
		return result;
	}
	result = NULL;
	_kkc_nicola_key_event_filter_timed_entry_unref0 (entry);
	return result;
}


static void kkc_nicola_key_event_filter_apply_shift (KkcNicolaKeyEventFilter* self, KkcKeyEvent* s, KkcKeyEvent* c) {
	KkcKeyEvent* _tmp0_ = NULL;
	gboolean _tmp1_ = FALSE;
	g_return_if_fail (self != NULL);
	g_return_if_fail (s != NULL);
	g_return_if_fail (c != NULL);
	_tmp0_ = s;
	_tmp1_ = kkc_nicola_key_event_filter_is_lshift (_tmp0_);
	if (_tmp1_) {
		KkcKeyEvent* _tmp2_ = NULL;
		KkcKeyEvent* _tmp3_ = NULL;
		KkcModifierType _tmp4_ = 0;
		KkcModifierType _tmp5_ = 0;
		_tmp2_ = c;
		_tmp3_ = c;
		_tmp4_ = kkc_key_event_get_modifiers (_tmp3_);
		_tmp5_ = _tmp4_;
		kkc_key_event_set_modifiers (_tmp3_, _tmp5_ | KKC_MODIFIER_TYPE_LSHIFT_MASK);
	} else {
		KkcKeyEvent* _tmp6_ = NULL;
		gboolean _tmp7_ = FALSE;
		_tmp6_ = s;
		_tmp7_ = kkc_nicola_key_event_filter_is_rshift (_tmp6_);
		if (_tmp7_) {
			KkcKeyEvent* _tmp8_ = NULL;
			KkcKeyEvent* _tmp9_ = NULL;
			KkcModifierType _tmp10_ = 0;
			KkcModifierType _tmp11_ = 0;
			_tmp8_ = c;
			_tmp9_ = c;
			_tmp10_ = kkc_key_event_get_modifiers (_tmp9_);
			_tmp11_ = _tmp10_;
			kkc_key_event_set_modifiers (_tmp9_, _tmp11_ | KKC_MODIFIER_TYPE_RSHIFT_MASK);
		}
	}
}


static KkcKeyEvent* kkc_nicola_key_event_filter_dispatch (KkcNicolaKeyEventFilter* self, gint64 time) {
	KkcKeyEvent* result = NULL;
	GeeLinkedList* _tmp0_ = NULL;
	gint _tmp1_ = 0;
	gint _tmp2_ = 0;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = self->priv->pending;
	_tmp1_ = gee_abstract_collection_get_size ((GeeCollection*) _tmp0_);
	_tmp2_ = _tmp1_;
	if (_tmp2_ == 3) {
		KkcNicolaKeyEventFilterTimedEntry* b = NULL;
		GeeLinkedList* _tmp3_ = NULL;
		gpointer _tmp4_ = NULL;
		KkcNicolaKeyEventFilterTimedEntry* s = NULL;
		GeeLinkedList* _tmp5_ = NULL;
		gpointer _tmp6_ = NULL;
		KkcNicolaKeyEventFilterTimedEntry* a = NULL;
		GeeLinkedList* _tmp7_ = NULL;
		gpointer _tmp8_ = NULL;
		gint64 t1 = 0LL;
		KkcNicolaKeyEventFilterTimedEntry* _tmp9_ = NULL;
		gint64 _tmp10_ = 0LL;
		KkcNicolaKeyEventFilterTimedEntry* _tmp11_ = NULL;
		gint64 _tmp12_ = 0LL;
		gint64 t2 = 0LL;
		KkcNicolaKeyEventFilterTimedEntry* _tmp13_ = NULL;
		gint64 _tmp14_ = 0LL;
		KkcNicolaKeyEventFilterTimedEntry* _tmp15_ = NULL;
		gint64 _tmp16_ = 0LL;
		gint64 _tmp17_ = 0LL;
		gint64 _tmp18_ = 0LL;
		_tmp3_ = self->priv->pending;
		_tmp4_ = gee_abstract_list_get ((GeeAbstractList*) _tmp3_, 0);
		b = (KkcNicolaKeyEventFilterTimedEntry*) _tmp4_;
		_tmp5_ = self->priv->pending;
		_tmp6_ = gee_abstract_list_get ((GeeAbstractList*) _tmp5_, 1);
		s = (KkcNicolaKeyEventFilterTimedEntry*) _tmp6_;
		_tmp7_ = self->priv->pending;
		_tmp8_ = gee_abstract_list_get ((GeeAbstractList*) _tmp7_, 2);
		a = (KkcNicolaKeyEventFilterTimedEntry*) _tmp8_;
		_tmp9_ = s;
		_tmp10_ = _tmp9_->time;
		_tmp11_ = a;
		_tmp12_ = _tmp11_->time;
		t1 = _tmp10_ - _tmp12_;
		_tmp13_ = b;
		_tmp14_ = _tmp13_->time;
		_tmp15_ = s;
		_tmp16_ = _tmp15_->time;
		t2 = _tmp14_ - _tmp16_;
		_tmp17_ = t1;
		_tmp18_ = t2;
		if (_tmp17_ <= _tmp18_) {
			GeeLinkedList* _tmp19_ = NULL;
			GeeLinkedList* _tmp20_ = NULL;
			KkcNicolaKeyEventFilterTimedEntry* _tmp21_ = NULL;
			KkcKeyEvent* r = NULL;
			gint64 _tmp22_ = 0LL;
			KkcKeyEvent* _tmp23_ = NULL;
			KkcNicolaKeyEventFilterTimedEntry* _tmp24_ = NULL;
			gconstpointer _tmp25_ = NULL;
			KkcNicolaKeyEventFilterTimedEntry* _tmp26_ = NULL;
			gconstpointer _tmp27_ = NULL;
			KkcKeyEvent* output = NULL;
			KkcNicolaKeyEventFilterTimedEntry* _tmp28_ = NULL;
			gconstpointer _tmp29_ = NULL;
			KkcKeyEvent* _tmp30_ = NULL;
			KkcKeyEvent* _tmp31_ = NULL;
			_tmp19_ = self->priv->pending;
			gee_abstract_collection_clear ((GeeAbstractCollection*) _tmp19_);
			_tmp20_ = self->priv->pending;
			_tmp21_ = b;
			gee_deque_offer_head ((GeeDeque*) _tmp20_, _tmp21_);
			_tmp22_ = time;
			_tmp23_ = kkc_nicola_key_event_filter_dispatch_single (self, _tmp22_);
			r = _tmp23_;
			_tmp24_ = s;
			_tmp25_ = _tmp24_->data;
			_tmp26_ = a;
			_tmp27_ = _tmp26_->data;
			kkc_nicola_key_event_filter_apply_shift (self, (KkcKeyEvent*) _tmp25_, (KkcKeyEvent*) _tmp27_);
			_tmp28_ = a;
			_tmp29_ = _tmp28_->data;
			_tmp30_ = kkc_nicola_key_event_filter_decompose_shifted (self, (KkcKeyEvent*) _tmp29_);
			output = _tmp30_;
			_tmp31_ = output;
			g_signal_emit_by_name ((KkcKeyEventFilter*) self, "forwarded", _tmp31_);
			result = r;
			_g_object_unref0 (output);
			_kkc_nicola_key_event_filter_timed_entry_unref0 (a);
			_kkc_nicola_key_event_filter_timed_entry_unref0 (s);
			_kkc_nicola_key_event_filter_timed_entry_unref0 (b);
			return result;
		} else {
			GeeLinkedList* _tmp32_ = NULL;
			KkcNicolaKeyEventFilterTimedEntry* _tmp33_ = NULL;
			gconstpointer _tmp34_ = NULL;
			KkcNicolaKeyEventFilterTimedEntry* _tmp35_ = NULL;
			gconstpointer _tmp36_ = NULL;
			KkcKeyEvent* output = NULL;
			KkcNicolaKeyEventFilterTimedEntry* _tmp37_ = NULL;
			gconstpointer _tmp38_ = NULL;
			KkcKeyEvent* _tmp39_ = NULL;
			KkcKeyEvent* _tmp40_ = NULL;
			KkcNicolaKeyEventFilterTimedEntry* _tmp41_ = NULL;
			gconstpointer _tmp42_ = NULL;
			KkcKeyEvent* _tmp43_ = NULL;
			_tmp32_ = self->priv->pending;
			gee_abstract_collection_clear ((GeeAbstractCollection*) _tmp32_);
			_tmp33_ = s;
			_tmp34_ = _tmp33_->data;
			_tmp35_ = b;
			_tmp36_ = _tmp35_->data;
			kkc_nicola_key_event_filter_apply_shift (self, (KkcKeyEvent*) _tmp34_, (KkcKeyEvent*) _tmp36_);
			_tmp37_ = a;
			_tmp38_ = _tmp37_->data;
			_tmp39_ = kkc_nicola_key_event_filter_decompose_shifted (self, (KkcKeyEvent*) _tmp38_);
			output = _tmp39_;
			_tmp40_ = output;
			g_signal_emit_by_name ((KkcKeyEventFilter*) self, "forwarded", _tmp40_);
			_tmp41_ = b;
			_tmp42_ = _tmp41_->data;
			_tmp43_ = _g_object_ref0 ((KkcKeyEvent*) _tmp42_);
			result = _tmp43_;
			_g_object_unref0 (output);
			_kkc_nicola_key_event_filter_timed_entry_unref0 (a);
			_kkc_nicola_key_event_filter_timed_entry_unref0 (s);
			_kkc_nicola_key_event_filter_timed_entry_unref0 (b);
			return result;
		}
		_kkc_nicola_key_event_filter_timed_entry_unref0 (a);
		_kkc_nicola_key_event_filter_timed_entry_unref0 (s);
		_kkc_nicola_key_event_filter_timed_entry_unref0 (b);
	} else {
		GeeLinkedList* _tmp44_ = NULL;
		gint _tmp45_ = 0;
		gint _tmp46_ = 0;
		_tmp44_ = self->priv->pending;
		_tmp45_ = gee_abstract_collection_get_size ((GeeCollection*) _tmp44_);
		_tmp46_ = _tmp45_;
		if (_tmp46_ == 2) {
			KkcNicolaKeyEventFilterTimedEntry* b = NULL;
			GeeLinkedList* _tmp47_ = NULL;
			gpointer _tmp48_ = NULL;
			KkcNicolaKeyEventFilterTimedEntry* a = NULL;
			GeeLinkedList* _tmp49_ = NULL;
			gpointer _tmp50_ = NULL;
			KkcNicolaKeyEventFilterTimedEntry* _tmp51_ = NULL;
			gint64 _tmp52_ = 0LL;
			KkcNicolaKeyEventFilterTimedEntry* _tmp53_ = NULL;
			gint64 _tmp54_ = 0LL;
			gint64 _tmp55_ = 0LL;
			_tmp47_ = self->priv->pending;
			_tmp48_ = gee_abstract_list_get ((GeeAbstractList*) _tmp47_, 0);
			b = (KkcNicolaKeyEventFilterTimedEntry*) _tmp48_;
			_tmp49_ = self->priv->pending;
			_tmp50_ = gee_abstract_list_get ((GeeAbstractList*) _tmp49_, 1);
			a = (KkcNicolaKeyEventFilterTimedEntry*) _tmp50_;
			_tmp51_ = b;
			_tmp52_ = _tmp51_->time;
			_tmp53_ = a;
			_tmp54_ = _tmp53_->time;
			_tmp55_ = self->overlap;
			if ((_tmp52_ - _tmp54_) > _tmp55_) {
				GeeLinkedList* _tmp56_ = NULL;
				GeeLinkedList* _tmp57_ = NULL;
				KkcNicolaKeyEventFilterTimedEntry* _tmp58_ = NULL;
				KkcKeyEvent* r = NULL;
				gint64 _tmp59_ = 0LL;
				KkcKeyEvent* _tmp60_ = NULL;
				KkcKeyEvent* output = NULL;
				KkcNicolaKeyEventFilterTimedEntry* _tmp61_ = NULL;
				gconstpointer _tmp62_ = NULL;
				KkcKeyEvent* _tmp63_ = NULL;
				KkcKeyEvent* _tmp64_ = NULL;
				_tmp56_ = self->priv->pending;
				gee_abstract_collection_clear ((GeeAbstractCollection*) _tmp56_);
				_tmp57_ = self->priv->pending;
				_tmp58_ = b;
				gee_deque_offer_head ((GeeDeque*) _tmp57_, _tmp58_);
				_tmp59_ = time;
				_tmp60_ = kkc_nicola_key_event_filter_dispatch_single (self, _tmp59_);
				r = _tmp60_;
				_tmp61_ = a;
				_tmp62_ = _tmp61_->data;
				_tmp63_ = kkc_nicola_key_event_filter_decompose_shifted (self, (KkcKeyEvent*) _tmp62_);
				output = _tmp63_;
				_tmp64_ = output;
				g_signal_emit_by_name ((KkcKeyEventFilter*) self, "forwarded", _tmp64_);
				result = r;
				_g_object_unref0 (output);
				_kkc_nicola_key_event_filter_timed_entry_unref0 (a);
				_kkc_nicola_key_event_filter_timed_entry_unref0 (b);
				return result;
			} else {
				gboolean _tmp65_ = FALSE;
				gboolean _tmp66_ = FALSE;
				KkcNicolaKeyEventFilterTimedEntry* _tmp67_ = NULL;
				gconstpointer _tmp68_ = NULL;
				gboolean _tmp69_ = FALSE;
				gboolean _tmp73_ = FALSE;
				gboolean _tmp82_ = FALSE;
				_tmp67_ = a;
				_tmp68_ = _tmp67_->data;
				_tmp69_ = kkc_nicola_key_event_filter_is_char ((KkcKeyEvent*) _tmp68_);
				if (_tmp69_) {
					KkcNicolaKeyEventFilterTimedEntry* _tmp70_ = NULL;
					gconstpointer _tmp71_ = NULL;
					gboolean _tmp72_ = FALSE;
					_tmp70_ = b;
					_tmp71_ = _tmp70_->data;
					_tmp72_ = kkc_nicola_key_event_filter_is_char ((KkcKeyEvent*) _tmp71_);
					_tmp66_ = _tmp72_;
				} else {
					_tmp66_ = FALSE;
				}
				_tmp73_ = _tmp66_;
				if (_tmp73_) {
					_tmp65_ = TRUE;
				} else {
					gboolean _tmp74_ = FALSE;
					KkcNicolaKeyEventFilterTimedEntry* _tmp75_ = NULL;
					gconstpointer _tmp76_ = NULL;
					gboolean _tmp77_ = FALSE;
					gboolean _tmp81_ = FALSE;
					_tmp75_ = a;
					_tmp76_ = _tmp75_->data;
					_tmp77_ = kkc_nicola_key_event_filter_is_shift ((KkcKeyEvent*) _tmp76_);
					if (_tmp77_) {
						KkcNicolaKeyEventFilterTimedEntry* _tmp78_ = NULL;
						gconstpointer _tmp79_ = NULL;
						gboolean _tmp80_ = FALSE;
						_tmp78_ = b;
						_tmp79_ = _tmp78_->data;
						_tmp80_ = kkc_nicola_key_event_filter_is_shift ((KkcKeyEvent*) _tmp79_);
						_tmp74_ = _tmp80_;
					} else {
						_tmp74_ = FALSE;
					}
					_tmp81_ = _tmp74_;
					_tmp65_ = _tmp81_;
				}
				_tmp82_ = _tmp65_;
				if (_tmp82_) {
					GeeLinkedList* _tmp83_ = NULL;
					GeeLinkedList* _tmp84_ = NULL;
					KkcNicolaKeyEventFilterTimedEntry* _tmp85_ = NULL;
					KkcKeyEvent* r = NULL;
					gint64 _tmp86_ = 0LL;
					KkcKeyEvent* _tmp87_ = NULL;
					KkcKeyEvent* output = NULL;
					KkcNicolaKeyEventFilterTimedEntry* _tmp88_ = NULL;
					gconstpointer _tmp89_ = NULL;
					KkcKeyEvent* _tmp90_ = NULL;
					KkcKeyEvent* _tmp91_ = NULL;
					_tmp83_ = self->priv->pending;
					gee_abstract_collection_clear ((GeeAbstractCollection*) _tmp83_);
					_tmp84_ = self->priv->pending;
					_tmp85_ = b;
					gee_deque_offer_head ((GeeDeque*) _tmp84_, _tmp85_);
					_tmp86_ = time;
					_tmp87_ = kkc_nicola_key_event_filter_dispatch_single (self, _tmp86_);
					r = _tmp87_;
					_tmp88_ = a;
					_tmp89_ = _tmp88_->data;
					_tmp90_ = kkc_nicola_key_event_filter_decompose_shifted (self, (KkcKeyEvent*) _tmp89_);
					output = _tmp90_;
					_tmp91_ = output;
					g_signal_emit_by_name ((KkcKeyEventFilter*) self, "forwarded", _tmp91_);
					result = r;
					_g_object_unref0 (output);
					_kkc_nicola_key_event_filter_timed_entry_unref0 (a);
					_kkc_nicola_key_event_filter_timed_entry_unref0 (b);
					return result;
				} else {
					gint64 _tmp92_ = 0LL;
					KkcNicolaKeyEventFilterTimedEntry* _tmp93_ = NULL;
					gint64 _tmp94_ = 0LL;
					gint64 _tmp95_ = 0LL;
					_tmp92_ = time;
					_tmp93_ = a;
					_tmp94_ = _tmp93_->time;
					_tmp95_ = self->timeout;
					if ((_tmp92_ - _tmp94_) > _tmp95_) {
						GeeLinkedList* _tmp96_ = NULL;
						KkcNicolaKeyEventFilterTimedEntry* _tmp97_ = NULL;
						gconstpointer _tmp98_ = NULL;
						gboolean _tmp99_ = FALSE;
						_tmp96_ = self->priv->pending;
						gee_abstract_collection_clear ((GeeAbstractCollection*) _tmp96_);
						_tmp97_ = b;
						_tmp98_ = _tmp97_->data;
						_tmp99_ = kkc_nicola_key_event_filter_is_shift ((KkcKeyEvent*) _tmp98_);
						if (_tmp99_) {
							KkcNicolaKeyEventFilterTimedEntry* _tmp100_ = NULL;
							gconstpointer _tmp101_ = NULL;
							KkcNicolaKeyEventFilterTimedEntry* _tmp102_ = NULL;
							gconstpointer _tmp103_ = NULL;
							KkcNicolaKeyEventFilterTimedEntry* _tmp104_ = NULL;
							gconstpointer _tmp105_ = NULL;
							KkcKeyEvent* _tmp106_ = NULL;
							_tmp100_ = b;
							_tmp101_ = _tmp100_->data;
							_tmp102_ = a;
							_tmp103_ = _tmp102_->data;
							kkc_nicola_key_event_filter_apply_shift (self, (KkcKeyEvent*) _tmp101_, (KkcKeyEvent*) _tmp103_);
							_tmp104_ = a;
							_tmp105_ = _tmp104_->data;
							_tmp106_ = _g_object_ref0 ((KkcKeyEvent*) _tmp105_);
							result = _tmp106_;
							_kkc_nicola_key_event_filter_timed_entry_unref0 (a);
							_kkc_nicola_key_event_filter_timed_entry_unref0 (b);
							return result;
						} else {
							KkcNicolaKeyEventFilterTimedEntry* _tmp107_ = NULL;
							gconstpointer _tmp108_ = NULL;
							KkcNicolaKeyEventFilterTimedEntry* _tmp109_ = NULL;
							gconstpointer _tmp110_ = NULL;
							KkcNicolaKeyEventFilterTimedEntry* _tmp111_ = NULL;
							gconstpointer _tmp112_ = NULL;
							KkcKeyEvent* _tmp113_ = NULL;
							_tmp107_ = a;
							_tmp108_ = _tmp107_->data;
							_tmp109_ = b;
							_tmp110_ = _tmp109_->data;
							kkc_nicola_key_event_filter_apply_shift (self, (KkcKeyEvent*) _tmp108_, (KkcKeyEvent*) _tmp110_);
							_tmp111_ = b;
							_tmp112_ = _tmp111_->data;
							_tmp113_ = _g_object_ref0 ((KkcKeyEvent*) _tmp112_);
							result = _tmp113_;
							_kkc_nicola_key_event_filter_timed_entry_unref0 (a);
							_kkc_nicola_key_event_filter_timed_entry_unref0 (b);
							return result;
						}
					}
				}
			}
			_kkc_nicola_key_event_filter_timed_entry_unref0 (a);
			_kkc_nicola_key_event_filter_timed_entry_unref0 (b);
		} else {
			GeeLinkedList* _tmp114_ = NULL;
			gint _tmp115_ = 0;
			gint _tmp116_ = 0;
			_tmp114_ = self->priv->pending;
			_tmp115_ = gee_abstract_collection_get_size ((GeeCollection*) _tmp114_);
			_tmp116_ = _tmp115_;
			if (_tmp116_ == 1) {
				gint64 _tmp117_ = 0LL;
				KkcKeyEvent* _tmp118_ = NULL;
				_tmp117_ = time;
				_tmp118_ = kkc_nicola_key_event_filter_dispatch_single (self, _tmp117_);
				result = _tmp118_;
				return result;
			}
		}
	}
	result = NULL;
	return result;
}


static gboolean kkc_nicola_key_event_filter_timeout_func (KkcNicolaKeyEventFilter* self) {
	gboolean result = FALSE;
	gint64 time = 0LL;
	KkcGetTime _tmp0_ = NULL;
	void* _tmp0__target = NULL;
	gint64 _tmp1_ = 0LL;
	KkcKeyEvent* r = NULL;
	gint64 _tmp2_ = 0LL;
	KkcKeyEvent* _tmp3_ = NULL;
	KkcKeyEvent* _tmp4_ = NULL;
	g_return_val_if_fail (self != NULL, FALSE);
	_tmp0_ = self->get_time_func;
	_tmp0__target = self->get_time_func_target;
	_tmp1_ = _tmp0_ (_tmp0__target);
	time = _tmp1_;
	_tmp2_ = time;
	_tmp3_ = kkc_nicola_key_event_filter_dispatch (self, _tmp2_);
	r = _tmp3_;
	_tmp4_ = r;
	if (_tmp4_ != NULL) {
		KkcKeyEvent* output = NULL;
		KkcKeyEvent* _tmp5_ = NULL;
		KkcKeyEvent* _tmp6_ = NULL;
		KkcKeyEvent* _tmp7_ = NULL;
		_tmp5_ = r;
		_tmp6_ = kkc_nicola_key_event_filter_decompose_shifted (self, _tmp5_);
		output = _tmp6_;
		_tmp7_ = output;
		g_signal_emit_by_name ((KkcKeyEventFilter*) self, "forwarded", _tmp7_);
		_g_object_unref0 (output);
	}
	self->priv->timeout_id = (guint) 0;
	result = FALSE;
	_g_object_unref0 (r);
	return result;
}


static KkcKeyEvent* kkc_nicola_key_event_filter_decompose_shifted (KkcNicolaKeyEventFilter* self, KkcKeyEvent* key) {
	KkcKeyEvent* result = NULL;
	KkcKeyEvent* _tmp0_ = NULL;
	KkcModifierType _tmp1_ = 0;
	KkcModifierType _tmp2_ = 0;
	KkcKeyEvent* _tmp11_ = NULL;
	KkcModifierType _tmp12_ = 0;
	KkcModifierType _tmp13_ = 0;
	KkcKeyEvent* _tmp22_ = NULL;
	KkcKeyEvent* _tmp23_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	g_return_val_if_fail (key != NULL, NULL);
	_tmp0_ = key;
	_tmp1_ = kkc_key_event_get_modifiers (_tmp0_);
	_tmp2_ = _tmp1_;
	if ((_tmp2_ & KKC_MODIFIER_TYPE_LSHIFT_MASK) != 0) {
		KkcKeyEvent* _tmp3_ = NULL;
		KkcKeyEvent* _tmp4_ = NULL;
		KkcKeyEvent* _tmp5_ = NULL;
		KkcKeyEvent* _tmp6_ = NULL;
		KkcModifierType _tmp7_ = 0;
		KkcModifierType _tmp8_ = 0;
		KkcKeyEvent* _tmp9_ = NULL;
		KkcKeyEvent* _tmp10_ = NULL;
		_tmp3_ = kkc_key_event_new_from_x_event ((guint) 0x4c, (guint) 0, 0);
		_tmp4_ = _tmp3_;
		g_signal_emit_by_name ((KkcKeyEventFilter*) self, "forwarded", _tmp4_);
		_g_object_unref0 (_tmp4_);
		_tmp5_ = key;
		_tmp6_ = key;
		_tmp7_ = kkc_key_event_get_modifiers (_tmp6_);
		_tmp8_ = _tmp7_;
		kkc_key_event_set_modifiers (_tmp6_, _tmp8_ & (~KKC_MODIFIER_TYPE_LSHIFT_MASK));
		_tmp9_ = key;
		_tmp10_ = _g_object_ref0 (_tmp9_);
		result = _tmp10_;
		return result;
	}
	_tmp11_ = key;
	_tmp12_ = kkc_key_event_get_modifiers (_tmp11_);
	_tmp13_ = _tmp12_;
	if ((_tmp13_ & KKC_MODIFIER_TYPE_RSHIFT_MASK) != 0) {
		KkcKeyEvent* _tmp14_ = NULL;
		KkcKeyEvent* _tmp15_ = NULL;
		KkcKeyEvent* _tmp16_ = NULL;
		KkcKeyEvent* _tmp17_ = NULL;
		KkcModifierType _tmp18_ = 0;
		KkcModifierType _tmp19_ = 0;
		KkcKeyEvent* _tmp20_ = NULL;
		KkcKeyEvent* _tmp21_ = NULL;
		_tmp14_ = kkc_key_event_new_from_x_event ((guint) 0x52, (guint) 0, 0);
		_tmp15_ = _tmp14_;
		g_signal_emit_by_name ((KkcKeyEventFilter*) self, "forwarded", _tmp15_);
		_g_object_unref0 (_tmp15_);
		_tmp16_ = key;
		_tmp17_ = key;
		_tmp18_ = kkc_key_event_get_modifiers (_tmp17_);
		_tmp19_ = _tmp18_;
		kkc_key_event_set_modifiers (_tmp17_, _tmp19_ & (~KKC_MODIFIER_TYPE_RSHIFT_MASK));
		_tmp20_ = key;
		_tmp21_ = _g_object_ref0 (_tmp20_);
		result = _tmp21_;
		return result;
	}
	_tmp22_ = key;
	_tmp23_ = _g_object_ref0 (_tmp22_);
	result = _tmp23_;
	return result;
}


/**
         * {@inheritDoc}
         */
static gboolean _kkc_nicola_key_event_filter_timeout_func_gsource_func (gpointer self) {
	gboolean result;
	result = kkc_nicola_key_event_filter_timeout_func (self);
	return result;
}


static KkcKeyEvent* kkc_nicola_key_event_filter_real_filter_key_event (KkcKeyEventFilter* base, KkcKeyEvent* key) {
	KkcNicolaKeyEventFilter * self;
	KkcKeyEvent* result = NULL;
	gint64 time = 0LL;
	KkcGetTime _tmp0_ = NULL;
	void* _tmp0__target = NULL;
	gint64 _tmp1_ = 0LL;
	gint64 wait = 0LL;
	KkcKeyEvent* output = NULL;
	KkcKeyEvent* _tmp2_ = NULL;
	gint64 _tmp3_ = 0LL;
	gint64 _tmp4_ = 0LL;
	KkcKeyEvent* _tmp5_ = NULL;
	gint64 _tmp6_ = 0LL;
	KkcKeyEvent* _tmp11_ = NULL;
	KkcKeyEvent* _tmp14_ = NULL;
	KkcKeyEvent* _tmp15_ = NULL;
	KkcKeyEvent* _tmp16_ = NULL;
	self = (KkcNicolaKeyEventFilter*) base;
	g_return_val_if_fail (key != NULL, NULL);
	_tmp0_ = self->get_time_func;
	_tmp0__target = self->get_time_func_target;
	_tmp1_ = _tmp0_ (_tmp0__target);
	time = _tmp1_;
	_tmp2_ = key;
	_tmp3_ = time;
	_tmp5_ = kkc_nicola_key_event_filter_queue (self, _tmp2_, _tmp3_, &_tmp4_);
	wait = _tmp4_;
	output = _tmp5_;
	_tmp6_ = wait;
	if (_tmp6_ > ((gint64) 0)) {
		guint _tmp7_ = 0U;
		gint64 _tmp9_ = 0LL;
		guint _tmp10_ = 0U;
		_tmp7_ = self->priv->timeout_id;
		if (_tmp7_ > ((guint) 0)) {
			guint _tmp8_ = 0U;
			_tmp8_ = self->priv->timeout_id;
			g_source_remove (_tmp8_);
		}
		_tmp9_ = wait;
		_tmp10_ = g_timeout_add_full (G_PRIORITY_DEFAULT, (guint) (_tmp9_ / 1000), _kkc_nicola_key_event_filter_timeout_func_gsource_func, g_object_ref (self), g_object_unref);
		self->priv->timeout_id = _tmp10_;
	}
	_tmp11_ = output;
	if (_tmp11_ == NULL) {
		gint64 _tmp12_ = 0LL;
		KkcKeyEvent* _tmp13_ = NULL;
		_tmp12_ = time;
		_tmp13_ = kkc_nicola_key_event_filter_dispatch (self, _tmp12_);
		_g_object_unref0 (output);
		output = _tmp13_;
	}
	_tmp14_ = output;
	if (_tmp14_ == NULL) {
		result = NULL;
		_g_object_unref0 (output);
		return result;
	}
	_tmp15_ = output;
	_tmp16_ = kkc_nicola_key_event_filter_decompose_shifted (self, _tmp15_);
	result = _tmp16_;
	_g_object_unref0 (output);
	return result;
}


/**
         * {@inheritDoc}
         */
static void kkc_nicola_key_event_filter_real_reset (KkcKeyEventFilter* base) {
	KkcNicolaKeyEventFilter * self;
	GeeLinkedList* _tmp0_ = NULL;
	self = (KkcNicolaKeyEventFilter*) base;
	_tmp0_ = self->priv->pending;
	gee_abstract_collection_clear ((GeeAbstractCollection*) _tmp0_);
}


KkcNicolaKeyEventFilter* kkc_nicola_key_event_filter_construct (GType object_type) {
	KkcNicolaKeyEventFilter * self = NULL;
	self = (KkcNicolaKeyEventFilter*) kkc_key_event_filter_construct (object_type);
	return self;
}


KkcNicolaKeyEventFilter* kkc_nicola_key_event_filter_new (void) {
	return kkc_nicola_key_event_filter_construct (KKC_TYPE_NICOLA_KEY_EVENT_FILTER);
}


static KkcNicolaKeyEventFilterTimedEntry* kkc_nicola_key_event_filter_timed_entry_construct (GType object_type, GType t_type, GBoxedCopyFunc t_dup_func, GDestroyNotify t_destroy_func, gconstpointer data, gint64 time) {
	KkcNicolaKeyEventFilterTimedEntry* self = NULL;
	gconstpointer _tmp0_ = NULL;
	gpointer _tmp1_ = NULL;
	gint64 _tmp2_ = 0LL;
	self = (KkcNicolaKeyEventFilterTimedEntry*) g_type_create_instance (object_type);
	self->priv->t_type = t_type;
	self->priv->t_dup_func = t_dup_func;
	self->priv->t_destroy_func = t_destroy_func;
	_tmp0_ = data;
	_tmp1_ = ((_tmp0_ != NULL) && (t_dup_func != NULL)) ? t_dup_func ((gpointer) _tmp0_) : ((gpointer) _tmp0_);
	_t_destroy_func0 (self->data);
	self->data = _tmp1_;
	_tmp2_ = time;
	self->time = _tmp2_;
	return self;
}


static KkcNicolaKeyEventFilterTimedEntry* kkc_nicola_key_event_filter_timed_entry_new (GType t_type, GBoxedCopyFunc t_dup_func, GDestroyNotify t_destroy_func, gconstpointer data, gint64 time) {
	return kkc_nicola_key_event_filter_timed_entry_construct (KKC_NICOLA_KEY_EVENT_FILTER_TYPE_TIMED_ENTRY, t_type, t_dup_func, t_destroy_func, data, time);
}


static void kkc_nicola_key_event_filter_value_timed_entry_init (GValue* value) {
	value->data[0].v_pointer = NULL;
}


static void kkc_nicola_key_event_filter_value_timed_entry_free_value (GValue* value) {
	if (value->data[0].v_pointer) {
		kkc_nicola_key_event_filter_timed_entry_unref (value->data[0].v_pointer);
	}
}


static void kkc_nicola_key_event_filter_value_timed_entry_copy_value (const GValue* src_value, GValue* dest_value) {
	if (src_value->data[0].v_pointer) {
		dest_value->data[0].v_pointer = kkc_nicola_key_event_filter_timed_entry_ref (src_value->data[0].v_pointer);
	} else {
		dest_value->data[0].v_pointer = NULL;
	}
}


static gpointer kkc_nicola_key_event_filter_value_timed_entry_peek_pointer (const GValue* value) {
	return value->data[0].v_pointer;
}


static gchar* kkc_nicola_key_event_filter_value_timed_entry_collect_value (GValue* value, guint n_collect_values, GTypeCValue* collect_values, guint collect_flags) {
	if (collect_values[0].v_pointer) {
		KkcNicolaKeyEventFilterTimedEntry* object;
		object = collect_values[0].v_pointer;
		if (object->parent_instance.g_class == NULL) {
			return g_strconcat ("invalid unclassed object pointer for value type `", G_VALUE_TYPE_NAME (value), "'", NULL);
		} else if (!g_value_type_compatible (G_TYPE_FROM_INSTANCE (object), G_VALUE_TYPE (value))) {
			return g_strconcat ("invalid object type `", g_type_name (G_TYPE_FROM_INSTANCE (object)), "' for value type `", G_VALUE_TYPE_NAME (value), "'", NULL);
		}
		value->data[0].v_pointer = kkc_nicola_key_event_filter_timed_entry_ref (object);
	} else {
		value->data[0].v_pointer = NULL;
	}
	return NULL;
}


static gchar* kkc_nicola_key_event_filter_value_timed_entry_lcopy_value (const GValue* value, guint n_collect_values, GTypeCValue* collect_values, guint collect_flags) {
	KkcNicolaKeyEventFilterTimedEntry** object_p;
	object_p = collect_values[0].v_pointer;
	if (!object_p) {
		return g_strdup_printf ("value location for `%s' passed as NULL", G_VALUE_TYPE_NAME (value));
	}
	if (!value->data[0].v_pointer) {
		*object_p = NULL;
	} else if (collect_flags & G_VALUE_NOCOPY_CONTENTS) {
		*object_p = value->data[0].v_pointer;
	} else {
		*object_p = kkc_nicola_key_event_filter_timed_entry_ref (value->data[0].v_pointer);
	}
	return NULL;
}


static GParamSpec* kkc_nicola_key_event_filter_param_spec_timed_entry (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags) {
	KkcNicolaKeyEventFilterParamSpecTimedEntry* spec;
	g_return_val_if_fail (g_type_is_a (object_type, KKC_NICOLA_KEY_EVENT_FILTER_TYPE_TIMED_ENTRY), NULL);
	spec = g_param_spec_internal (G_TYPE_PARAM_OBJECT, name, nick, blurb, flags);
	G_PARAM_SPEC (spec)->value_type = object_type;
	return G_PARAM_SPEC (spec);
}


static gpointer kkc_nicola_key_event_filter_value_get_timed_entry (const GValue* value) {
	g_return_val_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, KKC_NICOLA_KEY_EVENT_FILTER_TYPE_TIMED_ENTRY), NULL);
	return value->data[0].v_pointer;
}


static void kkc_nicola_key_event_filter_value_set_timed_entry (GValue* value, gpointer v_object) {
	KkcNicolaKeyEventFilterTimedEntry* old;
	g_return_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, KKC_NICOLA_KEY_EVENT_FILTER_TYPE_TIMED_ENTRY));
	old = value->data[0].v_pointer;
	if (v_object) {
		g_return_if_fail (G_TYPE_CHECK_INSTANCE_TYPE (v_object, KKC_NICOLA_KEY_EVENT_FILTER_TYPE_TIMED_ENTRY));
		g_return_if_fail (g_value_type_compatible (G_TYPE_FROM_INSTANCE (v_object), G_VALUE_TYPE (value)));
		value->data[0].v_pointer = v_object;
		kkc_nicola_key_event_filter_timed_entry_ref (value->data[0].v_pointer);
	} else {
		value->data[0].v_pointer = NULL;
	}
	if (old) {
		kkc_nicola_key_event_filter_timed_entry_unref (old);
	}
}


static void kkc_nicola_key_event_filter_value_take_timed_entry (GValue* value, gpointer v_object) {
	KkcNicolaKeyEventFilterTimedEntry* old;
	g_return_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, KKC_NICOLA_KEY_EVENT_FILTER_TYPE_TIMED_ENTRY));
	old = value->data[0].v_pointer;
	if (v_object) {
		g_return_if_fail (G_TYPE_CHECK_INSTANCE_TYPE (v_object, KKC_NICOLA_KEY_EVENT_FILTER_TYPE_TIMED_ENTRY));
		g_return_if_fail (g_value_type_compatible (G_TYPE_FROM_INSTANCE (v_object), G_VALUE_TYPE (value)));
		value->data[0].v_pointer = v_object;
	} else {
		value->data[0].v_pointer = NULL;
	}
	if (old) {
		kkc_nicola_key_event_filter_timed_entry_unref (old);
	}
}


static void kkc_nicola_key_event_filter_timed_entry_class_init (KkcNicolaKeyEventFilterTimedEntryClass * klass) {
	kkc_nicola_key_event_filter_timed_entry_parent_class = g_type_class_peek_parent (klass);
	KKC_NICOLA_KEY_EVENT_FILTER_TIMED_ENTRY_CLASS (klass)->finalize = kkc_nicola_key_event_filter_timed_entry_finalize;
	g_type_class_add_private (klass, sizeof (KkcNicolaKeyEventFilterTimedEntryPrivate));
}


static void kkc_nicola_key_event_filter_timed_entry_instance_init (KkcNicolaKeyEventFilterTimedEntry * self) {
	self->priv = KKC_NICOLA_KEY_EVENT_FILTER_TIMED_ENTRY_GET_PRIVATE (self);
	self->ref_count = 1;
}


static void kkc_nicola_key_event_filter_timed_entry_finalize (KkcNicolaKeyEventFilterTimedEntry* obj) {
	KkcNicolaKeyEventFilterTimedEntry * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (obj, KKC_NICOLA_KEY_EVENT_FILTER_TYPE_TIMED_ENTRY, KkcNicolaKeyEventFilterTimedEntry);
	((self->data == NULL) || (self->priv->t_destroy_func == NULL)) ? NULL : (self->data = (self->priv->t_destroy_func (self->data), NULL));
}


static GType kkc_nicola_key_event_filter_timed_entry_get_type (void) {
	static volatile gsize kkc_nicola_key_event_filter_timed_entry_type_id__volatile = 0;
	if (g_once_init_enter (&kkc_nicola_key_event_filter_timed_entry_type_id__volatile)) {
		static const GTypeValueTable g_define_type_value_table = { kkc_nicola_key_event_filter_value_timed_entry_init, kkc_nicola_key_event_filter_value_timed_entry_free_value, kkc_nicola_key_event_filter_value_timed_entry_copy_value, kkc_nicola_key_event_filter_value_timed_entry_peek_pointer, "p", kkc_nicola_key_event_filter_value_timed_entry_collect_value, "p", kkc_nicola_key_event_filter_value_timed_entry_lcopy_value };
		static const GTypeInfo g_define_type_info = { sizeof (KkcNicolaKeyEventFilterTimedEntryClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) kkc_nicola_key_event_filter_timed_entry_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (KkcNicolaKeyEventFilterTimedEntry), 0, (GInstanceInitFunc) kkc_nicola_key_event_filter_timed_entry_instance_init, &g_define_type_value_table };
		static const GTypeFundamentalInfo g_define_type_fundamental_info = { (G_TYPE_FLAG_CLASSED | G_TYPE_FLAG_INSTANTIATABLE | G_TYPE_FLAG_DERIVABLE | G_TYPE_FLAG_DEEP_DERIVABLE) };
		GType kkc_nicola_key_event_filter_timed_entry_type_id;
		kkc_nicola_key_event_filter_timed_entry_type_id = g_type_register_fundamental (g_type_fundamental_next (), "KkcNicolaKeyEventFilterTimedEntry", &g_define_type_info, &g_define_type_fundamental_info, 0);
		g_once_init_leave (&kkc_nicola_key_event_filter_timed_entry_type_id__volatile, kkc_nicola_key_event_filter_timed_entry_type_id);
	}
	return kkc_nicola_key_event_filter_timed_entry_type_id__volatile;
}


static gpointer kkc_nicola_key_event_filter_timed_entry_ref (gpointer instance) {
	KkcNicolaKeyEventFilterTimedEntry* self;
	self = instance;
	g_atomic_int_inc (&self->ref_count);
	return instance;
}


static void kkc_nicola_key_event_filter_timed_entry_unref (gpointer instance) {
	KkcNicolaKeyEventFilterTimedEntry* self;
	self = instance;
	if (g_atomic_int_dec_and_test (&self->ref_count)) {
		KKC_NICOLA_KEY_EVENT_FILTER_TIMED_ENTRY_GET_CLASS (self)->finalize (self);
		g_type_free_instance ((GTypeInstance *) self);
	}
}


static void kkc_nicola_key_event_filter_class_init (KkcNicolaKeyEventFilterClass * klass) {
	kkc_nicola_key_event_filter_parent_class = g_type_class_peek_parent (klass);
	g_type_class_add_private (klass, sizeof (KkcNicolaKeyEventFilterPrivate));
	KKC_KEY_EVENT_FILTER_CLASS (klass)->filter_key_event = kkc_nicola_key_event_filter_real_filter_key_event;
	KKC_KEY_EVENT_FILTER_CLASS (klass)->reset = kkc_nicola_key_event_filter_real_reset;
	G_OBJECT_CLASS (klass)->finalize = kkc_nicola_key_event_filter_finalize;
}


static void kkc_nicola_key_event_filter_instance_init (KkcNicolaKeyEventFilter * self) {
	GeeLinkedList* _tmp0_ = NULL;
	self->priv = KKC_NICOLA_KEY_EVENT_FILTER_GET_PRIVATE (self);
	self->get_time_func = _kkc_nicola_key_event_filter_get_time_kkc_get_time;
	self->timeout = (gint64) 100000;
	self->overlap = (gint64) 50000;
	self->maxwait = (gint64) 10000000;
	_tmp0_ = gee_linked_list_new (KKC_NICOLA_KEY_EVENT_FILTER_TYPE_TIMED_ENTRY, (GBoxedCopyFunc) kkc_nicola_key_event_filter_timed_entry_ref, kkc_nicola_key_event_filter_timed_entry_unref, NULL);
	self->priv->pending = _tmp0_;
	self->priv->timeout_id = (guint) 0;
}


static void kkc_nicola_key_event_filter_finalize (GObject* obj) {
	KkcNicolaKeyEventFilter * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (obj, KKC_TYPE_NICOLA_KEY_EVENT_FILTER, KkcNicolaKeyEventFilter);
	(self->get_time_func_target_destroy_notify == NULL) ? NULL : (self->get_time_func_target_destroy_notify (self->get_time_func_target), NULL);
	self->get_time_func = NULL;
	self->get_time_func_target = NULL;
	self->get_time_func_target_destroy_notify = NULL;
	_g_object_unref0 (self->priv->pending);
	G_OBJECT_CLASS (kkc_nicola_key_event_filter_parent_class)->finalize (obj);
}


/**
     * Key event filter implementing NICOLA (thumb shift) input
     *
     * This class is rarely used in programs but specified as "filter"
     * property in rule metadata.
     *
     * @see Rule
     */
GType kkc_nicola_key_event_filter_get_type (void) {
	static volatile gsize kkc_nicola_key_event_filter_type_id__volatile = 0;
	if (g_once_init_enter (&kkc_nicola_key_event_filter_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (KkcNicolaKeyEventFilterClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) kkc_nicola_key_event_filter_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (KkcNicolaKeyEventFilter), 0, (GInstanceInitFunc) kkc_nicola_key_event_filter_instance_init, NULL };
		GType kkc_nicola_key_event_filter_type_id;
		kkc_nicola_key_event_filter_type_id = g_type_register_static (KKC_TYPE_KEY_EVENT_FILTER, "KkcNicolaKeyEventFilter", &g_define_type_info, 0);
		g_once_init_leave (&kkc_nicola_key_event_filter_type_id__volatile, kkc_nicola_key_event_filter_type_id);
	}
	return kkc_nicola_key_event_filter_type_id__volatile;
}



