/* convert-sentence-state-handler.c generated by valac 0.24.0.131-42e78, the Vala compiler
 * generated from convert-sentence-state-handler.vala, do not modify */

/*
 * Copyright (C) 2011-2014 Daiki Ueno <ueno@gnu.org>
 * Copyright (C) 2011-2014 Red Hat, Inc.
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */

#include <glib.h>
#include <glib-object.h>
#include <stdlib.h>
#include <string.h>
#include <gee.h>


#define KKC_TYPE_STATE_HANDLER (kkc_state_handler_get_type ())
#define KKC_STATE_HANDLER(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), KKC_TYPE_STATE_HANDLER, KkcStateHandler))
#define KKC_STATE_HANDLER_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), KKC_TYPE_STATE_HANDLER, KkcStateHandlerClass))
#define KKC_IS_STATE_HANDLER(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), KKC_TYPE_STATE_HANDLER))
#define KKC_IS_STATE_HANDLER_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), KKC_TYPE_STATE_HANDLER))
#define KKC_STATE_HANDLER_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), KKC_TYPE_STATE_HANDLER, KkcStateHandlerClass))

typedef struct _KkcStateHandler KkcStateHandler;
typedef struct _KkcStateHandlerClass KkcStateHandlerClass;
typedef struct _KkcStateHandlerPrivate KkcStateHandlerPrivate;

#define KKC_TYPE_STATE (kkc_state_get_type ())
#define KKC_STATE(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), KKC_TYPE_STATE, KkcState))
#define KKC_STATE_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), KKC_TYPE_STATE, KkcStateClass))
#define KKC_IS_STATE(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), KKC_TYPE_STATE))
#define KKC_IS_STATE_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), KKC_TYPE_STATE))
#define KKC_STATE_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), KKC_TYPE_STATE, KkcStateClass))

typedef struct _KkcState KkcState;
typedef struct _KkcStateClass KkcStateClass;

#define KKC_TYPE_KEY_EVENT (kkc_key_event_get_type ())
#define KKC_KEY_EVENT(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), KKC_TYPE_KEY_EVENT, KkcKeyEvent))
#define KKC_KEY_EVENT_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), KKC_TYPE_KEY_EVENT, KkcKeyEventClass))
#define KKC_IS_KEY_EVENT(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), KKC_TYPE_KEY_EVENT))
#define KKC_IS_KEY_EVENT_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), KKC_TYPE_KEY_EVENT))
#define KKC_KEY_EVENT_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), KKC_TYPE_KEY_EVENT, KkcKeyEventClass))

typedef struct _KkcKeyEvent KkcKeyEvent;
typedef struct _KkcKeyEventClass KkcKeyEventClass;

#define KKC_TYPE_CONVERT_SENTENCE_STATE_HANDLER (kkc_convert_sentence_state_handler_get_type ())
#define KKC_CONVERT_SENTENCE_STATE_HANDLER(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), KKC_TYPE_CONVERT_SENTENCE_STATE_HANDLER, KkcConvertSentenceStateHandler))
#define KKC_CONVERT_SENTENCE_STATE_HANDLER_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), KKC_TYPE_CONVERT_SENTENCE_STATE_HANDLER, KkcConvertSentenceStateHandlerClass))
#define KKC_IS_CONVERT_SENTENCE_STATE_HANDLER(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), KKC_TYPE_CONVERT_SENTENCE_STATE_HANDLER))
#define KKC_IS_CONVERT_SENTENCE_STATE_HANDLER_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), KKC_TYPE_CONVERT_SENTENCE_STATE_HANDLER))
#define KKC_CONVERT_SENTENCE_STATE_HANDLER_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), KKC_TYPE_CONVERT_SENTENCE_STATE_HANDLER, KkcConvertSentenceStateHandlerClass))

typedef struct _KkcConvertSentenceStateHandler KkcConvertSentenceStateHandler;
typedef struct _KkcConvertSentenceStateHandlerClass KkcConvertSentenceStateHandlerClass;
typedef struct _KkcConvertSentenceStateHandlerPrivate KkcConvertSentenceStateHandlerPrivate;

#define KKC_TYPE_SEGMENT (kkc_segment_get_type ())
#define KKC_SEGMENT(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), KKC_TYPE_SEGMENT, KkcSegment))
#define KKC_SEGMENT_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), KKC_TYPE_SEGMENT, KkcSegmentClass))
#define KKC_IS_SEGMENT(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), KKC_TYPE_SEGMENT))
#define KKC_IS_SEGMENT_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), KKC_TYPE_SEGMENT))
#define KKC_SEGMENT_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), KKC_TYPE_SEGMENT, KkcSegmentClass))

typedef struct _KkcSegment KkcSegment;
typedef struct _KkcSegmentClass KkcSegmentClass;
typedef struct _KkcStatePrivate KkcStatePrivate;

#define KKC_TYPE_LANGUAGE_MODEL (kkc_language_model_get_type ())
#define KKC_LANGUAGE_MODEL(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), KKC_TYPE_LANGUAGE_MODEL, KkcLanguageModel))
#define KKC_LANGUAGE_MODEL_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), KKC_TYPE_LANGUAGE_MODEL, KkcLanguageModelClass))
#define KKC_IS_LANGUAGE_MODEL(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), KKC_TYPE_LANGUAGE_MODEL))
#define KKC_IS_LANGUAGE_MODEL_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), KKC_TYPE_LANGUAGE_MODEL))
#define KKC_LANGUAGE_MODEL_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), KKC_TYPE_LANGUAGE_MODEL, KkcLanguageModelClass))

typedef struct _KkcLanguageModel KkcLanguageModel;
typedef struct _KkcLanguageModelClass KkcLanguageModelClass;

#define KKC_TYPE_DECODER (kkc_decoder_get_type ())
#define KKC_DECODER(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), KKC_TYPE_DECODER, KkcDecoder))
#define KKC_DECODER_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), KKC_TYPE_DECODER, KkcDecoderClass))
#define KKC_IS_DECODER(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), KKC_TYPE_DECODER))
#define KKC_IS_DECODER_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), KKC_TYPE_DECODER))
#define KKC_DECODER_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), KKC_TYPE_DECODER, KkcDecoderClass))

typedef struct _KkcDecoder KkcDecoder;
typedef struct _KkcDecoderClass KkcDecoderClass;

#define KKC_TYPE_SEGMENT_LIST (kkc_segment_list_get_type ())
#define KKC_SEGMENT_LIST(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), KKC_TYPE_SEGMENT_LIST, KkcSegmentList))
#define KKC_SEGMENT_LIST_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), KKC_TYPE_SEGMENT_LIST, KkcSegmentListClass))
#define KKC_IS_SEGMENT_LIST(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), KKC_TYPE_SEGMENT_LIST))
#define KKC_IS_SEGMENT_LIST_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), KKC_TYPE_SEGMENT_LIST))
#define KKC_SEGMENT_LIST_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), KKC_TYPE_SEGMENT_LIST, KkcSegmentListClass))

typedef struct _KkcSegmentList KkcSegmentList;
typedef struct _KkcSegmentListClass KkcSegmentListClass;

#define KKC_TYPE_CANDIDATE_LIST (kkc_candidate_list_get_type ())
#define KKC_CANDIDATE_LIST(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), KKC_TYPE_CANDIDATE_LIST, KkcCandidateList))
#define KKC_CANDIDATE_LIST_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), KKC_TYPE_CANDIDATE_LIST, KkcCandidateListClass))
#define KKC_IS_CANDIDATE_LIST(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), KKC_TYPE_CANDIDATE_LIST))
#define KKC_IS_CANDIDATE_LIST_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), KKC_TYPE_CANDIDATE_LIST))
#define KKC_CANDIDATE_LIST_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), KKC_TYPE_CANDIDATE_LIST, KkcCandidateListClass))

typedef struct _KkcCandidateList KkcCandidateList;
typedef struct _KkcCandidateListClass KkcCandidateListClass;

#define KKC_TYPE_DICTIONARY_LIST (kkc_dictionary_list_get_type ())
#define KKC_DICTIONARY_LIST(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), KKC_TYPE_DICTIONARY_LIST, KkcDictionaryList))
#define KKC_DICTIONARY_LIST_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), KKC_TYPE_DICTIONARY_LIST, KkcDictionaryListClass))
#define KKC_IS_DICTIONARY_LIST(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), KKC_TYPE_DICTIONARY_LIST))
#define KKC_IS_DICTIONARY_LIST_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), KKC_TYPE_DICTIONARY_LIST))
#define KKC_DICTIONARY_LIST_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), KKC_TYPE_DICTIONARY_LIST, KkcDictionaryListClass))

typedef struct _KkcDictionaryList KkcDictionaryList;
typedef struct _KkcDictionaryListClass KkcDictionaryListClass;

#define KKC_TYPE_ROM_KANA_CONVERTER (kkc_rom_kana_converter_get_type ())
#define KKC_ROM_KANA_CONVERTER(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), KKC_TYPE_ROM_KANA_CONVERTER, KkcRomKanaConverter))
#define KKC_ROM_KANA_CONVERTER_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), KKC_TYPE_ROM_KANA_CONVERTER, KkcRomKanaConverterClass))
#define KKC_IS_ROM_KANA_CONVERTER(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), KKC_TYPE_ROM_KANA_CONVERTER))
#define KKC_IS_ROM_KANA_CONVERTER_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), KKC_TYPE_ROM_KANA_CONVERTER))
#define KKC_ROM_KANA_CONVERTER_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), KKC_TYPE_ROM_KANA_CONVERTER, KkcRomKanaConverterClass))

typedef struct _KkcRomKanaConverter KkcRomKanaConverter;
typedef struct _KkcRomKanaConverterClass KkcRomKanaConverterClass;

#define KKC_TYPE_ROM_KANA_CHARACTER_LIST (kkc_rom_kana_character_list_get_type ())
#define KKC_ROM_KANA_CHARACTER_LIST(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), KKC_TYPE_ROM_KANA_CHARACTER_LIST, KkcRomKanaCharacterList))
#define KKC_ROM_KANA_CHARACTER_LIST_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), KKC_TYPE_ROM_KANA_CHARACTER_LIST, KkcRomKanaCharacterListClass))
#define KKC_IS_ROM_KANA_CHARACTER_LIST(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), KKC_TYPE_ROM_KANA_CHARACTER_LIST))
#define KKC_IS_ROM_KANA_CHARACTER_LIST_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), KKC_TYPE_ROM_KANA_CHARACTER_LIST))
#define KKC_ROM_KANA_CHARACTER_LIST_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), KKC_TYPE_ROM_KANA_CHARACTER_LIST, KkcRomKanaCharacterListClass))

typedef struct _KkcRomKanaCharacterList KkcRomKanaCharacterList;
typedef struct _KkcRomKanaCharacterListClass KkcRomKanaCharacterListClass;
#define _g_object_unref0(var) ((var == NULL) ? NULL : (var = (g_object_unref (var), NULL)))

#define KKC_TYPE_CONVERT_SEGMENT_STATE_HANDLER (kkc_convert_segment_state_handler_get_type ())
#define KKC_CONVERT_SEGMENT_STATE_HANDLER(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), KKC_TYPE_CONVERT_SEGMENT_STATE_HANDLER, KkcConvertSegmentStateHandler))
#define KKC_CONVERT_SEGMENT_STATE_HANDLER_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), KKC_TYPE_CONVERT_SEGMENT_STATE_HANDLER, KkcConvertSegmentStateHandlerClass))
#define KKC_IS_CONVERT_SEGMENT_STATE_HANDLER(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), KKC_TYPE_CONVERT_SEGMENT_STATE_HANDLER))
#define KKC_IS_CONVERT_SEGMENT_STATE_HANDLER_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), KKC_TYPE_CONVERT_SEGMENT_STATE_HANDLER))
#define KKC_CONVERT_SEGMENT_STATE_HANDLER_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), KKC_TYPE_CONVERT_SEGMENT_STATE_HANDLER, KkcConvertSegmentStateHandlerClass))

typedef struct _KkcConvertSegmentStateHandler KkcConvertSegmentStateHandler;
typedef struct _KkcConvertSegmentStateHandlerClass KkcConvertSegmentStateHandlerClass;

#define KKC_TYPE_INITIAL_STATE_HANDLER (kkc_initial_state_handler_get_type ())
#define KKC_INITIAL_STATE_HANDLER(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), KKC_TYPE_INITIAL_STATE_HANDLER, KkcInitialStateHandler))
#define KKC_INITIAL_STATE_HANDLER_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), KKC_TYPE_INITIAL_STATE_HANDLER, KkcInitialStateHandlerClass))
#define KKC_IS_INITIAL_STATE_HANDLER(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), KKC_TYPE_INITIAL_STATE_HANDLER))
#define KKC_IS_INITIAL_STATE_HANDLER_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), KKC_TYPE_INITIAL_STATE_HANDLER))
#define KKC_INITIAL_STATE_HANDLER_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), KKC_TYPE_INITIAL_STATE_HANDLER, KkcInitialStateHandlerClass))

typedef struct _KkcInitialStateHandler KkcInitialStateHandler;
typedef struct _KkcInitialStateHandlerClass KkcInitialStateHandlerClass;
#define _g_free0(var) (var = (g_free (var), NULL))

#define KKC_TYPE_MODIFIER_TYPE (kkc_modifier_type_get_type ())

#define KKC_TYPE_KANA_MODE (kkc_kana_mode_get_type ())

#define KKC_TYPE_COMMAND_HANDLER (kkc_command_handler_get_type ())
#define KKC_COMMAND_HANDLER(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), KKC_TYPE_COMMAND_HANDLER, KkcCommandHandler))
#define KKC_IS_COMMAND_HANDLER(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), KKC_TYPE_COMMAND_HANDLER))
#define KKC_COMMAND_HANDLER_GET_INTERFACE(obj) (G_TYPE_INSTANCE_GET_INTERFACE ((obj), KKC_TYPE_COMMAND_HANDLER, KkcCommandHandlerIface))

typedef struct _KkcCommandHandler KkcCommandHandler;
typedef struct _KkcCommandHandlerIface KkcCommandHandlerIface;

#define KKC_CONVERT_SENTENCE_STATE_HANDLER_TYPE_CONVERT_COMMAND_HANDLER (kkc_convert_sentence_state_handler_convert_command_handler_get_type ())
#define KKC_CONVERT_SENTENCE_STATE_HANDLER_CONVERT_COMMAND_HANDLER(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), KKC_CONVERT_SENTENCE_STATE_HANDLER_TYPE_CONVERT_COMMAND_HANDLER, KkcConvertSentenceStateHandlerConvertCommandHandler))
#define KKC_CONVERT_SENTENCE_STATE_HANDLER_CONVERT_COMMAND_HANDLER_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), KKC_CONVERT_SENTENCE_STATE_HANDLER_TYPE_CONVERT_COMMAND_HANDLER, KkcConvertSentenceStateHandlerConvertCommandHandlerClass))
#define KKC_CONVERT_SENTENCE_STATE_HANDLER_IS_CONVERT_COMMAND_HANDLER(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), KKC_CONVERT_SENTENCE_STATE_HANDLER_TYPE_CONVERT_COMMAND_HANDLER))
#define KKC_CONVERT_SENTENCE_STATE_HANDLER_IS_CONVERT_COMMAND_HANDLER_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), KKC_CONVERT_SENTENCE_STATE_HANDLER_TYPE_CONVERT_COMMAND_HANDLER))
#define KKC_CONVERT_SENTENCE_STATE_HANDLER_CONVERT_COMMAND_HANDLER_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), KKC_CONVERT_SENTENCE_STATE_HANDLER_TYPE_CONVERT_COMMAND_HANDLER, KkcConvertSentenceStateHandlerConvertCommandHandlerClass))

typedef struct _KkcConvertSentenceStateHandlerConvertCommandHandler KkcConvertSentenceStateHandlerConvertCommandHandler;
typedef struct _KkcConvertSentenceStateHandlerConvertCommandHandlerClass KkcConvertSentenceStateHandlerConvertCommandHandlerClass;
#define _g_type_class_unref0(var) ((var == NULL) ? NULL : (var = (g_type_class_unref (var), NULL)))
typedef struct _KkcConvertSentenceStateHandlerConvertCommandHandlerPrivate KkcConvertSentenceStateHandlerConvertCommandHandlerPrivate;

struct _KkcStateHandler {
	GObject parent_instance;
	KkcStateHandlerPrivate * priv;
};

struct _KkcStateHandlerClass {
	GObjectClass parent_class;
	gboolean (*process_key_event) (KkcStateHandler* self, KkcState* state, KkcKeyEvent* key);
};

struct _KkcConvertSentenceStateHandler {
	KkcStateHandler parent_instance;
	KkcConvertSentenceStateHandlerPrivate * priv;
};

struct _KkcConvertSentenceStateHandlerClass {
	KkcStateHandlerClass parent_class;
};

struct _KkcState {
	GObject parent_instance;
	KkcStatePrivate * priv;
	GType handler_type;
	KkcLanguageModel* model;
	KkcDecoder* decoder;
	KkcSegmentList* segments;
	KkcCandidateList* candidates;
	KkcDictionaryList* dictionaries;
	KkcRomKanaConverter* rom_kana_converter;
	KkcRomKanaCharacterList* input_characters;
	gint input_characters_cursor_pos;
	GString* selection;
	GString* output;
	gboolean quoted;
	KkcKeyEvent* this_command_key;
	KkcKeyEvent* last_command_key;
	gchar* overriding_input;
	GeeIterator* completion_iterator;
};

struct _KkcStateClass {
	GObjectClass parent_class;
};

typedef enum  {
	KKC_MODIFIER_TYPE_NONE = 0,
	KKC_MODIFIER_TYPE_SHIFT_MASK = 1 << 0,
	KKC_MODIFIER_TYPE_LOCK_MASK = 1 << 1,
	KKC_MODIFIER_TYPE_CONTROL_MASK = 1 << 2,
	KKC_MODIFIER_TYPE_MOD1_MASK = 1 << 3,
	KKC_MODIFIER_TYPE_MOD2_MASK = 1 << 4,
	KKC_MODIFIER_TYPE_MOD3_MASK = 1 << 5,
	KKC_MODIFIER_TYPE_MOD4_MASK = 1 << 6,
	KKC_MODIFIER_TYPE_MOD5_MASK = 1 << 7,
	KKC_MODIFIER_TYPE_LSHIFT_MASK = 1 << 22,
	KKC_MODIFIER_TYPE_RSHIFT_MASK = 1 << 23,
	KKC_MODIFIER_TYPE_SUPER_MASK = 1 << 26,
	KKC_MODIFIER_TYPE_HYPER_MASK = 1 << 27,
	KKC_MODIFIER_TYPE_META_MASK = 1 << 28,
	KKC_MODIFIER_TYPE_RELEASE_MASK = 1 << 30
} KkcModifierType;

typedef gboolean (*KkcCommandCallback) (const gchar* command, KkcState* state, KkcKeyEvent* key, void* user_data);
typedef enum  {
	KKC_KANA_MODE_HIRAGANA,
	KKC_KANA_MODE_KATAKANA,
	KKC_KANA_MODE_HANKAKU_KATAKANA,
	KKC_KANA_MODE_LATIN,
	KKC_KANA_MODE_WIDE_LATIN
} KkcKanaMode;

struct _KkcCommandHandlerIface {
	GTypeInterface parent_iface;
	gboolean (*call) (KkcCommandHandler* self, const gchar* command, KkcState* state, KkcKeyEvent* key);
};

struct _KkcConvertSentenceStateHandlerConvertCommandHandler {
	GObject parent_instance;
	KkcConvertSentenceStateHandlerConvertCommandHandlerPrivate * priv;
};

struct _KkcConvertSentenceStateHandlerConvertCommandHandlerClass {
	GObjectClass parent_class;
};

struct _KkcConvertSentenceStateHandlerConvertCommandHandlerPrivate {
	KkcKanaMode mode;
};


static gpointer kkc_convert_sentence_state_handler_parent_class = NULL;
static gpointer kkc_convert_sentence_state_handler_convert_command_handler_parent_class = NULL;
static KkcCommandHandlerIface* kkc_convert_sentence_state_handler_convert_command_handler_kkc_command_handler_parent_iface = NULL;

GType kkc_state_handler_get_type (void) G_GNUC_CONST;
GType kkc_state_get_type (void) G_GNUC_CONST;
GType kkc_key_event_get_type (void) G_GNUC_CONST;
GType kkc_convert_sentence_state_handler_get_type (void) G_GNUC_CONST;
enum  {
	KKC_CONVERT_SENTENCE_STATE_HANDLER_DUMMY_PROPERTY
};
static gboolean kkc_convert_sentence_state_handler_do_original_candidate (KkcConvertSentenceStateHandler* self, const gchar* command, KkcState* state, KkcKeyEvent* key);
GType kkc_segment_get_type (void) G_GNUC_CONST;
GType kkc_language_model_get_type (void) G_GNUC_CONST;
GType kkc_decoder_get_type (void) G_GNUC_CONST;
GType kkc_segment_list_get_type (void) G_GNUC_CONST;
GType kkc_candidate_list_get_type (void) G_GNUC_CONST;
GType kkc_dictionary_list_get_type (void) G_GNUC_CONST;
GType kkc_rom_kana_converter_get_type (void) G_GNUC_CONST;
GType kkc_rom_kana_character_list_get_type (void) G_GNUC_CONST;
KkcSegment* kkc_segment_list_get (KkcSegmentList* self, gint index);
gint kkc_segment_list_get_cursor_pos (KkcSegmentList* self);
const gchar* kkc_segment_get_input (KkcSegment* self);
void kkc_segment_set_output (KkcSegment* self, const gchar* value);
static gboolean kkc_convert_sentence_state_handler_do_expand_segment (KkcConvertSentenceStateHandler* self, const gchar* command, KkcState* state, KkcKeyEvent* key);
gint kkc_segment_list_get_size (KkcSegmentList* self);
void kkc_state_resize_segment (KkcState* self, gint amount);
static gboolean kkc_convert_sentence_state_handler_do_shrink_segment (KkcConvertSentenceStateHandler* self, const gchar* command, KkcState* state, KkcKeyEvent* key);
static gboolean kkc_convert_sentence_state_handler_do_next_segment (KkcConvertSentenceStateHandler* self, const gchar* command, KkcState* state, KkcKeyEvent* key);
void kkc_segment_list_next_segment (KkcSegmentList* self);
static gboolean kkc_convert_sentence_state_handler_do_previous_segment (KkcConvertSentenceStateHandler* self, const gchar* command, KkcState* state, KkcKeyEvent* key);
void kkc_segment_list_previous_segment (KkcSegmentList* self);
static gboolean kkc_convert_sentence_state_handler_do_first_segment (KkcConvertSentenceStateHandler* self, const gchar* command, KkcState* state, KkcKeyEvent* key);
gboolean kkc_segment_list_first_segment (KkcSegmentList* self);
static gboolean kkc_convert_sentence_state_handler_do_last_segment (KkcConvertSentenceStateHandler* self, const gchar* command, KkcState* state, KkcKeyEvent* key);
gboolean kkc_segment_list_last_segment (KkcSegmentList* self);
static gboolean kkc_convert_sentence_state_handler_do_start_segment_conversion (KkcConvertSentenceStateHandler* self, const gchar* command, KkcState* state, KkcKeyEvent* key);
void kkc_state_lookup (KkcState* self, KkcSegment* segment);
gboolean kkc_candidate_list_first (KkcCandidateList* self);
GType kkc_convert_segment_state_handler_get_type (void) G_GNUC_CONST;
static gboolean kkc_convert_sentence_state_handler_do_clear_unhandled (KkcConvertSentenceStateHandler* self, const gchar* command, KkcState* state, KkcKeyEvent* key);
void kkc_segment_list_clear (KkcSegmentList* self);
GType kkc_initial_state_handler_get_type (void) G_GNUC_CONST;
static gboolean kkc_convert_sentence_state_handler_do_ (KkcConvertSentenceStateHandler* self, const gchar* command, KkcState* state, KkcKeyEvent* key);
gchar* kkc_segment_list_get_output (KkcSegmentList* self);
void kkc_state_select_sentence (KkcState* self);
void kkc_state_reset (KkcState* self);
gunichar kkc_key_event_get_unicode (KkcKeyEvent* self);
GType kkc_modifier_type_get_type (void) G_GNUC_CONST;
KkcModifierType kkc_key_event_get_modifiers (KkcKeyEvent* self);
static gboolean kkc_convert_sentence_state_handler_real_process_key_event (KkcStateHandler* base, KkcState* state, KkcKeyEvent* key);
gboolean kkc_state_handler_dispatch_command (KkcStateHandler* self, KkcState* state, KkcKeyEvent* key);
KkcConvertSentenceStateHandler* kkc_convert_sentence_state_handler_new (void);
KkcConvertSentenceStateHandler* kkc_convert_sentence_state_handler_construct (GType object_type);
KkcStateHandler* kkc_state_handler_construct (GType object_type);
static GObject * kkc_convert_sentence_state_handler_constructor (GType type, guint n_construct_properties, GObjectConstructParam * construct_properties);
void kkc_state_handler_register_command_callback (KkcStateHandler* self, const gchar* command, KkcCommandCallback cb, void* cb_target);
static gboolean _kkc_convert_sentence_state_handler_do_start_segment_conversion_kkc_command_callback (const gchar* command, KkcState* state, KkcKeyEvent* key, gpointer self);
static gboolean _kkc_convert_sentence_state_handler_do_original_candidate_kkc_command_callback (const gchar* command, KkcState* state, KkcKeyEvent* key, gpointer self);
static gboolean _kkc_convert_sentence_state_handler_do_expand_segment_kkc_command_callback (const gchar* command, KkcState* state, KkcKeyEvent* key, gpointer self);
static gboolean _kkc_convert_sentence_state_handler_do_shrink_segment_kkc_command_callback (const gchar* command, KkcState* state, KkcKeyEvent* key, gpointer self);
static gboolean _kkc_convert_sentence_state_handler_do_next_segment_kkc_command_callback (const gchar* command, KkcState* state, KkcKeyEvent* key, gpointer self);
static gboolean _kkc_convert_sentence_state_handler_do_previous_segment_kkc_command_callback (const gchar* command, KkcState* state, KkcKeyEvent* key, gpointer self);
static gboolean _kkc_convert_sentence_state_handler_do_first_segment_kkc_command_callback (const gchar* command, KkcState* state, KkcKeyEvent* key, gpointer self);
static gboolean _kkc_convert_sentence_state_handler_do_last_segment_kkc_command_callback (const gchar* command, KkcState* state, KkcKeyEvent* key, gpointer self);
static gboolean _kkc_convert_sentence_state_handler_do_clear_unhandled_kkc_command_callback (const gchar* command, KkcState* state, KkcKeyEvent* key, gpointer self);
GType kkc_kana_mode_get_type (void) G_GNUC_CONST;
static GEnumValue* _g_enum_value_dup (GEnumValue* self);
GType kkc_command_handler_get_type (void) G_GNUC_CONST;
void kkc_state_handler_register_command_handler (KkcStateHandler* self, const gchar* command, KkcCommandHandler* handler);
static KkcConvertSentenceStateHandlerConvertCommandHandler* kkc_convert_sentence_state_handler_convert_command_handler_new (KkcKanaMode mode);
static KkcConvertSentenceStateHandlerConvertCommandHandler* kkc_convert_sentence_state_handler_convert_command_handler_construct (GType object_type, KkcKanaMode mode);
static GType kkc_convert_sentence_state_handler_convert_command_handler_get_type (void) G_GNUC_CONST G_GNUC_UNUSED;
static gboolean _kkc_convert_sentence_state_handler_do__kkc_command_callback (const gchar* command, KkcState* state, KkcKeyEvent* key, gpointer self);
#define KKC_CONVERT_SENTENCE_STATE_HANDLER_CONVERT_COMMAND_HANDLER_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), KKC_CONVERT_SENTENCE_STATE_HANDLER_TYPE_CONVERT_COMMAND_HANDLER, KkcConvertSentenceStateHandlerConvertCommandHandlerPrivate))
enum  {
	KKC_CONVERT_SENTENCE_STATE_HANDLER_CONVERT_COMMAND_HANDLER_DUMMY_PROPERTY
};
static gboolean kkc_convert_sentence_state_handler_convert_command_handler_real_call (KkcCommandHandler* base, const gchar* command, KkcState* state, KkcKeyEvent* key);
void kkc_state_convert_segment_by_kana_mode (KkcState* self, KkcKanaMode mode);
static void kkc_convert_sentence_state_handler_convert_command_handler_finalize (GObject* obj);


static gboolean kkc_convert_sentence_state_handler_do_original_candidate (KkcConvertSentenceStateHandler* self, const gchar* command, KkcState* state, KkcKeyEvent* key) {
	gboolean result = FALSE;
	KkcSegment* segment = NULL;
	KkcState* _tmp0_ = NULL;
	KkcSegmentList* _tmp1_ = NULL;
	KkcState* _tmp2_ = NULL;
	KkcSegmentList* _tmp3_ = NULL;
	gint _tmp4_ = 0;
	gint _tmp5_ = 0;
	KkcSegment* _tmp6_ = NULL;
	const gchar* _tmp7_ = NULL;
	const gchar* _tmp8_ = NULL;
	g_return_val_if_fail (self != NULL, FALSE);
	g_return_val_if_fail (state != NULL, FALSE);
	g_return_val_if_fail (key != NULL, FALSE);
	_tmp0_ = state;
	_tmp1_ = _tmp0_->segments;
	_tmp2_ = state;
	_tmp3_ = _tmp2_->segments;
	_tmp4_ = kkc_segment_list_get_cursor_pos (_tmp3_);
	_tmp5_ = _tmp4_;
	_tmp6_ = kkc_segment_list_get (_tmp1_, _tmp5_);
	segment = _tmp6_;
	_tmp7_ = kkc_segment_get_input (segment);
	_tmp8_ = _tmp7_;
	kkc_segment_set_output (segment, _tmp8_);
	result = TRUE;
	_g_object_unref0 (segment);
	return result;
}


static gboolean kkc_convert_sentence_state_handler_do_expand_segment (KkcConvertSentenceStateHandler* self, const gchar* command, KkcState* state, KkcKeyEvent* key) {
	gboolean result = FALSE;
	KkcState* _tmp0_ = NULL;
	KkcSegmentList* _tmp1_ = NULL;
	gint _tmp2_ = 0;
	gint _tmp3_ = 0;
	KkcState* _tmp4_ = NULL;
	KkcSegmentList* _tmp5_ = NULL;
	gint _tmp6_ = 0;
	gint _tmp7_ = 0;
	g_return_val_if_fail (self != NULL, FALSE);
	g_return_val_if_fail (state != NULL, FALSE);
	g_return_val_if_fail (key != NULL, FALSE);
	_tmp0_ = state;
	_tmp1_ = _tmp0_->segments;
	_tmp2_ = kkc_segment_list_get_cursor_pos (_tmp1_);
	_tmp3_ = _tmp2_;
	_tmp4_ = state;
	_tmp5_ = _tmp4_->segments;
	_tmp6_ = kkc_segment_list_get_size (_tmp5_);
	_tmp7_ = _tmp6_;
	if (_tmp3_ < (_tmp7_ - 1)) {
		KkcState* _tmp8_ = NULL;
		_tmp8_ = state;
		kkc_state_resize_segment (_tmp8_, 1);
	}
	result = TRUE;
	return result;
}


static gboolean kkc_convert_sentence_state_handler_do_shrink_segment (KkcConvertSentenceStateHandler* self, const gchar* command, KkcState* state, KkcKeyEvent* key) {
	gboolean result = FALSE;
	KkcState* _tmp0_ = NULL;
	KkcSegmentList* _tmp1_ = NULL;
	KkcState* _tmp2_ = NULL;
	KkcSegmentList* _tmp3_ = NULL;
	gint _tmp4_ = 0;
	gint _tmp5_ = 0;
	KkcSegment* _tmp6_ = NULL;
	KkcSegment* _tmp7_ = NULL;
	const gchar* _tmp8_ = NULL;
	const gchar* _tmp9_ = NULL;
	gint _tmp10_ = 0;
	gboolean _tmp11_ = FALSE;
	g_return_val_if_fail (self != NULL, FALSE);
	g_return_val_if_fail (state != NULL, FALSE);
	g_return_val_if_fail (key != NULL, FALSE);
	_tmp0_ = state;
	_tmp1_ = _tmp0_->segments;
	_tmp2_ = state;
	_tmp3_ = _tmp2_->segments;
	_tmp4_ = kkc_segment_list_get_cursor_pos (_tmp3_);
	_tmp5_ = _tmp4_;
	_tmp6_ = kkc_segment_list_get (_tmp1_, _tmp5_);
	_tmp7_ = _tmp6_;
	_tmp8_ = kkc_segment_get_input (_tmp7_);
	_tmp9_ = _tmp8_;
	_tmp10_ = g_utf8_strlen (_tmp9_, (gssize) (-1));
	_tmp11_ = _tmp10_ > 1;
	_g_object_unref0 (_tmp7_);
	if (_tmp11_) {
		KkcState* _tmp12_ = NULL;
		_tmp12_ = state;
		kkc_state_resize_segment (_tmp12_, -1);
	}
	result = TRUE;
	return result;
}


static gboolean kkc_convert_sentence_state_handler_do_next_segment (KkcConvertSentenceStateHandler* self, const gchar* command, KkcState* state, KkcKeyEvent* key) {
	gboolean result = FALSE;
	KkcState* _tmp0_ = NULL;
	KkcSegmentList* _tmp1_ = NULL;
	g_return_val_if_fail (self != NULL, FALSE);
	g_return_val_if_fail (state != NULL, FALSE);
	g_return_val_if_fail (key != NULL, FALSE);
	_tmp0_ = state;
	_tmp1_ = _tmp0_->segments;
	kkc_segment_list_next_segment (_tmp1_);
	result = TRUE;
	return result;
}


static gboolean kkc_convert_sentence_state_handler_do_previous_segment (KkcConvertSentenceStateHandler* self, const gchar* command, KkcState* state, KkcKeyEvent* key) {
	gboolean result = FALSE;
	KkcState* _tmp0_ = NULL;
	KkcSegmentList* _tmp1_ = NULL;
	g_return_val_if_fail (self != NULL, FALSE);
	g_return_val_if_fail (state != NULL, FALSE);
	g_return_val_if_fail (key != NULL, FALSE);
	_tmp0_ = state;
	_tmp1_ = _tmp0_->segments;
	kkc_segment_list_previous_segment (_tmp1_);
	result = TRUE;
	return result;
}


static gboolean kkc_convert_sentence_state_handler_do_first_segment (KkcConvertSentenceStateHandler* self, const gchar* command, KkcState* state, KkcKeyEvent* key) {
	gboolean result = FALSE;
	KkcState* _tmp0_ = NULL;
	KkcSegmentList* _tmp1_ = NULL;
	g_return_val_if_fail (self != NULL, FALSE);
	g_return_val_if_fail (state != NULL, FALSE);
	g_return_val_if_fail (key != NULL, FALSE);
	_tmp0_ = state;
	_tmp1_ = _tmp0_->segments;
	kkc_segment_list_first_segment (_tmp1_);
	result = TRUE;
	return result;
}


static gboolean kkc_convert_sentence_state_handler_do_last_segment (KkcConvertSentenceStateHandler* self, const gchar* command, KkcState* state, KkcKeyEvent* key) {
	gboolean result = FALSE;
	KkcState* _tmp0_ = NULL;
	KkcSegmentList* _tmp1_ = NULL;
	g_return_val_if_fail (self != NULL, FALSE);
	g_return_val_if_fail (state != NULL, FALSE);
	g_return_val_if_fail (key != NULL, FALSE);
	_tmp0_ = state;
	_tmp1_ = _tmp0_->segments;
	kkc_segment_list_last_segment (_tmp1_);
	result = TRUE;
	return result;
}


static gboolean kkc_convert_sentence_state_handler_do_start_segment_conversion (KkcConvertSentenceStateHandler* self, const gchar* command, KkcState* state, KkcKeyEvent* key) {
	gboolean result = FALSE;
	KkcState* _tmp0_ = NULL;
	KkcState* _tmp1_ = NULL;
	KkcSegmentList* _tmp2_ = NULL;
	KkcState* _tmp3_ = NULL;
	KkcSegmentList* _tmp4_ = NULL;
	gint _tmp5_ = 0;
	gint _tmp6_ = 0;
	KkcSegment* _tmp7_ = NULL;
	KkcSegment* _tmp8_ = NULL;
	KkcState* _tmp9_ = NULL;
	KkcCandidateList* _tmp10_ = NULL;
	KkcState* _tmp11_ = NULL;
	g_return_val_if_fail (self != NULL, FALSE);
	g_return_val_if_fail (state != NULL, FALSE);
	g_return_val_if_fail (key != NULL, FALSE);
	_tmp0_ = state;
	_tmp1_ = state;
	_tmp2_ = _tmp1_->segments;
	_tmp3_ = state;
	_tmp4_ = _tmp3_->segments;
	_tmp5_ = kkc_segment_list_get_cursor_pos (_tmp4_);
	_tmp6_ = _tmp5_;
	_tmp7_ = kkc_segment_list_get (_tmp2_, _tmp6_);
	_tmp8_ = _tmp7_;
	kkc_state_lookup (_tmp0_, _tmp8_);
	_g_object_unref0 (_tmp8_);
	_tmp9_ = state;
	_tmp10_ = _tmp9_->candidates;
	kkc_candidate_list_first (_tmp10_);
	_tmp11_ = state;
	_tmp11_->handler_type = KKC_TYPE_CONVERT_SEGMENT_STATE_HANDLER;
	result = FALSE;
	return result;
}


static gboolean kkc_convert_sentence_state_handler_do_clear_unhandled (KkcConvertSentenceStateHandler* self, const gchar* command, KkcState* state, KkcKeyEvent* key) {
	gboolean result = FALSE;
	KkcState* _tmp0_ = NULL;
	KkcSegmentList* _tmp1_ = NULL;
	KkcState* _tmp2_ = NULL;
	g_return_val_if_fail (self != NULL, FALSE);
	g_return_val_if_fail (state != NULL, FALSE);
	g_return_val_if_fail (key != NULL, FALSE);
	_tmp0_ = state;
	_tmp1_ = _tmp0_->segments;
	kkc_segment_list_clear (_tmp1_);
	_tmp2_ = state;
	_tmp2_->handler_type = KKC_TYPE_INITIAL_STATE_HANDLER;
	result = TRUE;
	return result;
}


static gboolean kkc_convert_sentence_state_handler_do_ (KkcConvertSentenceStateHandler* self, const gchar* command, KkcState* state, KkcKeyEvent* key) {
	gboolean result = FALSE;
	KkcState* _tmp0_ = NULL;
	GString* _tmp1_ = NULL;
	KkcState* _tmp2_ = NULL;
	KkcSegmentList* _tmp3_ = NULL;
	gchar* _tmp4_ = NULL;
	gchar* _tmp5_ = NULL;
	KkcState* _tmp6_ = NULL;
	KkcState* _tmp7_ = NULL;
	gboolean _tmp8_ = FALSE;
	const gchar* _tmp9_ = NULL;
	gboolean _tmp15_ = FALSE;
	const gchar* _tmp16_ = NULL;
	g_return_val_if_fail (self != NULL, FALSE);
	g_return_val_if_fail (state != NULL, FALSE);
	g_return_val_if_fail (key != NULL, FALSE);
	_tmp0_ = state;
	_tmp1_ = _tmp0_->output;
	_tmp2_ = state;
	_tmp3_ = _tmp2_->segments;
	_tmp4_ = kkc_segment_list_get_output (_tmp3_);
	_tmp5_ = _tmp4_;
	g_string_append (_tmp1_, _tmp5_);
	_g_free0 (_tmp5_);
	_tmp6_ = state;
	kkc_state_select_sentence (_tmp6_);
	_tmp7_ = state;
	kkc_state_reset (_tmp7_);
	_tmp9_ = command;
	if (g_strcmp0 (_tmp9_, "commit") == 0) {
		_tmp8_ = TRUE;
	} else {
		gboolean _tmp10_ = FALSE;
		const gchar* _tmp11_ = NULL;
		_tmp11_ = command;
		if (_tmp11_ == NULL) {
			KkcKeyEvent* _tmp12_ = NULL;
			gunichar _tmp13_ = 0U;
			gunichar _tmp14_ = 0U;
			_tmp12_ = key;
			_tmp13_ = kkc_key_event_get_unicode (_tmp12_);
			_tmp14_ = _tmp13_;
			_tmp10_ = _tmp14_ == ((gunichar) '\0');
		} else {
			_tmp10_ = FALSE;
		}
		_tmp8_ = _tmp10_;
	}
	if (_tmp8_) {
		result = TRUE;
		return result;
	}
	_tmp16_ = command;
	if (_tmp16_ == NULL) {
		gboolean _tmp17_ = FALSE;
		KkcKeyEvent* _tmp18_ = NULL;
		KkcModifierType _tmp19_ = 0;
		KkcModifierType _tmp20_ = 0;
		_tmp18_ = key;
		_tmp19_ = kkc_key_event_get_modifiers (_tmp18_);
		_tmp20_ = _tmp19_;
		if (_tmp20_ == 0) {
			_tmp17_ = TRUE;
		} else {
			KkcKeyEvent* _tmp21_ = NULL;
			KkcModifierType _tmp22_ = 0;
			KkcModifierType _tmp23_ = 0;
			_tmp21_ = key;
			_tmp22_ = kkc_key_event_get_modifiers (_tmp21_);
			_tmp23_ = _tmp22_;
			_tmp17_ = _tmp23_ == KKC_MODIFIER_TYPE_SHIFT_MASK;
		}
		_tmp15_ = _tmp17_;
	} else {
		_tmp15_ = FALSE;
	}
	if (_tmp15_) {
		result = FALSE;
		return result;
	}
	result = TRUE;
	return result;
}


static gboolean kkc_convert_sentence_state_handler_real_process_key_event (KkcStateHandler* base, KkcState* state, KkcKeyEvent* key) {
	KkcConvertSentenceStateHandler * self;
	gboolean result = FALSE;
	KkcState* _tmp0_ = NULL;
	KkcKeyEvent* _tmp1_ = NULL;
	gboolean _tmp2_ = FALSE;
	self = (KkcConvertSentenceStateHandler*) base;
	g_return_val_if_fail (state != NULL, FALSE);
	g_return_val_if_fail (key != NULL, FALSE);
	_tmp0_ = state;
	_tmp1_ = key;
	_tmp2_ = kkc_state_handler_dispatch_command ((KkcStateHandler*) self, _tmp0_, _tmp1_);
	result = _tmp2_;
	return result;
}


KkcConvertSentenceStateHandler* kkc_convert_sentence_state_handler_construct (GType object_type) {
	KkcConvertSentenceStateHandler * self = NULL;
	self = (KkcConvertSentenceStateHandler*) kkc_state_handler_construct (object_type);
	return self;
}


KkcConvertSentenceStateHandler* kkc_convert_sentence_state_handler_new (void) {
	return kkc_convert_sentence_state_handler_construct (KKC_TYPE_CONVERT_SENTENCE_STATE_HANDLER);
}


static gboolean _kkc_convert_sentence_state_handler_do_start_segment_conversion_kkc_command_callback (const gchar* command, KkcState* state, KkcKeyEvent* key, gpointer self) {
	gboolean result;
	result = kkc_convert_sentence_state_handler_do_start_segment_conversion ((KkcConvertSentenceStateHandler*) self, command, state, key);
	return result;
}


static gboolean _kkc_convert_sentence_state_handler_do_original_candidate_kkc_command_callback (const gchar* command, KkcState* state, KkcKeyEvent* key, gpointer self) {
	gboolean result;
	result = kkc_convert_sentence_state_handler_do_original_candidate ((KkcConvertSentenceStateHandler*) self, command, state, key);
	return result;
}


static gboolean _kkc_convert_sentence_state_handler_do_expand_segment_kkc_command_callback (const gchar* command, KkcState* state, KkcKeyEvent* key, gpointer self) {
	gboolean result;
	result = kkc_convert_sentence_state_handler_do_expand_segment ((KkcConvertSentenceStateHandler*) self, command, state, key);
	return result;
}


static gboolean _kkc_convert_sentence_state_handler_do_shrink_segment_kkc_command_callback (const gchar* command, KkcState* state, KkcKeyEvent* key, gpointer self) {
	gboolean result;
	result = kkc_convert_sentence_state_handler_do_shrink_segment ((KkcConvertSentenceStateHandler*) self, command, state, key);
	return result;
}


static gboolean _kkc_convert_sentence_state_handler_do_next_segment_kkc_command_callback (const gchar* command, KkcState* state, KkcKeyEvent* key, gpointer self) {
	gboolean result;
	result = kkc_convert_sentence_state_handler_do_next_segment ((KkcConvertSentenceStateHandler*) self, command, state, key);
	return result;
}


static gboolean _kkc_convert_sentence_state_handler_do_previous_segment_kkc_command_callback (const gchar* command, KkcState* state, KkcKeyEvent* key, gpointer self) {
	gboolean result;
	result = kkc_convert_sentence_state_handler_do_previous_segment ((KkcConvertSentenceStateHandler*) self, command, state, key);
	return result;
}


static gboolean _kkc_convert_sentence_state_handler_do_first_segment_kkc_command_callback (const gchar* command, KkcState* state, KkcKeyEvent* key, gpointer self) {
	gboolean result;
	result = kkc_convert_sentence_state_handler_do_first_segment ((KkcConvertSentenceStateHandler*) self, command, state, key);
	return result;
}


static gboolean _kkc_convert_sentence_state_handler_do_last_segment_kkc_command_callback (const gchar* command, KkcState* state, KkcKeyEvent* key, gpointer self) {
	gboolean result;
	result = kkc_convert_sentence_state_handler_do_last_segment ((KkcConvertSentenceStateHandler*) self, command, state, key);
	return result;
}


static gboolean _kkc_convert_sentence_state_handler_do_clear_unhandled_kkc_command_callback (const gchar* command, KkcState* state, KkcKeyEvent* key, gpointer self) {
	gboolean result;
	result = kkc_convert_sentence_state_handler_do_clear_unhandled ((KkcConvertSentenceStateHandler*) self, command, state, key);
	return result;
}


static GEnumValue* _g_enum_value_dup (GEnumValue* self) {
	GEnumValue* dup;
	dup = g_new0 (GEnumValue, 1);
	memcpy (dup, self, sizeof (GEnumValue));
	return dup;
}


static gpointer __g_enum_value_dup0 (gpointer self) {
	return self ? _g_enum_value_dup (self) : NULL;
}


static gboolean _kkc_convert_sentence_state_handler_do__kkc_command_callback (const gchar* command, KkcState* state, KkcKeyEvent* key, gpointer self) {
	gboolean result;
	result = kkc_convert_sentence_state_handler_do_ ((KkcConvertSentenceStateHandler*) self, command, state, key);
	return result;
}


static GObject * kkc_convert_sentence_state_handler_constructor (GType type, guint n_construct_properties, GObjectConstructParam * construct_properties) {
	GObject * obj;
	GObjectClass * parent_class;
	KkcConvertSentenceStateHandler * self;
	GEnumClass* enum_class = NULL;
	GTypeClass* _tmp0_ = NULL;
	parent_class = G_OBJECT_CLASS (kkc_convert_sentence_state_handler_parent_class);
	obj = parent_class->constructor (type, n_construct_properties, construct_properties);
	self = G_TYPE_CHECK_INSTANCE_CAST (obj, KKC_TYPE_CONVERT_SENTENCE_STATE_HANDLER, KkcConvertSentenceStateHandler);
	kkc_state_handler_register_command_callback ((KkcStateHandler*) self, "next-candidate", _kkc_convert_sentence_state_handler_do_start_segment_conversion_kkc_command_callback, self);
	kkc_state_handler_register_command_callback ((KkcStateHandler*) self, "previous-candidate", _kkc_convert_sentence_state_handler_do_start_segment_conversion_kkc_command_callback, self);
	kkc_state_handler_register_command_callback ((KkcStateHandler*) self, "purge-candidate", _kkc_convert_sentence_state_handler_do_start_segment_conversion_kkc_command_callback, self);
	kkc_state_handler_register_command_callback ((KkcStateHandler*) self, "original-candidate", _kkc_convert_sentence_state_handler_do_original_candidate_kkc_command_callback, self);
	kkc_state_handler_register_command_callback ((KkcStateHandler*) self, "expand-segment", _kkc_convert_sentence_state_handler_do_expand_segment_kkc_command_callback, self);
	kkc_state_handler_register_command_callback ((KkcStateHandler*) self, "shrink-segment", _kkc_convert_sentence_state_handler_do_shrink_segment_kkc_command_callback, self);
	kkc_state_handler_register_command_callback ((KkcStateHandler*) self, "next-segment", _kkc_convert_sentence_state_handler_do_next_segment_kkc_command_callback, self);
	kkc_state_handler_register_command_callback ((KkcStateHandler*) self, "previous-segment", _kkc_convert_sentence_state_handler_do_previous_segment_kkc_command_callback, self);
	kkc_state_handler_register_command_callback ((KkcStateHandler*) self, "first-segment", _kkc_convert_sentence_state_handler_do_first_segment_kkc_command_callback, self);
	kkc_state_handler_register_command_callback ((KkcStateHandler*) self, "last-segment", _kkc_convert_sentence_state_handler_do_last_segment_kkc_command_callback, self);
	kkc_state_handler_register_command_callback ((KkcStateHandler*) self, "abort", _kkc_convert_sentence_state_handler_do_clear_unhandled_kkc_command_callback, self);
	kkc_state_handler_register_command_callback ((KkcStateHandler*) self, "delete", _kkc_convert_sentence_state_handler_do_clear_unhandled_kkc_command_callback, self);
	_tmp0_ = g_type_class_ref (KKC_TYPE_KANA_MODE);
	enum_class = (GEnumClass*) _tmp0_;
	{
		gint i = 0;
		GEnumClass* _tmp1_ = NULL;
		gint _tmp2_ = 0;
		_tmp1_ = enum_class;
		_tmp2_ = _tmp1_->minimum;
		i = _tmp2_;
		{
			gboolean _tmp3_ = FALSE;
			_tmp3_ = TRUE;
			while (TRUE) {
				gint _tmp5_ = 0;
				GEnumClass* _tmp6_ = NULL;
				gint _tmp7_ = 0;
				GEnumValue* enum_value = NULL;
				GEnumClass* _tmp8_ = NULL;
				gint _tmp9_ = 0;
				GEnumValue* _tmp10_ = NULL;
				GEnumValue* _tmp11_ = NULL;
				GEnumValue* _tmp12_ = NULL;
				if (!_tmp3_) {
					gint _tmp4_ = 0;
					_tmp4_ = i;
					i = _tmp4_ + 1;
				}
				_tmp3_ = FALSE;
				_tmp5_ = i;
				_tmp6_ = enum_class;
				_tmp7_ = _tmp6_->maximum;
				if (!(_tmp5_ <= _tmp7_)) {
					break;
				}
				_tmp8_ = enum_class;
				_tmp9_ = i;
				_tmp10_ = g_enum_get_value (_tmp8_, _tmp9_);
				_tmp11_ = __g_enum_value_dup0 (_tmp10_);
				enum_value = _tmp11_;
				_tmp12_ = enum_value;
				if (_tmp12_ != NULL) {
					GEnumValue* _tmp13_ = NULL;
					const gchar* _tmp14_ = NULL;
					gchar* _tmp15_ = NULL;
					gchar* _tmp16_ = NULL;
					GEnumValue* _tmp17_ = NULL;
					gint _tmp18_ = 0;
					KkcConvertSentenceStateHandlerConvertCommandHandler* _tmp19_ = NULL;
					KkcConvertSentenceStateHandlerConvertCommandHandler* _tmp20_ = NULL;
					_tmp13_ = enum_value;
					_tmp14_ = (*_tmp13_).value_nick;
					_tmp15_ = g_strconcat ("convert-", _tmp14_, NULL);
					_tmp16_ = _tmp15_;
					_tmp17_ = enum_value;
					_tmp18_ = (*_tmp17_).value;
					_tmp19_ = kkc_convert_sentence_state_handler_convert_command_handler_new ((KkcKanaMode) _tmp18_);
					_tmp20_ = _tmp19_;
					kkc_state_handler_register_command_handler ((KkcStateHandler*) self, _tmp16_, (KkcCommandHandler*) _tmp20_);
					_g_object_unref0 (_tmp20_);
					_g_free0 (_tmp16_);
				}
				_g_free0 (enum_value);
			}
		}
	}
	kkc_state_handler_register_command_callback ((KkcStateHandler*) self, NULL, _kkc_convert_sentence_state_handler_do__kkc_command_callback, self);
	_g_type_class_unref0 (enum_class);
	return obj;
}


static KkcConvertSentenceStateHandlerConvertCommandHandler* kkc_convert_sentence_state_handler_convert_command_handler_construct (GType object_type, KkcKanaMode mode) {
	KkcConvertSentenceStateHandlerConvertCommandHandler * self = NULL;
	KkcKanaMode _tmp0_ = 0;
	self = (KkcConvertSentenceStateHandlerConvertCommandHandler*) g_object_new (object_type, NULL);
	_tmp0_ = mode;
	self->priv->mode = _tmp0_;
	return self;
}


static KkcConvertSentenceStateHandlerConvertCommandHandler* kkc_convert_sentence_state_handler_convert_command_handler_new (KkcKanaMode mode) {
	return kkc_convert_sentence_state_handler_convert_command_handler_construct (KKC_CONVERT_SENTENCE_STATE_HANDLER_TYPE_CONVERT_COMMAND_HANDLER, mode);
}


static gboolean kkc_convert_sentence_state_handler_convert_command_handler_real_call (KkcCommandHandler* base, const gchar* command, KkcState* state, KkcKeyEvent* key) {
	KkcConvertSentenceStateHandlerConvertCommandHandler * self;
	gboolean result = FALSE;
	KkcState* _tmp0_ = NULL;
	KkcKanaMode _tmp1_ = 0;
	self = (KkcConvertSentenceStateHandlerConvertCommandHandler*) base;
	g_return_val_if_fail (state != NULL, FALSE);
	g_return_val_if_fail (key != NULL, FALSE);
	_tmp0_ = state;
	_tmp1_ = self->priv->mode;
	kkc_state_convert_segment_by_kana_mode (_tmp0_, _tmp1_);
	result = TRUE;
	return result;
}


static void kkc_convert_sentence_state_handler_convert_command_handler_class_init (KkcConvertSentenceStateHandlerConvertCommandHandlerClass * klass) {
	kkc_convert_sentence_state_handler_convert_command_handler_parent_class = g_type_class_peek_parent (klass);
	g_type_class_add_private (klass, sizeof (KkcConvertSentenceStateHandlerConvertCommandHandlerPrivate));
	G_OBJECT_CLASS (klass)->finalize = kkc_convert_sentence_state_handler_convert_command_handler_finalize;
}


static void kkc_convert_sentence_state_handler_convert_command_handler_kkc_command_handler_interface_init (KkcCommandHandlerIface * iface) {
	kkc_convert_sentence_state_handler_convert_command_handler_kkc_command_handler_parent_iface = g_type_interface_peek_parent (iface);
	iface->call = (gboolean (*)(KkcCommandHandler*, const gchar*, KkcState*, KkcKeyEvent*)) kkc_convert_sentence_state_handler_convert_command_handler_real_call;
}


static void kkc_convert_sentence_state_handler_convert_command_handler_instance_init (KkcConvertSentenceStateHandlerConvertCommandHandler * self) {
	self->priv = KKC_CONVERT_SENTENCE_STATE_HANDLER_CONVERT_COMMAND_HANDLER_GET_PRIVATE (self);
}


static void kkc_convert_sentence_state_handler_convert_command_handler_finalize (GObject* obj) {
	KkcConvertSentenceStateHandlerConvertCommandHandler * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (obj, KKC_CONVERT_SENTENCE_STATE_HANDLER_TYPE_CONVERT_COMMAND_HANDLER, KkcConvertSentenceStateHandlerConvertCommandHandler);
	G_OBJECT_CLASS (kkc_convert_sentence_state_handler_convert_command_handler_parent_class)->finalize (obj);
}


static GType kkc_convert_sentence_state_handler_convert_command_handler_get_type (void) {
	static volatile gsize kkc_convert_sentence_state_handler_convert_command_handler_type_id__volatile = 0;
	if (g_once_init_enter (&kkc_convert_sentence_state_handler_convert_command_handler_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (KkcConvertSentenceStateHandlerConvertCommandHandlerClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) kkc_convert_sentence_state_handler_convert_command_handler_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (KkcConvertSentenceStateHandlerConvertCommandHandler), 0, (GInstanceInitFunc) kkc_convert_sentence_state_handler_convert_command_handler_instance_init, NULL };
		static const GInterfaceInfo kkc_command_handler_info = { (GInterfaceInitFunc) kkc_convert_sentence_state_handler_convert_command_handler_kkc_command_handler_interface_init, (GInterfaceFinalizeFunc) NULL, NULL};
		GType kkc_convert_sentence_state_handler_convert_command_handler_type_id;
		kkc_convert_sentence_state_handler_convert_command_handler_type_id = g_type_register_static (G_TYPE_OBJECT, "KkcConvertSentenceStateHandlerConvertCommandHandler", &g_define_type_info, 0);
		g_type_add_interface_static (kkc_convert_sentence_state_handler_convert_command_handler_type_id, KKC_TYPE_COMMAND_HANDLER, &kkc_command_handler_info);
		g_once_init_leave (&kkc_convert_sentence_state_handler_convert_command_handler_type_id__volatile, kkc_convert_sentence_state_handler_convert_command_handler_type_id);
	}
	return kkc_convert_sentence_state_handler_convert_command_handler_type_id__volatile;
}


static void kkc_convert_sentence_state_handler_class_init (KkcConvertSentenceStateHandlerClass * klass) {
	kkc_convert_sentence_state_handler_parent_class = g_type_class_peek_parent (klass);
	((KkcStateHandlerClass *) klass)->process_key_event = kkc_convert_sentence_state_handler_real_process_key_event;
	G_OBJECT_CLASS (klass)->constructor = kkc_convert_sentence_state_handler_constructor;
}


static void kkc_convert_sentence_state_handler_instance_init (KkcConvertSentenceStateHandler * self) {
}


GType kkc_convert_sentence_state_handler_get_type (void) {
	static volatile gsize kkc_convert_sentence_state_handler_type_id__volatile = 0;
	if (g_once_init_enter (&kkc_convert_sentence_state_handler_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (KkcConvertSentenceStateHandlerClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) kkc_convert_sentence_state_handler_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (KkcConvertSentenceStateHandler), 0, (GInstanceInitFunc) kkc_convert_sentence_state_handler_instance_init, NULL };
		GType kkc_convert_sentence_state_handler_type_id;
		kkc_convert_sentence_state_handler_type_id = g_type_register_static (KKC_TYPE_STATE_HANDLER, "KkcConvertSentenceStateHandler", &g_define_type_info, 0);
		g_once_init_leave (&kkc_convert_sentence_state_handler_type_id__volatile, kkc_convert_sentence_state_handler_type_id);
	}
	return kkc_convert_sentence_state_handler_type_id__volatile;
}



