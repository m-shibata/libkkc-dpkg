/* decoder.c generated by valac 0.21.1.40-3bbfb, the Vala compiler
 * generated from decoder.vala, do not modify */

/*
 * Copyright (C) 2012-2013 Daiki Ueno <ueno@gnu.org>
 * Copyright (C) 2012-2013 Red Hat, Inc.
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */

#include <glib.h>
#include <glib-object.h>
#include <stdlib.h>
#include <string.h>
#include <float.h>
#include <math.h>


#define KKC_TYPE_DECODER (kkc_decoder_get_type ())
#define KKC_DECODER(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), KKC_TYPE_DECODER, KkcDecoder))
#define KKC_DECODER_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), KKC_TYPE_DECODER, KkcDecoderClass))
#define KKC_IS_DECODER(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), KKC_TYPE_DECODER))
#define KKC_IS_DECODER_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), KKC_TYPE_DECODER))
#define KKC_DECODER_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), KKC_TYPE_DECODER, KkcDecoderClass))

typedef struct _KkcDecoder KkcDecoder;
typedef struct _KkcDecoderClass KkcDecoderClass;
typedef struct _KkcDecoderPrivate KkcDecoderPrivate;

#define KKC_TYPE_SEGMENT (kkc_segment_get_type ())
#define KKC_SEGMENT(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), KKC_TYPE_SEGMENT, KkcSegment))
#define KKC_SEGMENT_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), KKC_TYPE_SEGMENT, KkcSegmentClass))
#define KKC_IS_SEGMENT(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), KKC_TYPE_SEGMENT))
#define KKC_IS_SEGMENT_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), KKC_TYPE_SEGMENT))
#define KKC_SEGMENT_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), KKC_TYPE_SEGMENT, KkcSegmentClass))

typedef struct _KkcSegment KkcSegment;
typedef struct _KkcSegmentClass KkcSegmentClass;

#define KKC_TYPE_LANGUAGE_MODEL (kkc_language_model_get_type ())
#define KKC_LANGUAGE_MODEL(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), KKC_TYPE_LANGUAGE_MODEL, KkcLanguageModel))
#define KKC_LANGUAGE_MODEL_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), KKC_TYPE_LANGUAGE_MODEL, KkcLanguageModelClass))
#define KKC_IS_LANGUAGE_MODEL(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), KKC_TYPE_LANGUAGE_MODEL))
#define KKC_IS_LANGUAGE_MODEL_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), KKC_TYPE_LANGUAGE_MODEL))
#define KKC_LANGUAGE_MODEL_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), KKC_TYPE_LANGUAGE_MODEL, KkcLanguageModelClass))

typedef struct _KkcLanguageModel KkcLanguageModel;
typedef struct _KkcLanguageModelClass KkcLanguageModelClass;

#define KKC_TYPE_UNIGRAM_LANGUAGE_MODEL (kkc_unigram_language_model_get_type ())
#define KKC_UNIGRAM_LANGUAGE_MODEL(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), KKC_TYPE_UNIGRAM_LANGUAGE_MODEL, KkcUnigramLanguageModel))
#define KKC_IS_UNIGRAM_LANGUAGE_MODEL(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), KKC_TYPE_UNIGRAM_LANGUAGE_MODEL))
#define KKC_UNIGRAM_LANGUAGE_MODEL_GET_INTERFACE(obj) (G_TYPE_INSTANCE_GET_INTERFACE ((obj), KKC_TYPE_UNIGRAM_LANGUAGE_MODEL, KkcUnigramLanguageModelIface))

typedef struct _KkcUnigramLanguageModel KkcUnigramLanguageModel;
typedef struct _KkcUnigramLanguageModelIface KkcUnigramLanguageModelIface;

#define KKC_TYPE_LANGUAGE_MODEL_ENTRY (kkc_language_model_entry_get_type ())
typedef struct _KkcLanguageModelEntry KkcLanguageModelEntry;

#define KKC_TYPE_BIGRAM_LANGUAGE_MODEL (kkc_bigram_language_model_get_type ())
#define KKC_BIGRAM_LANGUAGE_MODEL(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), KKC_TYPE_BIGRAM_LANGUAGE_MODEL, KkcBigramLanguageModel))
#define KKC_IS_BIGRAM_LANGUAGE_MODEL(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), KKC_TYPE_BIGRAM_LANGUAGE_MODEL))
#define KKC_BIGRAM_LANGUAGE_MODEL_GET_INTERFACE(obj) (G_TYPE_INSTANCE_GET_INTERFACE ((obj), KKC_TYPE_BIGRAM_LANGUAGE_MODEL, KkcBigramLanguageModelIface))

typedef struct _KkcBigramLanguageModel KkcBigramLanguageModel;
typedef struct _KkcBigramLanguageModelIface KkcBigramLanguageModelIface;

#define KKC_TYPE_TRIGRAM_LANGUAGE_MODEL (kkc_trigram_language_model_get_type ())
#define KKC_TRIGRAM_LANGUAGE_MODEL(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), KKC_TYPE_TRIGRAM_LANGUAGE_MODEL, KkcTrigramLanguageModel))
#define KKC_IS_TRIGRAM_LANGUAGE_MODEL(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), KKC_TYPE_TRIGRAM_LANGUAGE_MODEL))
#define KKC_TRIGRAM_LANGUAGE_MODEL_GET_INTERFACE(obj) (G_TYPE_INSTANCE_GET_INTERFACE ((obj), KKC_TYPE_TRIGRAM_LANGUAGE_MODEL, KkcTrigramLanguageModelIface))

typedef struct _KkcTrigramLanguageModel KkcTrigramLanguageModel;
typedef struct _KkcTrigramLanguageModelIface KkcTrigramLanguageModelIface;

#define KKC_TYPE_BIGRAM_DECODER (kkc_bigram_decoder_get_type ())
#define KKC_BIGRAM_DECODER(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), KKC_TYPE_BIGRAM_DECODER, KkcBigramDecoder))
#define KKC_BIGRAM_DECODER_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), KKC_TYPE_BIGRAM_DECODER, KkcBigramDecoderClass))
#define KKC_IS_BIGRAM_DECODER(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), KKC_TYPE_BIGRAM_DECODER))
#define KKC_IS_BIGRAM_DECODER_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), KKC_TYPE_BIGRAM_DECODER))
#define KKC_BIGRAM_DECODER_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), KKC_TYPE_BIGRAM_DECODER, KkcBigramDecoderClass))

typedef struct _KkcBigramDecoder KkcBigramDecoder;
typedef struct _KkcBigramDecoderClass KkcBigramDecoderClass;

#define KKC_TYPE_TRIGRAM_DECODER (kkc_trigram_decoder_get_type ())
#define KKC_TRIGRAM_DECODER(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), KKC_TYPE_TRIGRAM_DECODER, KkcTrigramDecoder))
#define KKC_TRIGRAM_DECODER_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), KKC_TYPE_TRIGRAM_DECODER, KkcTrigramDecoderClass))
#define KKC_IS_TRIGRAM_DECODER(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), KKC_TYPE_TRIGRAM_DECODER))
#define KKC_IS_TRIGRAM_DECODER_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), KKC_TYPE_TRIGRAM_DECODER))
#define KKC_TRIGRAM_DECODER_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), KKC_TYPE_TRIGRAM_DECODER, KkcTrigramDecoderClass))

typedef struct _KkcTrigramDecoder KkcTrigramDecoder;
typedef struct _KkcTrigramDecoderClass KkcTrigramDecoderClass;

struct _KkcDecoder {
	GObject parent_instance;
	KkcDecoderPrivate * priv;
};

struct _KkcDecoderClass {
	GObjectClass parent_class;
	KkcSegment** (*decode) (KkcDecoder* self, const gchar* input, gint nbest, gint* constraint, int constraint_length1, int* result_length1);
	KkcSegment** (*decode_with_costs) (KkcDecoder* self, const gchar* input, gint nbest, gint* constraint, int constraint_length1, gdouble max_distance, gdouble min_path_cost, int* result_length1);
};

struct _KkcLanguageModelEntry {
	gchar* input;
	gchar* output;
	guint id;
};

struct _KkcUnigramLanguageModelIface {
	GTypeInterface parent_iface;
	gdouble (*unigram_cost) (KkcUnigramLanguageModel* self, KkcLanguageModelEntry* entry);
	gdouble (*unigram_backoff) (KkcUnigramLanguageModel* self, KkcLanguageModelEntry* entry);
};

struct _KkcBigramLanguageModelIface {
	GTypeInterface parent_iface;
	gboolean (*has_bigram) (KkcBigramLanguageModel* self, KkcLanguageModelEntry* pentry, KkcLanguageModelEntry* entry);
	gdouble (*bigram_cost) (KkcBigramLanguageModel* self, KkcLanguageModelEntry* pentry, KkcLanguageModelEntry* entry);
	gdouble (*bigram_backoff) (KkcBigramLanguageModel* self, KkcLanguageModelEntry* pentry, KkcLanguageModelEntry* entry);
};

struct _KkcTrigramLanguageModelIface {
	GTypeInterface parent_iface;
	gboolean (*has_trigram) (KkcTrigramLanguageModel* self, KkcLanguageModelEntry* ppentry, KkcLanguageModelEntry* pentry, KkcLanguageModelEntry* entry);
	gdouble (*trigram_cost) (KkcTrigramLanguageModel* self, KkcLanguageModelEntry* ppentry, KkcLanguageModelEntry* pentry, KkcLanguageModelEntry* entry);
};


static gpointer kkc_decoder_parent_class = NULL;

GType kkc_decoder_get_type (void) G_GNUC_CONST;
GType kkc_segment_get_type (void) G_GNUC_CONST;
enum  {
	KKC_DECODER_DUMMY_PROPERTY
};
KkcSegment** kkc_decoder_decode (KkcDecoder* self, const gchar* input, gint nbest, gint* constraint, int constraint_length1, int* result_length1);
static KkcSegment** kkc_decoder_real_decode (KkcDecoder* self, const gchar* input, gint nbest, gint* constraint, int constraint_length1, int* result_length1);
KkcSegment** kkc_decoder_decode_with_costs (KkcDecoder* self, const gchar* input, gint nbest, gint* constraint, int constraint_length1, gdouble max_distance, gdouble min_path_cost, int* result_length1);
static KkcSegment** kkc_decoder_real_decode_with_costs (KkcDecoder* self, const gchar* input, gint nbest, gint* constraint, int constraint_length1, gdouble max_distance, gdouble min_path_cost, int* result_length1);
GType kkc_language_model_get_type (void) G_GNUC_CONST;
KkcDecoder* kkc_decoder_create (KkcLanguageModel* model);
GType kkc_language_model_entry_get_type (void) G_GNUC_CONST;
KkcLanguageModelEntry* kkc_language_model_entry_dup (const KkcLanguageModelEntry* self);
void kkc_language_model_entry_free (KkcLanguageModelEntry* self);
void kkc_language_model_entry_copy (const KkcLanguageModelEntry* self, KkcLanguageModelEntry* dest);
void kkc_language_model_entry_destroy (KkcLanguageModelEntry* self);
GType kkc_unigram_language_model_get_type (void) G_GNUC_CONST;
GType kkc_bigram_language_model_get_type (void) G_GNUC_CONST;
GType kkc_trigram_language_model_get_type (void) G_GNUC_CONST;
KkcTrigramDecoder* kkc_trigram_decoder_new (KkcTrigramLanguageModel* model);
KkcTrigramDecoder* kkc_trigram_decoder_construct (GType object_type, KkcTrigramLanguageModel* model);
GType kkc_bigram_decoder_get_type (void) G_GNUC_CONST;
GType kkc_trigram_decoder_get_type (void) G_GNUC_CONST;
KkcBigramDecoder* kkc_bigram_decoder_new (KkcBigramLanguageModel* model);
KkcBigramDecoder* kkc_bigram_decoder_construct (GType object_type, KkcBigramLanguageModel* model);
KkcDecoder* kkc_decoder_construct (GType object_type);


static KkcSegment** kkc_decoder_real_decode (KkcDecoder* self, const gchar* input, gint nbest, gint* constraint, int constraint_length1, int* result_length1) {
	g_critical ("Type `%s' does not implement abstract method `kkc_decoder_decode'", g_type_name (G_TYPE_FROM_INSTANCE (self)));
	return NULL;
}


KkcSegment** kkc_decoder_decode (KkcDecoder* self, const gchar* input, gint nbest, gint* constraint, int constraint_length1, int* result_length1) {
	g_return_val_if_fail (self != NULL, NULL);
	return KKC_DECODER_GET_CLASS (self)->decode (self, input, nbest, constraint, constraint_length1, result_length1);
}


static KkcSegment** kkc_decoder_real_decode_with_costs (KkcDecoder* self, const gchar* input, gint nbest, gint* constraint, int constraint_length1, gdouble max_distance, gdouble min_path_cost, int* result_length1) {
	g_critical ("Type `%s' does not implement abstract method `kkc_decoder_decode_with_costs'", g_type_name (G_TYPE_FROM_INSTANCE (self)));
	return NULL;
}


KkcSegment** kkc_decoder_decode_with_costs (KkcDecoder* self, const gchar* input, gint nbest, gint* constraint, int constraint_length1, gdouble max_distance, gdouble min_path_cost, int* result_length1) {
	g_return_val_if_fail (self != NULL, NULL);
	return KKC_DECODER_GET_CLASS (self)->decode_with_costs (self, input, nbest, constraint, constraint_length1, max_distance, min_path_cost, result_length1);
}


KkcDecoder* kkc_decoder_create (KkcLanguageModel* model) {
	KkcDecoder* result = NULL;
	KkcLanguageModel* _tmp0_ = NULL;
	g_return_val_if_fail (model != NULL, NULL);
	_tmp0_ = model;
	if (G_TYPE_CHECK_INSTANCE_TYPE (_tmp0_, KKC_TYPE_TRIGRAM_LANGUAGE_MODEL)) {
		KkcLanguageModel* _tmp1_ = NULL;
		KkcTrigramDecoder* _tmp2_ = NULL;
		_tmp1_ = model;
		_tmp2_ = kkc_trigram_decoder_new (G_TYPE_CHECK_INSTANCE_TYPE (_tmp1_, KKC_TYPE_TRIGRAM_LANGUAGE_MODEL) ? ((KkcTrigramLanguageModel*) _tmp1_) : NULL);
		result = (KkcDecoder*) _tmp2_;
		return result;
	} else {
		KkcLanguageModel* _tmp3_ = NULL;
		_tmp3_ = model;
		if (G_TYPE_CHECK_INSTANCE_TYPE (_tmp3_, KKC_TYPE_BIGRAM_LANGUAGE_MODEL)) {
			KkcLanguageModel* _tmp4_ = NULL;
			KkcBigramDecoder* _tmp5_ = NULL;
			_tmp4_ = model;
			_tmp5_ = kkc_bigram_decoder_new (G_TYPE_CHECK_INSTANCE_TYPE (_tmp4_, KKC_TYPE_BIGRAM_LANGUAGE_MODEL) ? ((KkcBigramLanguageModel*) _tmp4_) : NULL);
			result = (KkcDecoder*) _tmp5_;
			return result;
		} else {
			g_assert_not_reached ();
		}
	}
}


KkcDecoder* kkc_decoder_construct (GType object_type) {
	KkcDecoder * self = NULL;
	self = (KkcDecoder*) g_object_new (object_type, NULL);
	return self;
}


static void kkc_decoder_class_init (KkcDecoderClass * klass) {
	kkc_decoder_parent_class = g_type_class_peek_parent (klass);
	KKC_DECODER_CLASS (klass)->decode = kkc_decoder_real_decode;
	KKC_DECODER_CLASS (klass)->decode_with_costs = kkc_decoder_real_decode_with_costs;
}


static void kkc_decoder_instance_init (KkcDecoder * self) {
}


GType kkc_decoder_get_type (void) {
	static volatile gsize kkc_decoder_type_id__volatile = 0;
	if (g_once_init_enter (&kkc_decoder_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (KkcDecoderClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) kkc_decoder_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (KkcDecoder), 0, (GInstanceInitFunc) kkc_decoder_instance_init, NULL };
		GType kkc_decoder_type_id;
		kkc_decoder_type_id = g_type_register_static (G_TYPE_OBJECT, "KkcDecoder", &g_define_type_info, G_TYPE_FLAG_ABSTRACT);
		g_once_init_leave (&kkc_decoder_type_id__volatile, kkc_decoder_type_id);
	}
	return kkc_decoder_type_id__volatile;
}



