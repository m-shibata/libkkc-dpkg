/* rule.c generated by valac 0.24.0.131-42e78, the Vala compiler
 * generated from rule.vala, do not modify */

/*
 * Copyright (C) 2011-2014 Daiki Ueno <ueno@gnu.org>
 * Copyright (C) 2011-2014 Red Hat, Inc.
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */

#include <glib.h>
#include <glib-object.h>
#include <stdlib.h>
#include <string.h>
#include <gee.h>
#include <json-glib/json-glib.h>
#include <gio/gio.h>
#include <glib/gstdio.h>


#define KKC_TYPE_MAP_FILE (kkc_map_file_get_type ())
#define KKC_MAP_FILE(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), KKC_TYPE_MAP_FILE, KkcMapFile))
#define KKC_MAP_FILE_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), KKC_TYPE_MAP_FILE, KkcMapFileClass))
#define KKC_IS_MAP_FILE(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), KKC_TYPE_MAP_FILE))
#define KKC_IS_MAP_FILE_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), KKC_TYPE_MAP_FILE))
#define KKC_MAP_FILE_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), KKC_TYPE_MAP_FILE, KkcMapFileClass))

typedef struct _KkcMapFile KkcMapFile;
typedef struct _KkcMapFileClass KkcMapFileClass;
typedef struct _KkcMapFilePrivate KkcMapFilePrivate;

#define KKC_TYPE_KEYMAP_MAP_FILE (kkc_keymap_map_file_get_type ())
#define KKC_KEYMAP_MAP_FILE(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), KKC_TYPE_KEYMAP_MAP_FILE, KkcKeymapMapFile))
#define KKC_KEYMAP_MAP_FILE_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), KKC_TYPE_KEYMAP_MAP_FILE, KkcKeymapMapFileClass))
#define KKC_IS_KEYMAP_MAP_FILE(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), KKC_TYPE_KEYMAP_MAP_FILE))
#define KKC_IS_KEYMAP_MAP_FILE_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), KKC_TYPE_KEYMAP_MAP_FILE))
#define KKC_KEYMAP_MAP_FILE_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), KKC_TYPE_KEYMAP_MAP_FILE, KkcKeymapMapFileClass))

typedef struct _KkcKeymapMapFile KkcKeymapMapFile;
typedef struct _KkcKeymapMapFileClass KkcKeymapMapFileClass;
typedef struct _KkcKeymapMapFilePrivate KkcKeymapMapFilePrivate;

#define KKC_TYPE_KEYMAP (kkc_keymap_get_type ())
#define KKC_KEYMAP(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), KKC_TYPE_KEYMAP, KkcKeymap))
#define KKC_KEYMAP_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), KKC_TYPE_KEYMAP, KkcKeymapClass))
#define KKC_IS_KEYMAP(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), KKC_TYPE_KEYMAP))
#define KKC_IS_KEYMAP_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), KKC_TYPE_KEYMAP))
#define KKC_KEYMAP_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), KKC_TYPE_KEYMAP, KkcKeymapClass))

typedef struct _KkcKeymap KkcKeymap;
typedef struct _KkcKeymapClass KkcKeymapClass;
#define _g_object_unref0(var) ((var == NULL) ? NULL : (var = (g_object_unref (var), NULL)))

#define KKC_TYPE_KEY_EVENT (kkc_key_event_get_type ())
#define KKC_KEY_EVENT(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), KKC_TYPE_KEY_EVENT, KkcKeyEvent))
#define KKC_KEY_EVENT_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), KKC_TYPE_KEY_EVENT, KkcKeyEventClass))
#define KKC_IS_KEY_EVENT(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), KKC_TYPE_KEY_EVENT))
#define KKC_IS_KEY_EVENT_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), KKC_TYPE_KEY_EVENT))
#define KKC_KEY_EVENT_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), KKC_TYPE_KEY_EVENT, KkcKeyEventClass))

typedef struct _KkcKeyEvent KkcKeyEvent;
typedef struct _KkcKeyEventClass KkcKeyEventClass;
#define _g_error_free0(var) ((var == NULL) ? NULL : (var = (g_error_free (var), NULL)))
#define __vala_JsonNode_free0(var) ((var == NULL) ? NULL : (var = (_vala_JsonNode_free (var), NULL)))
#define _g_free0(var) (var = (g_free (var), NULL))

#define KKC_TYPE_METADATA_FILE (kkc_metadata_file_get_type ())
#define KKC_METADATA_FILE(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), KKC_TYPE_METADATA_FILE, KkcMetadataFile))
#define KKC_METADATA_FILE_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), KKC_TYPE_METADATA_FILE, KkcMetadataFileClass))
#define KKC_IS_METADATA_FILE(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), KKC_TYPE_METADATA_FILE))
#define KKC_IS_METADATA_FILE_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), KKC_TYPE_METADATA_FILE))
#define KKC_METADATA_FILE_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), KKC_TYPE_METADATA_FILE, KkcMetadataFileClass))

typedef struct _KkcMetadataFile KkcMetadataFile;
typedef struct _KkcMetadataFileClass KkcMetadataFileClass;

#define KKC_TYPE_RULE_METADATA (kkc_rule_metadata_get_type ())
#define KKC_RULE_METADATA(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), KKC_TYPE_RULE_METADATA, KkcRuleMetadata))
#define KKC_RULE_METADATA_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), KKC_TYPE_RULE_METADATA, KkcRuleMetadataClass))
#define KKC_IS_RULE_METADATA(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), KKC_TYPE_RULE_METADATA))
#define KKC_IS_RULE_METADATA_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), KKC_TYPE_RULE_METADATA))
#define KKC_RULE_METADATA_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), KKC_TYPE_RULE_METADATA, KkcRuleMetadataClass))

typedef struct _KkcRuleMetadata KkcRuleMetadata;
typedef struct _KkcRuleMetadataClass KkcRuleMetadataClass;

#define KKC_TYPE_ROM_KANA_MAP_FILE (kkc_rom_kana_map_file_get_type ())
#define KKC_ROM_KANA_MAP_FILE(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), KKC_TYPE_ROM_KANA_MAP_FILE, KkcRomKanaMapFile))
#define KKC_ROM_KANA_MAP_FILE_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), KKC_TYPE_ROM_KANA_MAP_FILE, KkcRomKanaMapFileClass))
#define KKC_IS_ROM_KANA_MAP_FILE(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), KKC_TYPE_ROM_KANA_MAP_FILE))
#define KKC_IS_ROM_KANA_MAP_FILE_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), KKC_TYPE_ROM_KANA_MAP_FILE))
#define KKC_ROM_KANA_MAP_FILE_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), KKC_TYPE_ROM_KANA_MAP_FILE, KkcRomKanaMapFileClass))

typedef struct _KkcRomKanaMapFile KkcRomKanaMapFile;
typedef struct _KkcRomKanaMapFileClass KkcRomKanaMapFileClass;
typedef struct _KkcRomKanaMapFilePrivate KkcRomKanaMapFilePrivate;

#define KKC_TYPE_ROM_KANA_NODE (kkc_rom_kana_node_get_type ())
#define KKC_ROM_KANA_NODE(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), KKC_TYPE_ROM_KANA_NODE, KkcRomKanaNode))
#define KKC_ROM_KANA_NODE_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), KKC_TYPE_ROM_KANA_NODE, KkcRomKanaNodeClass))
#define KKC_IS_ROM_KANA_NODE(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), KKC_TYPE_ROM_KANA_NODE))
#define KKC_IS_ROM_KANA_NODE_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), KKC_TYPE_ROM_KANA_NODE))
#define KKC_ROM_KANA_NODE_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), KKC_TYPE_ROM_KANA_NODE, KkcRomKanaNodeClass))

typedef struct _KkcRomKanaNode KkcRomKanaNode;
typedef struct _KkcRomKanaNodeClass KkcRomKanaNodeClass;

#define KKC_TYPE_ROM_KANA_ENTRY (kkc_rom_kana_entry_get_type ())
typedef struct _KkcRomKanaEntry KkcRomKanaEntry;
#define _json_array_unref0(var) ((var == NULL) ? NULL : (var = (json_array_unref (var), NULL)))
typedef struct _KkcMetadataFilePrivate KkcMetadataFilePrivate;
typedef struct _KkcRuleMetadataPrivate KkcRuleMetadataPrivate;

#define KKC_TYPE_KEY_EVENT_FILTER (kkc_key_event_filter_get_type ())
#define KKC_KEY_EVENT_FILTER(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), KKC_TYPE_KEY_EVENT_FILTER, KkcKeyEventFilter))
#define KKC_KEY_EVENT_FILTER_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), KKC_TYPE_KEY_EVENT_FILTER, KkcKeyEventFilterClass))
#define KKC_IS_KEY_EVENT_FILTER(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), KKC_TYPE_KEY_EVENT_FILTER))
#define KKC_IS_KEY_EVENT_FILTER_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), KKC_TYPE_KEY_EVENT_FILTER))
#define KKC_KEY_EVENT_FILTER_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), KKC_TYPE_KEY_EVENT_FILTER, KkcKeyEventFilterClass))

typedef struct _KkcKeyEventFilter KkcKeyEventFilter;
typedef struct _KkcKeyEventFilterClass KkcKeyEventFilterClass;

#define KKC_TYPE_SIMPLE_KEY_EVENT_FILTER (kkc_simple_key_event_filter_get_type ())
#define KKC_SIMPLE_KEY_EVENT_FILTER(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), KKC_TYPE_SIMPLE_KEY_EVENT_FILTER, KkcSimpleKeyEventFilter))
#define KKC_SIMPLE_KEY_EVENT_FILTER_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), KKC_TYPE_SIMPLE_KEY_EVENT_FILTER, KkcSimpleKeyEventFilterClass))
#define KKC_IS_SIMPLE_KEY_EVENT_FILTER(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), KKC_TYPE_SIMPLE_KEY_EVENT_FILTER))
#define KKC_IS_SIMPLE_KEY_EVENT_FILTER_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), KKC_TYPE_SIMPLE_KEY_EVENT_FILTER))
#define KKC_SIMPLE_KEY_EVENT_FILTER_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), KKC_TYPE_SIMPLE_KEY_EVENT_FILTER, KkcSimpleKeyEventFilterClass))

typedef struct _KkcSimpleKeyEventFilter KkcSimpleKeyEventFilter;
typedef struct _KkcSimpleKeyEventFilterClass KkcSimpleKeyEventFilterClass;

#define KKC_TYPE_NICOLA_KEY_EVENT_FILTER (kkc_nicola_key_event_filter_get_type ())
#define KKC_NICOLA_KEY_EVENT_FILTER(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), KKC_TYPE_NICOLA_KEY_EVENT_FILTER, KkcNicolaKeyEventFilter))
#define KKC_NICOLA_KEY_EVENT_FILTER_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), KKC_TYPE_NICOLA_KEY_EVENT_FILTER, KkcNicolaKeyEventFilterClass))
#define KKC_IS_NICOLA_KEY_EVENT_FILTER(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), KKC_TYPE_NICOLA_KEY_EVENT_FILTER))
#define KKC_IS_NICOLA_KEY_EVENT_FILTER_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), KKC_TYPE_NICOLA_KEY_EVENT_FILTER))
#define KKC_NICOLA_KEY_EVENT_FILTER_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), KKC_TYPE_NICOLA_KEY_EVENT_FILTER, KkcNicolaKeyEventFilterClass))

typedef struct _KkcNicolaKeyEventFilter KkcNicolaKeyEventFilter;
typedef struct _KkcNicolaKeyEventFilterClass KkcNicolaKeyEventFilterClass;

#define KKC_TYPE_KANA_KEY_EVENT_FILTER (kkc_kana_key_event_filter_get_type ())
#define KKC_KANA_KEY_EVENT_FILTER(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), KKC_TYPE_KANA_KEY_EVENT_FILTER, KkcKanaKeyEventFilter))
#define KKC_KANA_KEY_EVENT_FILTER_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), KKC_TYPE_KANA_KEY_EVENT_FILTER, KkcKanaKeyEventFilterClass))
#define KKC_IS_KANA_KEY_EVENT_FILTER(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), KKC_TYPE_KANA_KEY_EVENT_FILTER))
#define KKC_IS_KANA_KEY_EVENT_FILTER_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), KKC_TYPE_KANA_KEY_EVENT_FILTER))
#define KKC_KANA_KEY_EVENT_FILTER_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), KKC_TYPE_KANA_KEY_EVENT_FILTER, KkcKanaKeyEventFilterClass))

typedef struct _KkcKanaKeyEventFilter KkcKanaKeyEventFilter;
typedef struct _KkcKanaKeyEventFilterClass KkcKanaKeyEventFilterClass;

#define KKC_TYPE_RULE (kkc_rule_get_type ())
#define KKC_RULE(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), KKC_TYPE_RULE, KkcRule))
#define KKC_RULE_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), KKC_TYPE_RULE, KkcRuleClass))
#define KKC_IS_RULE(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), KKC_TYPE_RULE))
#define KKC_IS_RULE_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), KKC_TYPE_RULE))
#define KKC_RULE_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), KKC_TYPE_RULE, KkcRuleClass))

typedef struct _KkcRule KkcRule;
typedef struct _KkcRuleClass KkcRuleClass;
typedef struct _KkcRulePrivate KkcRulePrivate;

#define KKC_TYPE_KANA_MODE (kkc_kana_mode_get_type ())

#define KKC_TYPE_INPUT_MODE (kkc_input_mode_get_type ())
#define _g_type_class_unref0(var) ((var == NULL) ? NULL : (var = (g_type_class_unref (var), NULL)))
#define _g_dir_close0(var) ((var == NULL) ? NULL : (var = (g_dir_close (var), NULL)))

struct _KkcMapFile {
	GObject parent_instance;
	KkcMapFilePrivate * priv;
};

struct _KkcMapFileClass {
	GObjectClass parent_class;
	gchar* (*uniquify) (KkcMapFile* self, const gchar* key);
};

struct _KkcKeymapMapFile {
	KkcMapFile parent_instance;
	KkcKeymapMapFilePrivate * priv;
	KkcKeymap* keymap;
	KkcKeymap* parent_keymap;
};

struct _KkcKeymapMapFileClass {
	KkcMapFileClass parent_class;
};

typedef enum  {
	KKC_KEY_EVENT_FORMAT_ERROR_PARSE_FAILED,
	KKC_KEY_EVENT_FORMAT_ERROR_KEYSYM_NOT_FOUND
} KkcKeyEventFormatError;
#define KKC_KEY_EVENT_FORMAT_ERROR kkc_key_event_format_error_quark ()
typedef enum  {
	KKC_RULE_PARSE_ERROR_FAILED
} KkcRuleParseError;
#define KKC_RULE_PARSE_ERROR kkc_rule_parse_error_quark ()
struct _KkcRomKanaMapFile {
	KkcMapFile parent_instance;
	KkcRomKanaMapFilePrivate * priv;
	KkcRomKanaNode* root_node;
};

struct _KkcRomKanaMapFileClass {
	KkcMapFileClass parent_class;
};

struct _KkcRomKanaEntry {
	gchar* rom;
	gchar* carryover;
	gchar* hiragana;
	gchar* katakana;
	gchar* hiragana_partial;
	gchar* katakana_partial;
};

struct _KkcMetadataFile {
	GObject parent_instance;
	KkcMetadataFilePrivate * priv;
};

struct _KkcMetadataFileClass {
	GObjectClass parent_class;
	gboolean (*parse) (KkcMetadataFile* self, JsonObject* object, GError** error);
};

struct _KkcRuleMetadata {
	KkcMetadataFile parent_instance;
	KkcRuleMetadataPrivate * priv;
};

struct _KkcRuleMetadataClass {
	KkcMetadataFileClass parent_class;
};

struct _KkcRuleMetadataPrivate {
	gchar* _filter;
	gint _priority;
};

typedef enum  {
	KKC_METADATA_FORMAT_ERROR_MISSING_FIELD,
	KKC_METADATA_FORMAT_ERROR_INVALID_FIELD
} KkcMetadataFormatError;
#define KKC_METADATA_FORMAT_ERROR kkc_metadata_format_error_quark ()
struct _KkcRule {
	GObject parent_instance;
	KkcRulePrivate * priv;
	KkcRomKanaMapFile* rom_kana;
};

struct _KkcRuleClass {
	GObjectClass parent_class;
};

struct _KkcRulePrivate {
	KkcRuleMetadata* _metadata;
	KkcKeyEventFilter* _filter;
	KkcKeymapMapFile** keymaps;
	gint keymaps_length1;
	gint _keymaps_size_;
};

typedef enum  {
	KKC_KANA_MODE_HIRAGANA,
	KKC_KANA_MODE_KATAKANA,
	KKC_KANA_MODE_HANKAKU_KATAKANA,
	KKC_KANA_MODE_LATIN,
	KKC_KANA_MODE_WIDE_LATIN
} KkcKanaMode;

typedef enum  {
	KKC_INPUT_MODE_HIRAGANA = KKC_KANA_MODE_HIRAGANA,
	KKC_INPUT_MODE_KATAKANA = KKC_KANA_MODE_KATAKANA,
	KKC_INPUT_MODE_HANKAKU_KATAKANA = KKC_KANA_MODE_HANKAKU_KATAKANA,
	KKC_INPUT_MODE_LATIN = KKC_KANA_MODE_LATIN,
	KKC_INPUT_MODE_WIDE_LATIN = KKC_KANA_MODE_WIDE_LATIN,
	KKC_INPUT_MODE_DIRECT
} KkcInputMode;


static gpointer kkc_keymap_map_file_parent_class = NULL;
static gpointer kkc_rom_kana_map_file_parent_class = NULL;
static gpointer kkc_rule_metadata_parent_class = NULL;
static GeeMap* kkc_rule_metadata_filter_types;
static GeeMap* kkc_rule_metadata_filter_types = NULL;
static GeeMap* kkc_rule_metadata_instance_cache;
static GeeMap* kkc_rule_metadata_instance_cache = NULL;
static gpointer kkc_rule_parent_class = NULL;
static GInitableIface* kkc_rule_g_initable_parent_iface = NULL;

GType kkc_map_file_get_type (void) G_GNUC_CONST;
GType kkc_keymap_map_file_get_type (void) G_GNUC_CONST;
GType kkc_keymap_get_type (void) G_GNUC_CONST;
enum  {
	KKC_KEYMAP_MAP_FILE_DUMMY_PROPERTY
};
static gchar* kkc_keymap_map_file_real_uniquify (KkcMapFile* base, const gchar* key);
GType kkc_key_event_get_type (void) G_GNUC_CONST;
GQuark kkc_key_event_format_error_quark (void);
KkcKeyEvent* kkc_key_event_new_from_string (const gchar* key, GError** error);
KkcKeyEvent* kkc_key_event_construct_from_string (GType object_type, const gchar* key, GError** error);
gchar* kkc_key_event_to_string (KkcKeyEvent* self);
static void kkc_keymap_map_file_load_keymap (KkcKeymapMapFile* self, KkcKeymap* keymap, GeeMap* map);
static void _vala_JsonNode_free (JsonNode* self);
void kkc_keymap_set (KkcKeymap* self, KkcKeyEvent* key, const gchar* command);
GType kkc_metadata_file_get_type (void) G_GNUC_CONST;
GType kkc_rule_metadata_get_type (void) G_GNUC_CONST;
GQuark kkc_rule_parse_error_quark (void);
KkcKeymapMapFile* kkc_keymap_map_file_new (KkcRuleMetadata* metadata, const gchar* mode, GError** error);
KkcKeymapMapFile* kkc_keymap_map_file_construct (GType object_type, KkcRuleMetadata* metadata, const gchar* mode, GError** error);
KkcMapFile* kkc_map_file_construct (GType object_type, KkcRuleMetadata* metadata, const gchar* type, const gchar* name, GError** error);
KkcKeymap* kkc_keymap_new (void);
KkcKeymap* kkc_keymap_construct (GType object_type);
GeeMap* kkc_map_file_get (KkcMapFile* self, const gchar* name);
void kkc_keymap_set_parent (KkcKeymap* self, KkcKeymap* value);
KkcKeymap* kkc_keymap_get_parent (KkcKeymap* self);
GeeMap* kkc_map_file_get_parent (KkcMapFile* self, const gchar* name);
static void kkc_keymap_map_file_finalize (GObject* obj);
GType kkc_rom_kana_map_file_get_type (void) G_GNUC_CONST;
GType kkc_rom_kana_node_get_type (void) G_GNUC_CONST;
enum  {
	KKC_ROM_KANA_MAP_FILE_DUMMY_PROPERTY
};
static void kkc_rom_kana_map_file_load_rom_kana (KkcRomKanaMapFile* self, KkcRomKanaNode* node, GeeMap* map, GError** error);
gchar* kkc_rom_kana_utils_get_katakana (const gchar* kana);
GType kkc_rom_kana_entry_get_type (void) G_GNUC_CONST;
KkcRomKanaEntry* kkc_rom_kana_entry_dup (const KkcRomKanaEntry* self);
void kkc_rom_kana_entry_free (KkcRomKanaEntry* self);
void kkc_rom_kana_entry_copy (const KkcRomKanaEntry* self, KkcRomKanaEntry* dest);
void kkc_rom_kana_entry_destroy (KkcRomKanaEntry* self);
void kkc_rom_kana_node_insert (KkcRomKanaNode* self, const gchar* key, KkcRomKanaEntry* entry);
KkcRomKanaMapFile* kkc_rom_kana_map_file_new (KkcRuleMetadata* metadata, GError** error);
KkcRomKanaMapFile* kkc_rom_kana_map_file_construct (GType object_type, KkcRuleMetadata* metadata, GError** error);
KkcRomKanaNode* kkc_rom_kana_node_new (KkcRomKanaEntry* entry);
KkcRomKanaNode* kkc_rom_kana_node_construct (GType object_type, KkcRomKanaEntry* entry);
static void kkc_rom_kana_map_file_finalize (GObject* obj);
#define KKC_RULE_METADATA_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), KKC_TYPE_RULE_METADATA, KkcRuleMetadataPrivate))
enum  {
	KKC_RULE_METADATA_DUMMY_PROPERTY,
	KKC_RULE_METADATA_FILTER,
	KKC_RULE_METADATA_PRIORITY
};
KkcRuleMetadata* kkc_rule_metadata_new (const gchar* name, const gchar* filename, GError** error);
KkcRuleMetadata* kkc_rule_metadata_construct (GType object_type, const gchar* name, const gchar* filename, GError** error);
KkcMetadataFile* kkc_metadata_file_construct (GType object_type, const gchar* name, const gchar* filename, GError** error);
static gboolean kkc_rule_metadata_real_parse (KkcMetadataFile* base, JsonObject* object, GError** error);
GQuark kkc_metadata_format_error_quark (void);
void kkc_rule_metadata_set_filter (KkcRuleMetadata* self, const gchar* value);
void kkc_rule_metadata_set_priority (KkcRuleMetadata* self, gint value);
GType kkc_key_event_filter_get_type (void) G_GNUC_CONST;
KkcKeyEventFilter* kkc_rule_metadata_create_key_event_filter (KkcRuleMetadata* self);
const gchar* kkc_rule_metadata_get_filter (KkcRuleMetadata* self);
gchar* kkc_rule_metadata_locate_map_file (KkcRuleMetadata* self, const gchar* type, const gchar* name);
const gchar* kkc_metadata_file_get_filename (KkcMetadataFile* self);
KkcRuleMetadata* kkc_rule_metadata_find (const gchar* name);
gchar** kkc_utils_build_data_path (const gchar* subdir, int* result_length1);
gint kkc_rule_metadata_get_priority (KkcRuleMetadata* self);
static GType* _g_type_dup (GType* self);
GType kkc_simple_key_event_filter_get_type (void) G_GNUC_CONST;
GType kkc_nicola_key_event_filter_get_type (void) G_GNUC_CONST;
GType kkc_kana_key_event_filter_get_type (void) G_GNUC_CONST;
static void kkc_rule_metadata_finalize (GObject* obj);
static void _vala_kkc_rule_metadata_get_property (GObject * object, guint property_id, GValue * value, GParamSpec * pspec);
static void _vala_kkc_rule_metadata_set_property (GObject * object, guint property_id, const GValue * value, GParamSpec * pspec);
GType kkc_rule_get_type (void) G_GNUC_CONST;
#define KKC_RULE_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), KKC_TYPE_RULE, KkcRulePrivate))
enum  {
	KKC_RULE_DUMMY_PROPERTY,
	KKC_RULE_METADATA,
	KKC_RULE_FILTER
};
KkcKeyEventFilter* kkc_rule_get_filter (KkcRule* self);
void kkc_key_event_filter_reset (KkcKeyEventFilter* self);
void kkc_rule_set_filter (KkcRule* self, KkcKeyEventFilter* value);
GType kkc_kana_mode_get_type (void) G_GNUC_CONST;
GType kkc_input_mode_get_type (void) G_GNUC_CONST;
KkcKeymap* kkc_rule_get_keymap (KkcRule* self, KkcInputMode mode);
KkcRule* kkc_rule_new (KkcRuleMetadata* metadata, GError** error);
KkcRule* kkc_rule_construct (GType object_type, KkcRuleMetadata* metadata, GError** error);
static gboolean kkc_rule_real_init (GInitable* base, GCancellable* cancellable, GError** error);
static GEnumValue* _g_enum_value_dup (GEnumValue* self);
KkcRuleMetadata* kkc_rule_get_metadata (KkcRule* self);
KkcRuleMetadata** kkc_rule_list (int* result_length1);
void kkc_metadata_file_set_name (KkcMetadataFile* self, const gchar* value);
static void _vala_array_add5 (KkcRuleMetadata*** array, int* length, int* size, KkcRuleMetadata* value);
void kkc_rule_set_metadata (KkcRule* self, KkcRuleMetadata* value);
static void kkc_rule_finalize (GObject* obj);
static void _vala_kkc_rule_get_property (GObject * object, guint property_id, GValue * value, GParamSpec * pspec);
static void _vala_kkc_rule_set_property (GObject * object, guint property_id, const GValue * value, GParamSpec * pspec);
static void _vala_array_destroy (gpointer array, gint array_length, GDestroyNotify destroy_func);
static void _vala_array_free (gpointer array, gint array_length, GDestroyNotify destroy_func);


static gchar* kkc_keymap_map_file_real_uniquify (KkcMapFile* base, const gchar* key) {
	KkcKeymapMapFile * self;
	gchar* result = NULL;
	GError * _inner_error_ = NULL;
	self = (KkcKeymapMapFile*) base;
	g_return_val_if_fail (key != NULL, NULL);
	{
		KkcKeyEvent* event = NULL;
		const gchar* _tmp0_ = NULL;
		KkcKeyEvent* _tmp1_ = NULL;
		gchar* _tmp2_ = NULL;
		_tmp0_ = key;
		_tmp1_ = kkc_key_event_new_from_string (_tmp0_, &_inner_error_);
		event = _tmp1_;
		if (G_UNLIKELY (_inner_error_ != NULL)) {
			if (_inner_error_->domain == KKC_KEY_EVENT_FORMAT_ERROR) {
				goto __catch5_kkc_key_event_format_error;
			}
			g_critical ("file %s: line %d: unexpected error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
		_tmp2_ = kkc_key_event_to_string (event);
		result = _tmp2_;
		_g_object_unref0 (event);
		return result;
	}
	goto __finally5;
	__catch5_kkc_key_event_format_error:
	{
		GError* e = NULL;
		const gchar* _tmp3_ = NULL;
		GError* _tmp4_ = NULL;
		const gchar* _tmp5_ = NULL;
		const gchar* _tmp6_ = NULL;
		gchar* _tmp7_ = NULL;
		e = _inner_error_;
		_inner_error_ = NULL;
		_tmp3_ = key;
		_tmp4_ = e;
		_tmp5_ = _tmp4_->message;
		g_warning ("rule.vala:30: can't get key event from string %s: %s", _tmp3_, _tmp5_);
		_tmp6_ = key;
		_tmp7_ = g_strdup (_tmp6_);
		result = _tmp7_;
		_g_error_free0 (e);
		return result;
	}
	__finally5:
	g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
	g_clear_error (&_inner_error_);
	return NULL;
}


static void _vala_JsonNode_free (JsonNode* self) {
	g_boxed_free (json_node_get_type (), self);
}


static void kkc_keymap_map_file_load_keymap (KkcKeymapMapFile* self, KkcKeymap* keymap, GeeMap* map) {
	GeeMapIterator* iter = NULL;
	GeeMap* _tmp0_ = NULL;
	GeeMapIterator* _tmp1_ = NULL;
	GError * _inner_error_ = NULL;
	g_return_if_fail (self != NULL);
	g_return_if_fail (keymap != NULL);
	g_return_if_fail (map != NULL);
	_tmp0_ = map;
	_tmp1_ = gee_map_map_iterator (_tmp0_);
	iter = _tmp1_;
	while (TRUE) {
		GeeMapIterator* _tmp2_ = NULL;
		gboolean _tmp3_ = FALSE;
		gchar* key = NULL;
		GeeMapIterator* _tmp4_ = NULL;
		gpointer _tmp5_ = NULL;
		JsonNode* value = NULL;
		GeeMapIterator* _tmp6_ = NULL;
		gpointer _tmp7_ = NULL;
		_tmp2_ = iter;
		_tmp3_ = gee_map_iterator_next (_tmp2_);
		if (!_tmp3_) {
			break;
		}
		_tmp4_ = iter;
		_tmp5_ = gee_map_iterator_get_key (_tmp4_);
		key = (gchar*) _tmp5_;
		_tmp6_ = iter;
		_tmp7_ = gee_map_iterator_get_value (_tmp6_);
		value = (JsonNode*) _tmp7_;
		{
			KkcKeyEvent* _tmp8_ = NULL;
			const gchar* _tmp9_ = NULL;
			KkcKeyEvent* _tmp10_ = NULL;
			KkcKeymap* _tmp11_ = NULL;
			JsonNode* _tmp12_ = NULL;
			const gchar* _tmp13_ = NULL;
			_tmp9_ = key;
			_tmp10_ = kkc_key_event_new_from_string (_tmp9_, &_inner_error_);
			_tmp8_ = _tmp10_;
			if (G_UNLIKELY (_inner_error_ != NULL)) {
				if (_inner_error_->domain == KKC_KEY_EVENT_FORMAT_ERROR) {
					goto __catch6_kkc_key_event_format_error;
				}
				__vala_JsonNode_free0 (value);
				_g_free0 (key);
				_g_object_unref0 (iter);
				g_critical ("file %s: line %d: unexpected error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
				g_clear_error (&_inner_error_);
				return;
			}
			_tmp11_ = keymap;
			_tmp12_ = value;
			_tmp13_ = json_node_get_string (_tmp12_);
			kkc_keymap_set (_tmp11_, _tmp8_, _tmp13_);
			_g_object_unref0 (_tmp8_);
		}
		goto __finally6;
		__catch6_kkc_key_event_format_error:
		{
			GError* e = NULL;
			const gchar* _tmp14_ = NULL;
			GError* _tmp15_ = NULL;
			const gchar* _tmp16_ = NULL;
			e = _inner_error_;
			_inner_error_ = NULL;
			_tmp14_ = key;
			_tmp15_ = e;
			_tmp16_ = _tmp15_->message;
			g_warning ("rule.vala:46: can't get key event from string %s: %s", _tmp14_, _tmp16_);
			_g_error_free0 (e);
		}
		__finally6:
		if (G_UNLIKELY (_inner_error_ != NULL)) {
			__vala_JsonNode_free0 (value);
			_g_free0 (key);
			_g_object_unref0 (iter);
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return;
		}
		__vala_JsonNode_free0 (value);
		_g_free0 (key);
	}
	_g_object_unref0 (iter);
}


KkcKeymapMapFile* kkc_keymap_map_file_construct (GType object_type, KkcRuleMetadata* metadata, const gchar* mode, GError** error) {
	KkcKeymapMapFile * self = NULL;
	KkcRuleMetadata* _tmp0_ = NULL;
	const gchar* _tmp1_ = NULL;
	KkcKeymap* _tmp2_ = NULL;
	KkcKeymap* _tmp3_ = NULL;
	GeeMap* _tmp4_ = NULL;
	GeeMap* _tmp5_ = NULL;
	KkcKeymap* _tmp6_ = NULL;
	KkcKeymap* _tmp7_ = NULL;
	KkcKeymap* _tmp8_ = NULL;
	KkcKeymap* _tmp9_ = NULL;
	KkcKeymap* _tmp10_ = NULL;
	KkcKeymap* _tmp11_ = NULL;
	GeeMap* _tmp12_ = NULL;
	GeeMap* _tmp13_ = NULL;
	GError * _inner_error_ = NULL;
	g_return_val_if_fail (metadata != NULL, NULL);
	g_return_val_if_fail (mode != NULL, NULL);
	_tmp0_ = metadata;
	_tmp1_ = mode;
	self = (KkcKeymapMapFile*) kkc_map_file_construct (object_type, _tmp0_, "keymap", _tmp1_, &_inner_error_);
	if (G_UNLIKELY (_inner_error_ != NULL)) {
		if (_inner_error_->domain == KKC_RULE_PARSE_ERROR) {
			g_propagate_error (error, _inner_error_);
			_g_object_unref0 (self);
			return NULL;
		} else {
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	_tmp2_ = kkc_keymap_new ();
	_g_object_unref0 (self->keymap);
	self->keymap = _tmp2_;
	_tmp3_ = self->keymap;
	_tmp4_ = kkc_map_file_get ((KkcMapFile*) self, "keymap");
	_tmp5_ = _tmp4_;
	kkc_keymap_map_file_load_keymap (self, _tmp3_, _tmp5_);
	_g_object_unref0 (_tmp5_);
	_tmp6_ = self->keymap;
	_tmp7_ = kkc_keymap_new ();
	_tmp8_ = _tmp7_;
	kkc_keymap_set_parent (_tmp6_, _tmp8_);
	_g_object_unref0 (_tmp8_);
	_tmp9_ = self->keymap;
	_tmp10_ = kkc_keymap_get_parent (_tmp9_);
	_tmp11_ = _tmp10_;
	_tmp12_ = kkc_map_file_get_parent ((KkcMapFile*) self, "keymap");
	_tmp13_ = _tmp12_;
	kkc_keymap_map_file_load_keymap (self, _tmp11_, _tmp13_);
	_g_object_unref0 (_tmp13_);
	return self;
}


KkcKeymapMapFile* kkc_keymap_map_file_new (KkcRuleMetadata* metadata, const gchar* mode, GError** error) {
	return kkc_keymap_map_file_construct (KKC_TYPE_KEYMAP_MAP_FILE, metadata, mode, error);
}


static void kkc_keymap_map_file_class_init (KkcKeymapMapFileClass * klass) {
	kkc_keymap_map_file_parent_class = g_type_class_peek_parent (klass);
	((KkcMapFileClass *) klass)->uniquify = kkc_keymap_map_file_real_uniquify;
	G_OBJECT_CLASS (klass)->finalize = kkc_keymap_map_file_finalize;
}


static void kkc_keymap_map_file_instance_init (KkcKeymapMapFile * self) {
}


static void kkc_keymap_map_file_finalize (GObject* obj) {
	KkcKeymapMapFile * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (obj, KKC_TYPE_KEYMAP_MAP_FILE, KkcKeymapMapFile);
	_g_object_unref0 (self->keymap);
	_g_object_unref0 (self->parent_keymap);
	G_OBJECT_CLASS (kkc_keymap_map_file_parent_class)->finalize (obj);
}


GType kkc_keymap_map_file_get_type (void) {
	static volatile gsize kkc_keymap_map_file_type_id__volatile = 0;
	if (g_once_init_enter (&kkc_keymap_map_file_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (KkcKeymapMapFileClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) kkc_keymap_map_file_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (KkcKeymapMapFile), 0, (GInstanceInitFunc) kkc_keymap_map_file_instance_init, NULL };
		GType kkc_keymap_map_file_type_id;
		kkc_keymap_map_file_type_id = g_type_register_static (KKC_TYPE_MAP_FILE, "KkcKeymapMapFile", &g_define_type_info, 0);
		g_once_init_leave (&kkc_keymap_map_file_type_id__volatile, kkc_keymap_map_file_type_id);
	}
	return kkc_keymap_map_file_type_id__volatile;
}


static gpointer _json_array_ref0 (gpointer self) {
	return self ? json_array_ref (self) : NULL;
}


static void kkc_rom_kana_map_file_load_rom_kana (KkcRomKanaMapFile* self, KkcRomKanaNode* node, GeeMap* map, GError** error) {
	GError * _inner_error_ = NULL;
	g_return_if_fail (self != NULL);
	g_return_if_fail (node != NULL);
	g_return_if_fail (map != NULL);
	{
		GeeIterator* _key_it = NULL;
		GeeMap* _tmp0_ = NULL;
		GeeSet* _tmp1_ = NULL;
		GeeSet* _tmp2_ = NULL;
		GeeSet* _tmp3_ = NULL;
		GeeIterator* _tmp4_ = NULL;
		GeeIterator* _tmp5_ = NULL;
		_tmp0_ = map;
		_tmp1_ = gee_map_get_keys (_tmp0_);
		_tmp2_ = _tmp1_;
		_tmp3_ = _tmp2_;
		_tmp4_ = gee_iterable_iterator ((GeeIterable*) _tmp3_);
		_tmp5_ = _tmp4_;
		_g_object_unref0 (_tmp3_);
		_key_it = _tmp5_;
		while (TRUE) {
			GeeIterator* _tmp6_ = NULL;
			gboolean _tmp7_ = FALSE;
			gchar* key = NULL;
			GeeIterator* _tmp8_ = NULL;
			gpointer _tmp9_ = NULL;
			JsonNode* value = NULL;
			GeeMap* _tmp10_ = NULL;
			const gchar* _tmp11_ = NULL;
			gpointer _tmp12_ = NULL;
			JsonNode* _tmp13_ = NULL;
			JsonNodeType _tmp14_ = 0;
			_tmp6_ = _key_it;
			_tmp7_ = gee_iterator_next (_tmp6_);
			if (!_tmp7_) {
				break;
			}
			_tmp8_ = _key_it;
			_tmp9_ = gee_iterator_get (_tmp8_);
			key = (gchar*) _tmp9_;
			_tmp10_ = map;
			_tmp11_ = key;
			_tmp12_ = gee_map_get (_tmp10_, _tmp11_);
			value = (JsonNode*) _tmp12_;
			_tmp13_ = value;
			_tmp14_ = json_node_get_node_type (_tmp13_);
			if (_tmp14_ == JSON_NODE_ARRAY) {
				JsonArray* components = NULL;
				JsonNode* _tmp15_ = NULL;
				JsonArray* _tmp16_ = NULL;
				JsonArray* _tmp17_ = NULL;
				guint length = 0U;
				JsonArray* _tmp18_ = NULL;
				guint _tmp19_ = 0U;
				gboolean _tmp20_ = FALSE;
				guint _tmp21_ = 0U;
				_tmp15_ = value;
				_tmp16_ = json_node_get_array (_tmp15_);
				_tmp17_ = _json_array_ref0 (_tmp16_);
				components = _tmp17_;
				_tmp18_ = components;
				_tmp19_ = json_array_get_length (_tmp18_);
				length = _tmp19_;
				_tmp21_ = length;
				if (((guint) 2) <= _tmp21_) {
					guint _tmp22_ = 0U;
					_tmp22_ = length;
					_tmp20_ = _tmp22_ <= ((guint) 5);
				} else {
					_tmp20_ = FALSE;
				}
				if (_tmp20_) {
					gchar* carryover = NULL;
					JsonArray* _tmp23_ = NULL;
					const gchar* _tmp24_ = NULL;
					gchar* _tmp25_ = NULL;
					gchar* hiragana = NULL;
					JsonArray* _tmp26_ = NULL;
					const gchar* _tmp27_ = NULL;
					gchar* _tmp28_ = NULL;
					gchar* _tmp29_ = NULL;
					guint _tmp30_ = 0U;
					gchar* katakana = NULL;
					gchar* _tmp36_ = NULL;
					const gchar* _tmp37_ = NULL;
					guint _tmp38_ = 0U;
					gchar* hiragana_partial = NULL;
					gchar* _tmp41_ = NULL;
					const gchar* _tmp42_ = NULL;
					guint _tmp43_ = 0U;
					gchar* katakana_partial = NULL;
					gchar* _tmp46_ = NULL;
					KkcRomKanaEntry entry = {0};
					const gchar* _tmp47_ = NULL;
					gchar* _tmp48_ = NULL;
					const gchar* _tmp49_ = NULL;
					gchar* _tmp50_ = NULL;
					const gchar* _tmp51_ = NULL;
					gchar* _tmp52_ = NULL;
					const gchar* _tmp53_ = NULL;
					gchar* _tmp54_ = NULL;
					const gchar* _tmp55_ = NULL;
					gchar* _tmp56_ = NULL;
					const gchar* _tmp57_ = NULL;
					gchar* _tmp58_ = NULL;
					KkcRomKanaEntry _tmp59_ = {0};
					KkcRomKanaNode* _tmp60_ = NULL;
					const gchar* _tmp61_ = NULL;
					KkcRomKanaEntry _tmp62_ = {0};
					_tmp23_ = components;
					_tmp24_ = json_array_get_string_element (_tmp23_, (guint) 0);
					_tmp25_ = g_strdup (_tmp24_);
					carryover = _tmp25_;
					_tmp26_ = components;
					_tmp27_ = json_array_get_string_element (_tmp26_, (guint) 1);
					_tmp28_ = g_strdup (_tmp27_);
					hiragana = _tmp28_;
					_tmp30_ = length;
					if (_tmp30_ >= ((guint) 3)) {
						JsonArray* _tmp31_ = NULL;
						const gchar* _tmp32_ = NULL;
						gchar* _tmp33_ = NULL;
						_tmp31_ = components;
						_tmp32_ = json_array_get_string_element (_tmp31_, (guint) 2);
						_tmp33_ = g_strdup (_tmp32_);
						_g_free0 (_tmp29_);
						_tmp29_ = _tmp33_;
					} else {
						const gchar* _tmp34_ = NULL;
						gchar* _tmp35_ = NULL;
						_tmp34_ = hiragana;
						_tmp35_ = kkc_rom_kana_utils_get_katakana (_tmp34_);
						_g_free0 (_tmp29_);
						_tmp29_ = _tmp35_;
					}
					_tmp36_ = g_strdup (_tmp29_);
					katakana = _tmp36_;
					_tmp38_ = length;
					if (_tmp38_ >= ((guint) 4)) {
						JsonArray* _tmp39_ = NULL;
						const gchar* _tmp40_ = NULL;
						_tmp39_ = components;
						_tmp40_ = json_array_get_string_element (_tmp39_, (guint) 3);
						_tmp37_ = _tmp40_;
					} else {
						_tmp37_ = "";
					}
					_tmp41_ = g_strdup (_tmp37_);
					hiragana_partial = _tmp41_;
					_tmp43_ = length;
					if (_tmp43_ >= ((guint) 5)) {
						JsonArray* _tmp44_ = NULL;
						const gchar* _tmp45_ = NULL;
						_tmp44_ = components;
						_tmp45_ = json_array_get_string_element (_tmp44_, (guint) 4);
						_tmp42_ = _tmp45_;
					} else {
						_tmp42_ = "";
					}
					_tmp46_ = g_strdup (_tmp42_);
					katakana_partial = _tmp46_;
					_tmp47_ = key;
					_tmp48_ = g_strdup (_tmp47_);
					_tmp49_ = carryover;
					_tmp50_ = g_strdup (_tmp49_);
					_tmp51_ = hiragana;
					_tmp52_ = g_strdup (_tmp51_);
					_tmp53_ = katakana;
					_tmp54_ = g_strdup (_tmp53_);
					_tmp55_ = hiragana_partial;
					_tmp56_ = g_strdup (_tmp55_);
					_tmp57_ = katakana_partial;
					_tmp58_ = g_strdup (_tmp57_);
					_g_free0 (_tmp59_.rom);
					_tmp59_.rom = _tmp48_;
					_g_free0 (_tmp59_.carryover);
					_tmp59_.carryover = _tmp50_;
					_g_free0 (_tmp59_.hiragana);
					_tmp59_.hiragana = _tmp52_;
					_g_free0 (_tmp59_.katakana);
					_tmp59_.katakana = _tmp54_;
					_g_free0 (_tmp59_.hiragana_partial);
					_tmp59_.hiragana_partial = _tmp56_;
					_g_free0 (_tmp59_.katakana_partial);
					_tmp59_.katakana_partial = _tmp58_;
					entry = _tmp59_;
					_tmp60_ = node;
					_tmp61_ = key;
					_tmp62_ = entry;
					kkc_rom_kana_node_insert (_tmp60_, _tmp61_, &_tmp62_);
					kkc_rom_kana_entry_destroy (&entry);
					_g_free0 (katakana_partial);
					_g_free0 (hiragana_partial);
					_g_free0 (katakana);
					_g_free0 (_tmp29_);
					_g_free0 (hiragana);
					_g_free0 (carryover);
				} else {
					GError* _tmp63_ = NULL;
					_tmp63_ = g_error_new_literal (KKC_RULE_PARSE_ERROR, KKC_RULE_PARSE_ERROR_FAILED, "\"rom-kana\" must have two to four elements");
					_inner_error_ = _tmp63_;
					if (_inner_error_->domain == KKC_RULE_PARSE_ERROR) {
						g_propagate_error (error, _inner_error_);
						_json_array_unref0 (components);
						__vala_JsonNode_free0 (value);
						_g_free0 (key);
						_g_object_unref0 (_key_it);
						return;
					} else {
						_json_array_unref0 (components);
						__vala_JsonNode_free0 (value);
						_g_free0 (key);
						_g_object_unref0 (_key_it);
						g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
						g_clear_error (&_inner_error_);
						return;
					}
				}
				_json_array_unref0 (components);
			} else {
				GError* _tmp64_ = NULL;
				_tmp64_ = g_error_new_literal (KKC_RULE_PARSE_ERROR, KKC_RULE_PARSE_ERROR_FAILED, "\"rom-kana\" member must be either an array or null");
				_inner_error_ = _tmp64_;
				if (_inner_error_->domain == KKC_RULE_PARSE_ERROR) {
					g_propagate_error (error, _inner_error_);
					__vala_JsonNode_free0 (value);
					_g_free0 (key);
					_g_object_unref0 (_key_it);
					return;
				} else {
					__vala_JsonNode_free0 (value);
					_g_free0 (key);
					_g_object_unref0 (_key_it);
					g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
					g_clear_error (&_inner_error_);
					return;
				}
			}
			__vala_JsonNode_free0 (value);
			_g_free0 (key);
		}
		_g_object_unref0 (_key_it);
	}
}


KkcRomKanaMapFile* kkc_rom_kana_map_file_construct (GType object_type, KkcRuleMetadata* metadata, GError** error) {
	KkcRomKanaMapFile * self = NULL;
	KkcRuleMetadata* _tmp0_ = NULL;
	KkcRomKanaNode* _tmp1_ = NULL;
	GeeMap* parent_map = NULL;
	GeeMap* _tmp2_ = NULL;
	GeeMap* map = NULL;
	GeeMap* _tmp3_ = NULL;
	GeeMapIterator* iter = NULL;
	GeeMap* _tmp4_ = NULL;
	GeeMapIterator* _tmp5_ = NULL;
	KkcRomKanaNode* _tmp19_ = NULL;
	GeeMap* _tmp20_ = NULL;
	GError * _inner_error_ = NULL;
	g_return_val_if_fail (metadata != NULL, NULL);
	_tmp0_ = metadata;
	self = (KkcRomKanaMapFile*) kkc_map_file_construct (object_type, _tmp0_, "rom-kana", "default", &_inner_error_);
	if (G_UNLIKELY (_inner_error_ != NULL)) {
		if (_inner_error_->domain == KKC_RULE_PARSE_ERROR) {
			g_propagate_error (error, _inner_error_);
			_g_object_unref0 (self);
			return NULL;
		} else {
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	_tmp1_ = kkc_rom_kana_node_new (NULL);
	_g_object_unref0 (self->root_node);
	self->root_node = _tmp1_;
	_tmp2_ = kkc_map_file_get_parent ((KkcMapFile*) self, "rom-kana");
	parent_map = _tmp2_;
	_tmp3_ = kkc_map_file_get ((KkcMapFile*) self, "rom-kana");
	map = _tmp3_;
	_tmp4_ = map;
	_tmp5_ = gee_map_map_iterator (_tmp4_);
	iter = _tmp5_;
	while (TRUE) {
		GeeMapIterator* _tmp6_ = NULL;
		gboolean _tmp7_ = FALSE;
		gchar* key = NULL;
		GeeMapIterator* _tmp8_ = NULL;
		gpointer _tmp9_ = NULL;
		JsonNode* value = NULL;
		GeeMapIterator* _tmp10_ = NULL;
		gpointer _tmp11_ = NULL;
		JsonNode* _tmp12_ = NULL;
		JsonNodeType _tmp13_ = 0;
		_tmp6_ = iter;
		_tmp7_ = gee_map_iterator_next (_tmp6_);
		if (!_tmp7_) {
			break;
		}
		_tmp8_ = iter;
		_tmp9_ = gee_map_iterator_get_key (_tmp8_);
		key = (gchar*) _tmp9_;
		_tmp10_ = iter;
		_tmp11_ = gee_map_iterator_get_value (_tmp10_);
		value = (JsonNode*) _tmp11_;
		_tmp12_ = value;
		_tmp13_ = json_node_get_node_type (_tmp12_);
		if (_tmp13_ == JSON_NODE_NULL) {
			GeeMap* _tmp14_ = NULL;
			const gchar* _tmp15_ = NULL;
			_tmp14_ = parent_map;
			_tmp15_ = key;
			gee_map_unset (_tmp14_, _tmp15_, NULL);
		} else {
			GeeMap* _tmp16_ = NULL;
			const gchar* _tmp17_ = NULL;
			JsonNode* _tmp18_ = NULL;
			_tmp16_ = parent_map;
			_tmp17_ = key;
			_tmp18_ = value;
			gee_map_set (_tmp16_, _tmp17_, _tmp18_);
		}
		__vala_JsonNode_free0 (value);
		_g_free0 (key);
	}
	_tmp19_ = self->root_node;
	_tmp20_ = parent_map;
	kkc_rom_kana_map_file_load_rom_kana (self, _tmp19_, _tmp20_, &_inner_error_);
	if (G_UNLIKELY (_inner_error_ != NULL)) {
		if (_inner_error_->domain == KKC_RULE_PARSE_ERROR) {
			g_propagate_error (error, _inner_error_);
			_g_object_unref0 (iter);
			_g_object_unref0 (map);
			_g_object_unref0 (parent_map);
			_g_object_unref0 (self);
			return NULL;
		} else {
			_g_object_unref0 (iter);
			_g_object_unref0 (map);
			_g_object_unref0 (parent_map);
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	_g_object_unref0 (iter);
	_g_object_unref0 (map);
	_g_object_unref0 (parent_map);
	return self;
}


KkcRomKanaMapFile* kkc_rom_kana_map_file_new (KkcRuleMetadata* metadata, GError** error) {
	return kkc_rom_kana_map_file_construct (KKC_TYPE_ROM_KANA_MAP_FILE, metadata, error);
}


static void kkc_rom_kana_map_file_class_init (KkcRomKanaMapFileClass * klass) {
	kkc_rom_kana_map_file_parent_class = g_type_class_peek_parent (klass);
	G_OBJECT_CLASS (klass)->finalize = kkc_rom_kana_map_file_finalize;
}


static void kkc_rom_kana_map_file_instance_init (KkcRomKanaMapFile * self) {
}


static void kkc_rom_kana_map_file_finalize (GObject* obj) {
	KkcRomKanaMapFile * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (obj, KKC_TYPE_ROM_KANA_MAP_FILE, KkcRomKanaMapFile);
	_g_object_unref0 (self->root_node);
	G_OBJECT_CLASS (kkc_rom_kana_map_file_parent_class)->finalize (obj);
}


GType kkc_rom_kana_map_file_get_type (void) {
	static volatile gsize kkc_rom_kana_map_file_type_id__volatile = 0;
	if (g_once_init_enter (&kkc_rom_kana_map_file_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (KkcRomKanaMapFileClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) kkc_rom_kana_map_file_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (KkcRomKanaMapFile), 0, (GInstanceInitFunc) kkc_rom_kana_map_file_instance_init, NULL };
		GType kkc_rom_kana_map_file_type_id;
		kkc_rom_kana_map_file_type_id = g_type_register_static (KKC_TYPE_MAP_FILE, "KkcRomKanaMapFile", &g_define_type_info, 0);
		g_once_init_leave (&kkc_rom_kana_map_file_type_id__volatile, kkc_rom_kana_map_file_type_id);
	}
	return kkc_rom_kana_map_file_type_id__volatile;
}


GQuark kkc_rule_parse_error_quark (void) {
	return g_quark_from_static_string ("kkc_rule_parse_error-quark");
}


KkcRuleMetadata* kkc_rule_metadata_construct (GType object_type, const gchar* name, const gchar* filename, GError** error) {
	KkcRuleMetadata * self = NULL;
	const gchar* _tmp0_ = NULL;
	const gchar* _tmp1_ = NULL;
	GError * _inner_error_ = NULL;
	g_return_val_if_fail (name != NULL, NULL);
	g_return_val_if_fail (filename != NULL, NULL);
	_tmp0_ = name;
	_tmp1_ = filename;
	self = (KkcRuleMetadata*) kkc_metadata_file_construct (object_type, _tmp0_, _tmp1_, &_inner_error_);
	if (G_UNLIKELY (_inner_error_ != NULL)) {
		g_propagate_error (error, _inner_error_);
		_g_object_unref0 (self);
		return NULL;
	}
	return self;
}


KkcRuleMetadata* kkc_rule_metadata_new (const gchar* name, const gchar* filename, GError** error) {
	return kkc_rule_metadata_construct (KKC_TYPE_RULE_METADATA, name, filename, error);
}


static gboolean kkc_rule_metadata_real_parse (KkcMetadataFile* base, JsonObject* object, GError** error) {
	KkcRuleMetadata * self;
	gboolean result = FALSE;
	gchar* filter = NULL;
	gchar* _tmp0_ = NULL;
	JsonObject* _tmp1_ = NULL;
	gboolean _tmp2_ = FALSE;
	const gchar* _tmp11_ = NULL;
	JsonObject* _tmp12_ = NULL;
	gboolean _tmp13_ = FALSE;
	GError * _inner_error_ = NULL;
	self = (KkcRuleMetadata*) base;
	g_return_val_if_fail (object != NULL, FALSE);
	_tmp0_ = g_strdup ("simple");
	filter = _tmp0_;
	_tmp1_ = object;
	_tmp2_ = json_object_has_member (_tmp1_, "filter");
	if (_tmp2_) {
		JsonObject* _tmp3_ = NULL;
		const gchar* _tmp4_ = NULL;
		gchar* _tmp5_ = NULL;
		GeeMap* _tmp6_ = NULL;
		const gchar* _tmp7_ = NULL;
		gboolean _tmp8_ = FALSE;
		_tmp3_ = object;
		_tmp4_ = json_object_get_string_member (_tmp3_, "filter");
		_tmp5_ = g_strdup (_tmp4_);
		_g_free0 (filter);
		filter = _tmp5_;
		_tmp6_ = kkc_rule_metadata_filter_types;
		_tmp7_ = filter;
		_tmp8_ = gee_map_has_key (_tmp6_, _tmp7_);
		if (!_tmp8_) {
			const gchar* _tmp9_ = NULL;
			GError* _tmp10_ = NULL;
			_tmp9_ = filter;
			_tmp10_ = g_error_new (KKC_METADATA_FORMAT_ERROR, KKC_METADATA_FORMAT_ERROR_INVALID_FIELD, "unknown filter type %s", _tmp9_);
			_inner_error_ = _tmp10_;
			g_propagate_error (error, _inner_error_);
			_g_free0 (filter);
			return FALSE;
		}
	}
	_tmp11_ = filter;
	kkc_rule_metadata_set_filter (self, _tmp11_);
	_tmp12_ = object;
	_tmp13_ = json_object_has_member (_tmp12_, "priority");
	if (_tmp13_) {
		JsonObject* _tmp14_ = NULL;
		gint64 _tmp15_ = 0LL;
		_tmp14_ = object;
		_tmp15_ = json_object_get_int_member (_tmp14_, "priority");
		kkc_rule_metadata_set_priority (self, (gint) _tmp15_);
	}
	result = TRUE;
	_g_free0 (filter);
	return result;
}


KkcKeyEventFilter* kkc_rule_metadata_create_key_event_filter (KkcRuleMetadata* self) {
	KkcKeyEventFilter* result = NULL;
	GType* type = NULL;
	GeeMap* _tmp0_ = NULL;
	const gchar* _tmp1_ = NULL;
	gpointer _tmp2_ = NULL;
	GObject* _tmp3_ = NULL;
	GObject* _tmp4_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = kkc_rule_metadata_filter_types;
	_tmp1_ = self->priv->_filter;
	_tmp2_ = gee_map_get (_tmp0_, _tmp1_);
	type = (GType*) _tmp2_;
	_tmp3_ = g_object_new (*type, NULL);
	_tmp4_ = G_IS_INITIALLY_UNOWNED (_tmp3_) ? g_object_ref_sink (_tmp3_) : _tmp3_;
	result = G_TYPE_CHECK_INSTANCE_CAST (_tmp4_, KKC_TYPE_KEY_EVENT_FILTER, KkcKeyEventFilter);
	_g_free0 (type);
	return result;
}


/**
         * Return the path of the map file.
         *
         * @param type type of the map file
         * @param name name of the map file
         *
         * @return the absolute path of the map file
         */
gchar* kkc_rule_metadata_locate_map_file (KkcRuleMetadata* self, const gchar* type, const gchar* name) {
	gchar* result = NULL;
	gchar* map_filename = NULL;
	const gchar* _tmp0_ = NULL;
	const gchar* _tmp1_ = NULL;
	gchar* _tmp2_ = NULL;
	gchar* _tmp3_ = NULL;
	const gchar* _tmp4_ = NULL;
	const gchar* _tmp5_ = NULL;
	gchar* _tmp6_ = NULL;
	gchar* _tmp7_ = NULL;
	gchar* _tmp8_ = NULL;
	gchar* _tmp9_ = NULL;
	const gchar* _tmp10_ = NULL;
	gboolean _tmp11_ = FALSE;
	g_return_val_if_fail (self != NULL, NULL);
	g_return_val_if_fail (type != NULL, NULL);
	g_return_val_if_fail (name != NULL, NULL);
	_tmp0_ = kkc_metadata_file_get_filename ((KkcMetadataFile*) self);
	_tmp1_ = _tmp0_;
	_tmp2_ = g_path_get_dirname (_tmp1_);
	_tmp3_ = _tmp2_;
	_tmp4_ = type;
	_tmp5_ = name;
	_tmp6_ = g_strconcat (_tmp5_, ".json", NULL);
	_tmp7_ = _tmp6_;
	_tmp8_ = g_build_filename (_tmp3_, _tmp4_, _tmp7_, NULL);
	_tmp9_ = _tmp8_;
	_g_free0 (_tmp7_);
	_g_free0 (_tmp3_);
	map_filename = _tmp9_;
	_tmp10_ = map_filename;
	_tmp11_ = g_file_test (_tmp10_, G_FILE_TEST_EXISTS);
	if (_tmp11_) {
		result = map_filename;
		return result;
	}
	result = NULL;
	_g_free0 (map_filename);
	return result;
}


/**
         * Locate a rule metadata by name.
         *
         * @param name name of the rule
         *
         * @return a RuleMetadata or `null`
         */
KkcRuleMetadata* kkc_rule_metadata_find (const gchar* name) {
	KkcRuleMetadata* result = NULL;
	GeeMap* _tmp0_ = NULL;
	const gchar* _tmp1_ = NULL;
	gboolean _tmp2_ = FALSE;
	gchar** dirs = NULL;
	gint _tmp6_ = 0;
	gchar** _tmp7_ = NULL;
	gint dirs_length1 = 0;
	gint _dirs_size_ = 0;
	gchar** _tmp8_ = NULL;
	gint _tmp8__length1 = 0;
	GError * _inner_error_ = NULL;
	g_return_val_if_fail (name != NULL, NULL);
	_tmp0_ = kkc_rule_metadata_instance_cache;
	_tmp1_ = name;
	_tmp2_ = gee_map_has_key (_tmp0_, _tmp1_);
	if (_tmp2_) {
		GeeMap* _tmp3_ = NULL;
		const gchar* _tmp4_ = NULL;
		gpointer _tmp5_ = NULL;
		_tmp3_ = kkc_rule_metadata_instance_cache;
		_tmp4_ = name;
		_tmp5_ = gee_map_get (_tmp3_, _tmp4_);
		result = (KkcRuleMetadata*) _tmp5_;
		return result;
	}
	_tmp7_ = kkc_utils_build_data_path ("rules", &_tmp6_);
	dirs = _tmp7_;
	dirs_length1 = _tmp6_;
	_dirs_size_ = dirs_length1;
	_tmp8_ = dirs;
	_tmp8__length1 = dirs_length1;
	{
		gchar** dir_collection = NULL;
		gint dir_collection_length1 = 0;
		gint _dir_collection_size_ = 0;
		gint dir_it = 0;
		dir_collection = _tmp8_;
		dir_collection_length1 = _tmp8__length1;
		for (dir_it = 0; dir_it < _tmp8__length1; dir_it = dir_it + 1) {
			gchar* _tmp9_ = NULL;
			gchar* dir = NULL;
			_tmp9_ = g_strdup (dir_collection[dir_it]);
			dir = _tmp9_;
			{
				gchar* base_dir_filename = NULL;
				const gchar* _tmp10_ = NULL;
				const gchar* _tmp11_ = NULL;
				gchar* _tmp12_ = NULL;
				gchar* metadata_filename = NULL;
				const gchar* _tmp13_ = NULL;
				gchar* _tmp14_ = NULL;
				const gchar* _tmp15_ = NULL;
				gboolean _tmp16_ = FALSE;
				_tmp10_ = dir;
				_tmp11_ = name;
				_tmp12_ = g_build_filename (_tmp10_, _tmp11_, NULL);
				base_dir_filename = _tmp12_;
				_tmp13_ = base_dir_filename;
				_tmp14_ = g_build_filename (_tmp13_, "metadata.json", NULL);
				metadata_filename = _tmp14_;
				_tmp15_ = metadata_filename;
				_tmp16_ = g_file_test (_tmp15_, G_FILE_TEST_EXISTS);
				if (_tmp16_) {
					{
						KkcRuleMetadata* metadata = NULL;
						const gchar* _tmp17_ = NULL;
						const gchar* _tmp18_ = NULL;
						KkcRuleMetadata* _tmp19_ = NULL;
						GeeMap* _tmp20_ = NULL;
						const gchar* _tmp21_ = NULL;
						KkcRuleMetadata* _tmp22_ = NULL;
						_tmp17_ = name;
						_tmp18_ = metadata_filename;
						_tmp19_ = kkc_rule_metadata_new (_tmp17_, _tmp18_, &_inner_error_);
						metadata = _tmp19_;
						if (G_UNLIKELY (_inner_error_ != NULL)) {
							goto __catch7_g_error;
						}
						_tmp20_ = kkc_rule_metadata_instance_cache;
						_tmp21_ = name;
						_tmp22_ = metadata;
						gee_map_set (_tmp20_, _tmp21_, _tmp22_);
						result = metadata;
						_g_free0 (metadata_filename);
						_g_free0 (base_dir_filename);
						_g_free0 (dir);
						dirs = (_vala_array_free (dirs, dirs_length1, (GDestroyNotify) g_free), NULL);
						return result;
					}
					goto __finally7;
					__catch7_g_error:
					{
						GError* e = NULL;
						e = _inner_error_;
						_inner_error_ = NULL;
						_g_error_free0 (e);
						_g_free0 (metadata_filename);
						_g_free0 (base_dir_filename);
						_g_free0 (dir);
						continue;
					}
					__finally7:
					_g_free0 (metadata_filename);
					_g_free0 (base_dir_filename);
					_g_free0 (dir);
					dirs = (_vala_array_free (dirs, dirs_length1, (GDestroyNotify) g_free), NULL);
					g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
					g_clear_error (&_inner_error_);
					return NULL;
				}
				_g_free0 (metadata_filename);
				_g_free0 (base_dir_filename);
				_g_free0 (dir);
			}
		}
	}
	result = NULL;
	dirs = (_vala_array_free (dirs, dirs_length1, (GDestroyNotify) g_free), NULL);
	return result;
}


const gchar* kkc_rule_metadata_get_filter (KkcRuleMetadata* self) {
	const gchar* result;
	const gchar* _tmp0_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = self->priv->_filter;
	result = _tmp0_;
	return result;
}


void kkc_rule_metadata_set_filter (KkcRuleMetadata* self, const gchar* value) {
	const gchar* _tmp0_ = NULL;
	gchar* _tmp1_ = NULL;
	g_return_if_fail (self != NULL);
	_tmp0_ = value;
	_tmp1_ = g_strdup (_tmp0_);
	_g_free0 (self->priv->_filter);
	self->priv->_filter = _tmp1_;
	g_object_notify ((GObject *) self, "filter");
}


gint kkc_rule_metadata_get_priority (KkcRuleMetadata* self) {
	gint result;
	gint _tmp0_ = 0;
	g_return_val_if_fail (self != NULL, 0);
	_tmp0_ = self->priv->_priority;
	result = _tmp0_;
	return result;
}


void kkc_rule_metadata_set_priority (KkcRuleMetadata* self, gint value) {
	gint _tmp0_ = 0;
	g_return_if_fail (self != NULL);
	_tmp0_ = value;
	self->priv->_priority = _tmp0_;
	g_object_notify ((GObject *) self, "priority");
}


static GType* _g_type_dup (GType* self) {
	GType* dup;
	dup = g_new0 (GType, 1);
	memcpy (dup, self, sizeof (GType));
	return dup;
}


static void kkc_rule_metadata_class_init (KkcRuleMetadataClass * klass) {
	GeeHashMap* _tmp0_ = NULL;
	GeeHashMap* _tmp1_ = NULL;
	GeeMap* _tmp2_ = NULL;
	GType _tmp3_ = 0UL;
	GeeMap* _tmp4_ = NULL;
	GType _tmp5_ = 0UL;
	GeeMap* _tmp6_ = NULL;
	GType _tmp7_ = 0UL;
	kkc_rule_metadata_parent_class = g_type_class_peek_parent (klass);
	g_type_class_add_private (klass, sizeof (KkcRuleMetadataPrivate));
	((KkcMetadataFileClass *) klass)->parse = kkc_rule_metadata_real_parse;
	G_OBJECT_CLASS (klass)->get_property = _vala_kkc_rule_metadata_get_property;
	G_OBJECT_CLASS (klass)->set_property = _vala_kkc_rule_metadata_set_property;
	G_OBJECT_CLASS (klass)->finalize = kkc_rule_metadata_finalize;
	/**
	         * Name of key event filter.
	         */
	g_object_class_install_property (G_OBJECT_CLASS (klass), KKC_RULE_METADATA_FILTER, g_param_spec_string ("filter", "filter", "filter", NULL, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE | G_PARAM_WRITABLE | G_PARAM_CONSTRUCT));
	/**
	         * Priority of the rule.
	         */
	g_object_class_install_property (G_OBJECT_CLASS (klass), KKC_RULE_METADATA_PRIORITY, g_param_spec_int ("priority", "priority", "priority", G_MININT, G_MAXINT, 0, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE | G_PARAM_WRITABLE | G_PARAM_CONSTRUCT));
	_tmp0_ = gee_hash_map_new (G_TYPE_STRING, (GBoxedCopyFunc) g_strdup, g_free, G_TYPE_GTYPE, (GBoxedCopyFunc) _g_type_dup, g_free, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL);
	_g_object_unref0 (kkc_rule_metadata_filter_types);
	kkc_rule_metadata_filter_types = (GeeMap*) _tmp0_;
	_tmp1_ = gee_hash_map_new (G_TYPE_STRING, (GBoxedCopyFunc) g_strdup, g_free, KKC_TYPE_RULE_METADATA, (GBoxedCopyFunc) g_object_ref, g_object_unref, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL);
	_g_object_unref0 (kkc_rule_metadata_instance_cache);
	kkc_rule_metadata_instance_cache = (GeeMap*) _tmp1_;
	_tmp2_ = kkc_rule_metadata_filter_types;
	_tmp3_ = KKC_TYPE_SIMPLE_KEY_EVENT_FILTER;
	gee_map_set (_tmp2_, "simple", &_tmp3_);
	_tmp4_ = kkc_rule_metadata_filter_types;
	_tmp5_ = KKC_TYPE_NICOLA_KEY_EVENT_FILTER;
	gee_map_set (_tmp4_, "nicola", &_tmp5_);
	_tmp6_ = kkc_rule_metadata_filter_types;
	_tmp7_ = KKC_TYPE_KANA_KEY_EVENT_FILTER;
	gee_map_set (_tmp6_, "kana", &_tmp7_);
}


static void kkc_rule_metadata_instance_init (KkcRuleMetadata * self) {
	self->priv = KKC_RULE_METADATA_GET_PRIVATE (self);
	self->priv->_priority = 0;
}


static void kkc_rule_metadata_finalize (GObject* obj) {
	KkcRuleMetadata * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (obj, KKC_TYPE_RULE_METADATA, KkcRuleMetadata);
	_g_free0 (self->priv->_filter);
	G_OBJECT_CLASS (kkc_rule_metadata_parent_class)->finalize (obj);
}


/**
     * Object describing a rule.
     */
GType kkc_rule_metadata_get_type (void) {
	static volatile gsize kkc_rule_metadata_type_id__volatile = 0;
	if (g_once_init_enter (&kkc_rule_metadata_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (KkcRuleMetadataClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) kkc_rule_metadata_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (KkcRuleMetadata), 0, (GInstanceInitFunc) kkc_rule_metadata_instance_init, NULL };
		GType kkc_rule_metadata_type_id;
		kkc_rule_metadata_type_id = g_type_register_static (KKC_TYPE_METADATA_FILE, "KkcRuleMetadata", &g_define_type_info, 0);
		g_once_init_leave (&kkc_rule_metadata_type_id__volatile, kkc_rule_metadata_type_id);
	}
	return kkc_rule_metadata_type_id__volatile;
}


static void _vala_kkc_rule_metadata_get_property (GObject * object, guint property_id, GValue * value, GParamSpec * pspec) {
	KkcRuleMetadata * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (object, KKC_TYPE_RULE_METADATA, KkcRuleMetadata);
	switch (property_id) {
		case KKC_RULE_METADATA_FILTER:
		g_value_set_string (value, kkc_rule_metadata_get_filter (self));
		break;
		case KKC_RULE_METADATA_PRIORITY:
		g_value_set_int (value, kkc_rule_metadata_get_priority (self));
		break;
		default:
		G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
		break;
	}
}


static void _vala_kkc_rule_metadata_set_property (GObject * object, guint property_id, const GValue * value, GParamSpec * pspec) {
	KkcRuleMetadata * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (object, KKC_TYPE_RULE_METADATA, KkcRuleMetadata);
	switch (property_id) {
		case KKC_RULE_METADATA_FILTER:
		kkc_rule_metadata_set_filter (self, g_value_get_string (value));
		break;
		case KKC_RULE_METADATA_PRIORITY:
		kkc_rule_metadata_set_priority (self, g_value_get_int (value));
		break;
		default:
		G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
		break;
	}
}


static gpointer _g_object_ref0 (gpointer self) {
	return self ? g_object_ref (self) : NULL;
}


KkcKeymap* kkc_rule_get_keymap (KkcRule* self, KkcInputMode mode) {
	KkcKeymap* result = NULL;
	KkcKeymapMapFile** _tmp0_ = NULL;
	gint _tmp0__length1 = 0;
	KkcInputMode _tmp1_ = 0;
	KkcKeymapMapFile* _tmp2_ = NULL;
	KkcKeymap* _tmp3_ = NULL;
	KkcKeymap* _tmp4_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = self->priv->keymaps;
	_tmp0__length1 = self->priv->keymaps_length1;
	_tmp1_ = mode;
	_tmp2_ = _tmp0_[_tmp1_];
	_tmp3_ = _tmp2_->keymap;
	_tmp4_ = _g_object_ref0 (_tmp3_);
	result = _tmp4_;
	return result;
}


/**
         * Create a rule.
         *
         * @param metadata metadata of the rule
         *
         * @return a new Rule
         */
KkcRule* kkc_rule_construct (GType object_type, KkcRuleMetadata* metadata, GError** error) {
	KkcRule * self = NULL;
	KkcRuleMetadata* _tmp0_ = NULL;
	GError * _inner_error_ = NULL;
	g_return_val_if_fail (metadata != NULL, NULL);
	_tmp0_ = metadata;
	self = (KkcRule*) g_object_new (object_type, "metadata", _tmp0_, NULL);
	g_initable_init ((GInitable*) self, NULL, &_inner_error_);
	if (G_UNLIKELY (_inner_error_ != NULL)) {
		g_propagate_error (error, _inner_error_);
		_g_object_unref0 (self);
		return NULL;
	}
	return self;
}


KkcRule* kkc_rule_new (KkcRuleMetadata* metadata, GError** error) {
	return kkc_rule_construct (KKC_TYPE_RULE, metadata, error);
}


static GEnumValue* _g_enum_value_dup (GEnumValue* self) {
	GEnumValue* dup;
	dup = g_new0 (GEnumValue, 1);
	memcpy (dup, self, sizeof (GEnumValue));
	return dup;
}


static gpointer __g_enum_value_dup0 (gpointer self) {
	return self ? _g_enum_value_dup (self) : NULL;
}


static gboolean kkc_rule_real_init (GInitable* base, GCancellable* cancellable, GError** error) {
	KkcRule * self;
	gboolean result = FALSE;
	KkcRuleMetadata* default_metadata = NULL;
	KkcRuleMetadata* _tmp0_ = NULL;
	GEnumClass* enum_class = NULL;
	GTypeClass* _tmp1_ = NULL;
	GEnumClass* _tmp2_ = NULL;
	gint _tmp3_ = 0;
	KkcKeymapMapFile** _tmp4_ = NULL;
	KkcRuleMetadata* _metadata = NULL;
	KkcRuleMetadata* _tmp37_ = NULL;
	KkcRuleMetadata* _tmp38_ = NULL;
	KkcRuleMetadata* _tmp39_ = NULL;
	gchar* _tmp40_ = NULL;
	gchar* _tmp41_ = NULL;
	gboolean _tmp42_ = FALSE;
	KkcRomKanaMapFile* _tmp45_ = NULL;
	KkcRuleMetadata* _tmp46_ = NULL;
	KkcRomKanaMapFile* _tmp47_ = NULL;
	KkcRomKanaMapFile* _tmp48_ = NULL;
	KkcRuleMetadata* _tmp49_ = NULL;
	KkcKeyEventFilter* _tmp50_ = NULL;
	KkcKeyEventFilter* _tmp51_ = NULL;
	GError * _inner_error_ = NULL;
	self = (KkcRule*) base;
	_tmp0_ = kkc_rule_metadata_find ("default");
	default_metadata = _tmp0_;
	_tmp1_ = g_type_class_ref (KKC_TYPE_INPUT_MODE);
	enum_class = (GEnumClass*) _tmp1_;
	_tmp2_ = enum_class;
	_tmp3_ = _tmp2_->maximum;
	_tmp4_ = g_new0 (KkcKeymapMapFile*, (_tmp3_ + 1) + 1);
	self->priv->keymaps = (_vala_array_free (self->priv->keymaps, self->priv->keymaps_length1, (GDestroyNotify) g_object_unref), NULL);
	self->priv->keymaps = _tmp4_;
	self->priv->keymaps_length1 = _tmp3_ + 1;
	self->priv->_keymaps_size_ = self->priv->keymaps_length1;
	{
		gint i = 0;
		GEnumClass* _tmp5_ = NULL;
		gint _tmp6_ = 0;
		_tmp5_ = enum_class;
		_tmp6_ = _tmp5_->minimum;
		i = _tmp6_;
		{
			gboolean _tmp7_ = FALSE;
			_tmp7_ = TRUE;
			while (TRUE) {
				gint _tmp9_ = 0;
				GEnumClass* _tmp10_ = NULL;
				gint _tmp11_ = 0;
				GEnumValue* enum_value = NULL;
				GEnumClass* _tmp12_ = NULL;
				gint _tmp13_ = 0;
				GEnumValue* _tmp14_ = NULL;
				GEnumValue* _tmp15_ = NULL;
				GEnumValue* _tmp16_ = NULL;
				if (!_tmp7_) {
					gint _tmp8_ = 0;
					_tmp8_ = i;
					i = _tmp8_ + 1;
				}
				_tmp7_ = FALSE;
				_tmp9_ = i;
				_tmp10_ = enum_class;
				_tmp11_ = _tmp10_->maximum;
				if (!(_tmp9_ <= _tmp11_)) {
					break;
				}
				_tmp12_ = enum_class;
				_tmp13_ = i;
				_tmp14_ = g_enum_get_value (_tmp12_, _tmp13_);
				_tmp15_ = __g_enum_value_dup0 (_tmp14_);
				enum_value = _tmp15_;
				_tmp16_ = enum_value;
				if (_tmp16_ != NULL) {
					KkcRuleMetadata* _metadata = NULL;
					KkcRuleMetadata* _tmp17_ = NULL;
					KkcRuleMetadata* _tmp18_ = NULL;
					KkcRuleMetadata* _tmp19_ = NULL;
					GEnumValue* _tmp20_ = NULL;
					const gchar* _tmp21_ = NULL;
					gchar* _tmp22_ = NULL;
					gchar* _tmp23_ = NULL;
					gboolean _tmp24_ = FALSE;
					KkcKeymapMapFile* _tmp27_ = NULL;
					KkcRuleMetadata* _tmp28_ = NULL;
					GEnumValue* _tmp29_ = NULL;
					const gchar* _tmp30_ = NULL;
					KkcKeymapMapFile* _tmp31_ = NULL;
					KkcKeymapMapFile** _tmp32_ = NULL;
					gint _tmp32__length1 = 0;
					GEnumValue* _tmp33_ = NULL;
					gint _tmp34_ = 0;
					KkcKeymapMapFile* _tmp35_ = NULL;
					KkcKeymapMapFile* _tmp36_ = NULL;
					_tmp17_ = self->priv->_metadata;
					_tmp18_ = _g_object_ref0 (_tmp17_);
					_metadata = _tmp18_;
					_tmp19_ = _metadata;
					_tmp20_ = enum_value;
					_tmp21_ = (*_tmp20_).value_nick;
					_tmp22_ = kkc_rule_metadata_locate_map_file (_tmp19_, "keymap", _tmp21_);
					_tmp23_ = _tmp22_;
					_tmp24_ = _tmp23_ == NULL;
					_g_free0 (_tmp23_);
					if (_tmp24_) {
						KkcRuleMetadata* _tmp25_ = NULL;
						KkcRuleMetadata* _tmp26_ = NULL;
						_tmp25_ = default_metadata;
						_tmp26_ = _g_object_ref0 (_tmp25_);
						_g_object_unref0 (_metadata);
						_metadata = _tmp26_;
					}
					_tmp28_ = _metadata;
					_tmp29_ = enum_value;
					_tmp30_ = (*_tmp29_).value_nick;
					_tmp31_ = kkc_keymap_map_file_new (_tmp28_, _tmp30_, &_inner_error_);
					_tmp27_ = _tmp31_;
					if (G_UNLIKELY (_inner_error_ != NULL)) {
						g_propagate_error (error, _inner_error_);
						_g_object_unref0 (_metadata);
						_g_free0 (enum_value);
						_g_type_class_unref0 (enum_class);
						_g_object_unref0 (default_metadata);
						return FALSE;
					}
					_tmp32_ = self->priv->keymaps;
					_tmp32__length1 = self->priv->keymaps_length1;
					_tmp33_ = enum_value;
					_tmp34_ = (*_tmp33_).value;
					_tmp35_ = _tmp27_;
					_tmp27_ = NULL;
					_g_object_unref0 (_tmp32_[_tmp34_]);
					_tmp32_[_tmp34_] = _tmp35_;
					_tmp36_ = _tmp32_[_tmp34_];
					_g_object_unref0 (_tmp27_);
					_g_object_unref0 (_metadata);
				}
				_g_free0 (enum_value);
			}
		}
	}
	_tmp37_ = self->priv->_metadata;
	_tmp38_ = _g_object_ref0 (_tmp37_);
	_metadata = _tmp38_;
	_tmp39_ = _metadata;
	_tmp40_ = kkc_rule_metadata_locate_map_file (_tmp39_, "rom-kana", "default");
	_tmp41_ = _tmp40_;
	_tmp42_ = _tmp41_ == NULL;
	_g_free0 (_tmp41_);
	if (_tmp42_) {
		KkcRuleMetadata* _tmp43_ = NULL;
		KkcRuleMetadata* _tmp44_ = NULL;
		_tmp43_ = default_metadata;
		_tmp44_ = _g_object_ref0 (_tmp43_);
		_g_object_unref0 (_metadata);
		_metadata = _tmp44_;
	}
	_tmp46_ = _metadata;
	_tmp47_ = kkc_rom_kana_map_file_new (_tmp46_, &_inner_error_);
	_tmp45_ = _tmp47_;
	if (G_UNLIKELY (_inner_error_ != NULL)) {
		g_propagate_error (error, _inner_error_);
		_g_object_unref0 (_metadata);
		_g_type_class_unref0 (enum_class);
		_g_object_unref0 (default_metadata);
		return FALSE;
	}
	_tmp48_ = _tmp45_;
	_tmp45_ = NULL;
	_g_object_unref0 (self->rom_kana);
	self->rom_kana = _tmp48_;
	_tmp49_ = _metadata;
	_tmp50_ = kkc_rule_metadata_create_key_event_filter (_tmp49_);
	_tmp51_ = _tmp50_;
	kkc_rule_set_filter (self, _tmp51_);
	_g_object_unref0 (_tmp51_);
	result = TRUE;
	_g_object_unref0 (_tmp45_);
	_g_object_unref0 (_metadata);
	_g_type_class_unref0 (enum_class);
	_g_object_unref0 (default_metadata);
	return result;
}


/**
         * List rules.
         *
         * @return an array of RuleMetadata
         */
static void _vala_array_add5 (KkcRuleMetadata*** array, int* length, int* size, KkcRuleMetadata* value) {
	if ((*length) == (*size)) {
		*size = (*size) ? (2 * (*size)) : 4;
		*array = g_renew (KkcRuleMetadata*, *array, (*size) + 1);
	}
	(*array)[(*length)++] = value;
	(*array)[*length] = NULL;
}


KkcRuleMetadata** kkc_rule_list (int* result_length1) {
	KkcRuleMetadata** result = NULL;
	GeeSet* names = NULL;
	GeeHashSet* _tmp0_ = NULL;
	KkcRuleMetadata** rules = NULL;
	KkcRuleMetadata** _tmp1_ = NULL;
	gint rules_length1 = 0;
	gint _rules_size_ = 0;
	gchar** dirs = NULL;
	gint _tmp2_ = 0;
	gchar** _tmp3_ = NULL;
	gint dirs_length1 = 0;
	gint _dirs_size_ = 0;
	gchar** _tmp4_ = NULL;
	gint _tmp4__length1 = 0;
	KkcRuleMetadata** _tmp35_ = NULL;
	gint _tmp35__length1 = 0;
	GError * _inner_error_ = NULL;
	_tmp0_ = gee_hash_set_new (G_TYPE_STRING, (GBoxedCopyFunc) g_strdup, g_free, NULL, NULL, NULL, NULL, NULL, NULL);
	names = (GeeSet*) _tmp0_;
	_tmp1_ = g_new0 (KkcRuleMetadata*, 0 + 1);
	rules = _tmp1_;
	rules_length1 = 0;
	_rules_size_ = rules_length1;
	_tmp3_ = kkc_utils_build_data_path ("rules", &_tmp2_);
	dirs = _tmp3_;
	dirs_length1 = _tmp2_;
	_dirs_size_ = dirs_length1;
	_tmp4_ = dirs;
	_tmp4__length1 = dirs_length1;
	{
		gchar** dir_collection = NULL;
		gint dir_collection_length1 = 0;
		gint _dir_collection_size_ = 0;
		gint dir_it = 0;
		dir_collection = _tmp4_;
		dir_collection_length1 = _tmp4__length1;
		for (dir_it = 0; dir_it < _tmp4__length1; dir_it = dir_it + 1) {
			gchar* _tmp5_ = NULL;
			gchar* dir = NULL;
			_tmp5_ = g_strdup (dir_collection[dir_it]);
			dir = _tmp5_;
			{
				GDir* handle = NULL;
				gchar* name = NULL;
				{
					GDir* _tmp6_ = NULL;
					const gchar* _tmp7_ = NULL;
					GDir* _tmp8_ = NULL;
					GDir* _tmp9_ = NULL;
					_tmp7_ = dir;
					_tmp8_ = g_dir_open (_tmp7_, (guint) 0, &_inner_error_);
					_tmp6_ = _tmp8_;
					if (G_UNLIKELY (_inner_error_ != NULL)) {
						goto __catch8_g_error;
					}
					_tmp9_ = _tmp6_;
					_tmp6_ = NULL;
					_g_dir_close0 (handle);
					handle = _tmp9_;
					_g_dir_close0 (_tmp6_);
				}
				goto __finally8;
				__catch8_g_error:
				{
					GError* e = NULL;
					e = _inner_error_;
					_inner_error_ = NULL;
					_g_error_free0 (e);
					_g_dir_close0 (handle);
					_g_free0 (dir);
					continue;
				}
				__finally8:
				if (G_UNLIKELY (_inner_error_ != NULL)) {
					_g_dir_close0 (handle);
					_g_free0 (dir);
					dirs = (_vala_array_free (dirs, dirs_length1, (GDestroyNotify) g_free), NULL);
					rules = (_vala_array_free (rules, rules_length1, (GDestroyNotify) g_object_unref), NULL);
					_g_object_unref0 (names);
					g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
					g_clear_error (&_inner_error_);
					return NULL;
				}
				while (TRUE) {
					GDir* _tmp10_ = NULL;
					const gchar* _tmp11_ = NULL;
					gchar* _tmp12_ = NULL;
					const gchar* _tmp13_ = NULL;
					GeeSet* _tmp14_ = NULL;
					const gchar* _tmp15_ = NULL;
					gboolean _tmp16_ = FALSE;
					gchar* metadata_filename = NULL;
					const gchar* _tmp17_ = NULL;
					const gchar* _tmp18_ = NULL;
					gchar* _tmp19_ = NULL;
					const gchar* _tmp20_ = NULL;
					gboolean _tmp21_ = FALSE;
					_tmp10_ = handle;
					_tmp11_ = g_dir_read_name (_tmp10_);
					_tmp12_ = g_strdup (_tmp11_);
					_g_free0 (name);
					name = _tmp12_;
					_tmp13_ = name;
					if (!(_tmp13_ != NULL)) {
						break;
					}
					_tmp14_ = names;
					_tmp15_ = name;
					_tmp16_ = gee_collection_contains ((GeeCollection*) _tmp14_, _tmp15_);
					if (_tmp16_) {
						continue;
					}
					_tmp17_ = dir;
					_tmp18_ = name;
					_tmp19_ = g_build_filename (_tmp17_, _tmp18_, "metadata.json", NULL);
					metadata_filename = _tmp19_;
					_tmp20_ = metadata_filename;
					_tmp21_ = g_file_test (_tmp20_, G_FILE_TEST_EXISTS);
					if (_tmp21_) {
						{
							KkcRuleMetadata* metadata = NULL;
							const gchar* _tmp22_ = NULL;
							const gchar* _tmp23_ = NULL;
							KkcRuleMetadata* _tmp24_ = NULL;
							GeeSet* _tmp25_ = NULL;
							const gchar* _tmp26_ = NULL;
							KkcRuleMetadata* _tmp27_ = NULL;
							const gchar* _tmp28_ = NULL;
							KkcRuleMetadata** _tmp29_ = NULL;
							gint _tmp29__length1 = 0;
							KkcRuleMetadata* _tmp30_ = NULL;
							KkcRuleMetadata* _tmp31_ = NULL;
							_tmp22_ = name;
							_tmp23_ = metadata_filename;
							_tmp24_ = kkc_rule_metadata_new (_tmp22_, _tmp23_, &_inner_error_);
							metadata = _tmp24_;
							if (G_UNLIKELY (_inner_error_ != NULL)) {
								goto __catch9_g_error;
							}
							_tmp25_ = names;
							_tmp26_ = name;
							gee_collection_add ((GeeCollection*) _tmp25_, _tmp26_);
							_tmp27_ = metadata;
							_tmp28_ = name;
							kkc_metadata_file_set_name ((KkcMetadataFile*) _tmp27_, _tmp28_);
							_tmp29_ = rules;
							_tmp29__length1 = rules_length1;
							_tmp30_ = metadata;
							_tmp31_ = _g_object_ref0 (_tmp30_);
							_vala_array_add5 (&rules, &rules_length1, &_rules_size_, _tmp31_);
							_g_object_unref0 (metadata);
						}
						goto __finally9;
						__catch9_g_error:
						{
							GError* e = NULL;
							const gchar* _tmp32_ = NULL;
							GError* _tmp33_ = NULL;
							const gchar* _tmp34_ = NULL;
							e = _inner_error_;
							_inner_error_ = NULL;
							_tmp32_ = metadata_filename;
							_tmp33_ = e;
							_tmp34_ = _tmp33_->message;
							g_warning ("rule.vala:333: can't load metadata %s: %s", _tmp32_, _tmp34_);
							_g_error_free0 (e);
						}
						__finally9:
						if (G_UNLIKELY (_inner_error_ != NULL)) {
							_g_free0 (metadata_filename);
							_g_free0 (name);
							_g_dir_close0 (handle);
							_g_free0 (dir);
							dirs = (_vala_array_free (dirs, dirs_length1, (GDestroyNotify) g_free), NULL);
							rules = (_vala_array_free (rules, rules_length1, (GDestroyNotify) g_object_unref), NULL);
							_g_object_unref0 (names);
							g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
							g_clear_error (&_inner_error_);
							return NULL;
						}
					}
					_g_free0 (metadata_filename);
				}
				_g_free0 (name);
				_g_dir_close0 (handle);
				_g_free0 (dir);
			}
		}
	}
	_tmp35_ = rules;
	_tmp35__length1 = rules_length1;
	if (result_length1) {
		*result_length1 = _tmp35__length1;
	}
	result = _tmp35_;
	dirs = (_vala_array_free (dirs, dirs_length1, (GDestroyNotify) g_free), NULL);
	_g_object_unref0 (names);
	return result;
}


KkcRuleMetadata* kkc_rule_get_metadata (KkcRule* self) {
	KkcRuleMetadata* result;
	KkcRuleMetadata* _tmp0_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = self->priv->_metadata;
	result = _tmp0_;
	return result;
}


void kkc_rule_set_metadata (KkcRule* self, KkcRuleMetadata* value) {
	KkcRuleMetadata* _tmp0_ = NULL;
	KkcRuleMetadata* _tmp1_ = NULL;
	g_return_if_fail (self != NULL);
	_tmp0_ = value;
	_tmp1_ = _g_object_ref0 (_tmp0_);
	_g_object_unref0 (self->priv->_metadata);
	self->priv->_metadata = _tmp1_;
	g_object_notify ((GObject *) self, "metadata");
}


KkcKeyEventFilter* kkc_rule_get_filter (KkcRule* self) {
	KkcKeyEventFilter* result;
	KkcKeyEventFilter* _tmp0_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = self->priv->_filter;
	result = _tmp0_;
	return result;
}


void kkc_rule_set_filter (KkcRule* self, KkcKeyEventFilter* value) {
	KkcKeyEventFilter* _tmp0_ = NULL;
	KkcKeyEventFilter* _tmp1_ = NULL;
	g_return_if_fail (self != NULL);
	_tmp0_ = value;
	_tmp1_ = _g_object_ref0 (_tmp0_);
	_g_object_unref0 (self->priv->_filter);
	self->priv->_filter = _tmp1_;
	g_object_notify ((GObject *) self, "filter");
}


static void kkc_rule_class_init (KkcRuleClass * klass) {
	kkc_rule_parent_class = g_type_class_peek_parent (klass);
	g_type_class_add_private (klass, sizeof (KkcRulePrivate));
	G_OBJECT_CLASS (klass)->get_property = _vala_kkc_rule_get_property;
	G_OBJECT_CLASS (klass)->set_property = _vala_kkc_rule_set_property;
	G_OBJECT_CLASS (klass)->finalize = kkc_rule_finalize;
	/**
	         * Metadata associated with the rule.
	         */
	g_object_class_install_property (G_OBJECT_CLASS (klass), KKC_RULE_METADATA, g_param_spec_object ("metadata", "metadata", "metadata", KKC_TYPE_RULE_METADATA, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE | G_PARAM_WRITABLE | G_PARAM_CONSTRUCT));
	g_object_class_install_property (G_OBJECT_CLASS (klass), KKC_RULE_FILTER, g_param_spec_object ("filter", "filter", "filter", KKC_TYPE_KEY_EVENT_FILTER, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE | G_PARAM_WRITABLE | G_PARAM_CONSTRUCT));
}


static void kkc_rule_g_initable_interface_init (GInitableIface * iface) {
	kkc_rule_g_initable_parent_iface = g_type_interface_peek_parent (iface);
	iface->init = (gboolean (*)(GInitable*, GCancellable*, GError**)) kkc_rule_real_init;
}


static void kkc_rule_instance_init (KkcRule * self) {
	self->priv = KKC_RULE_GET_PRIVATE (self);
}


static void kkc_rule_finalize (GObject* obj) {
	KkcRule * self;
	KkcKeyEventFilter* _tmp0_ = NULL;
	self = G_TYPE_CHECK_INSTANCE_CAST (obj, KKC_TYPE_RULE, KkcRule);
	_tmp0_ = self->priv->_filter;
	if (_tmp0_ != NULL) {
		KkcKeyEventFilter* _tmp1_ = NULL;
		_tmp1_ = self->priv->_filter;
		kkc_key_event_filter_reset (_tmp1_);
		kkc_rule_set_filter (self, NULL);
	}
	_g_object_unref0 (self->priv->_metadata);
	_g_object_unref0 (self->priv->_filter);
	self->priv->keymaps = (_vala_array_free (self->priv->keymaps, self->priv->keymaps_length1, (GDestroyNotify) g_object_unref), NULL);
	_g_object_unref0 (self->rom_kana);
	G_OBJECT_CLASS (kkc_rule_parent_class)->finalize (obj);
}


/**
     * Object representing a typing rule.
     */
GType kkc_rule_get_type (void) {
	static volatile gsize kkc_rule_type_id__volatile = 0;
	if (g_once_init_enter (&kkc_rule_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (KkcRuleClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) kkc_rule_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (KkcRule), 0, (GInstanceInitFunc) kkc_rule_instance_init, NULL };
		static const GInterfaceInfo g_initable_info = { (GInterfaceInitFunc) kkc_rule_g_initable_interface_init, (GInterfaceFinalizeFunc) NULL, NULL};
		GType kkc_rule_type_id;
		kkc_rule_type_id = g_type_register_static (G_TYPE_OBJECT, "KkcRule", &g_define_type_info, 0);
		g_type_add_interface_static (kkc_rule_type_id, G_TYPE_INITABLE, &g_initable_info);
		g_once_init_leave (&kkc_rule_type_id__volatile, kkc_rule_type_id);
	}
	return kkc_rule_type_id__volatile;
}


static void _vala_kkc_rule_get_property (GObject * object, guint property_id, GValue * value, GParamSpec * pspec) {
	KkcRule * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (object, KKC_TYPE_RULE, KkcRule);
	switch (property_id) {
		case KKC_RULE_METADATA:
		g_value_set_object (value, kkc_rule_get_metadata (self));
		break;
		case KKC_RULE_FILTER:
		g_value_set_object (value, kkc_rule_get_filter (self));
		break;
		default:
		G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
		break;
	}
}


static void _vala_kkc_rule_set_property (GObject * object, guint property_id, const GValue * value, GParamSpec * pspec) {
	KkcRule * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (object, KKC_TYPE_RULE, KkcRule);
	switch (property_id) {
		case KKC_RULE_METADATA:
		kkc_rule_set_metadata (self, g_value_get_object (value));
		break;
		case KKC_RULE_FILTER:
		kkc_rule_set_filter (self, g_value_get_object (value));
		break;
		default:
		G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
		break;
	}
}


static void _vala_array_destroy (gpointer array, gint array_length, GDestroyNotify destroy_func) {
	if ((array != NULL) && (destroy_func != NULL)) {
		int i;
		for (i = 0; i < array_length; i = i + 1) {
			if (((gpointer*) array)[i] != NULL) {
				destroy_func (((gpointer*) array)[i]);
			}
		}
	}
}


static void _vala_array_free (gpointer array, gint array_length, GDestroyNotify destroy_func) {
	_vala_array_destroy (array, array_length, destroy_func);
	g_free (array);
}



