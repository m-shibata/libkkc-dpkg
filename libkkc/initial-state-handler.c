/* initial-state-handler.c generated by valac 0.24.0.131-42e78, the Vala compiler
 * generated from initial-state-handler.vala, do not modify */

/*
 * Copyright (C) 2011-2014 Daiki Ueno <ueno@gnu.org>
 * Copyright (C) 2011-2014 Red Hat, Inc.
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */

#include <glib.h>
#include <glib-object.h>
#include <stdlib.h>
#include <string.h>
#include <gee.h>


#define KKC_TYPE_STATE_HANDLER (kkc_state_handler_get_type ())
#define KKC_STATE_HANDLER(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), KKC_TYPE_STATE_HANDLER, KkcStateHandler))
#define KKC_STATE_HANDLER_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), KKC_TYPE_STATE_HANDLER, KkcStateHandlerClass))
#define KKC_IS_STATE_HANDLER(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), KKC_TYPE_STATE_HANDLER))
#define KKC_IS_STATE_HANDLER_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), KKC_TYPE_STATE_HANDLER))
#define KKC_STATE_HANDLER_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), KKC_TYPE_STATE_HANDLER, KkcStateHandlerClass))

typedef struct _KkcStateHandler KkcStateHandler;
typedef struct _KkcStateHandlerClass KkcStateHandlerClass;
typedef struct _KkcStateHandlerPrivate KkcStateHandlerPrivate;

#define KKC_TYPE_STATE (kkc_state_get_type ())
#define KKC_STATE(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), KKC_TYPE_STATE, KkcState))
#define KKC_STATE_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), KKC_TYPE_STATE, KkcStateClass))
#define KKC_IS_STATE(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), KKC_TYPE_STATE))
#define KKC_IS_STATE_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), KKC_TYPE_STATE))
#define KKC_STATE_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), KKC_TYPE_STATE, KkcStateClass))

typedef struct _KkcState KkcState;
typedef struct _KkcStateClass KkcStateClass;

#define KKC_TYPE_KEY_EVENT (kkc_key_event_get_type ())
#define KKC_KEY_EVENT(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), KKC_TYPE_KEY_EVENT, KkcKeyEvent))
#define KKC_KEY_EVENT_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), KKC_TYPE_KEY_EVENT, KkcKeyEventClass))
#define KKC_IS_KEY_EVENT(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), KKC_TYPE_KEY_EVENT))
#define KKC_IS_KEY_EVENT_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), KKC_TYPE_KEY_EVENT))
#define KKC_KEY_EVENT_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), KKC_TYPE_KEY_EVENT, KkcKeyEventClass))

typedef struct _KkcKeyEvent KkcKeyEvent;
typedef struct _KkcKeyEventClass KkcKeyEventClass;

#define KKC_TYPE_INITIAL_STATE_HANDLER (kkc_initial_state_handler_get_type ())
#define KKC_INITIAL_STATE_HANDLER(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), KKC_TYPE_INITIAL_STATE_HANDLER, KkcInitialStateHandler))
#define KKC_INITIAL_STATE_HANDLER_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), KKC_TYPE_INITIAL_STATE_HANDLER, KkcInitialStateHandlerClass))
#define KKC_IS_INITIAL_STATE_HANDLER(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), KKC_TYPE_INITIAL_STATE_HANDLER))
#define KKC_IS_INITIAL_STATE_HANDLER_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), KKC_TYPE_INITIAL_STATE_HANDLER))
#define KKC_INITIAL_STATE_HANDLER_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), KKC_TYPE_INITIAL_STATE_HANDLER, KkcInitialStateHandlerClass))

typedef struct _KkcInitialStateHandler KkcInitialStateHandler;
typedef struct _KkcInitialStateHandlerClass KkcInitialStateHandlerClass;
typedef struct _KkcInitialStateHandlerPrivate KkcInitialStateHandlerPrivate;
typedef struct _KkcStatePrivate KkcStatePrivate;

#define KKC_TYPE_LANGUAGE_MODEL (kkc_language_model_get_type ())
#define KKC_LANGUAGE_MODEL(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), KKC_TYPE_LANGUAGE_MODEL, KkcLanguageModel))
#define KKC_LANGUAGE_MODEL_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), KKC_TYPE_LANGUAGE_MODEL, KkcLanguageModelClass))
#define KKC_IS_LANGUAGE_MODEL(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), KKC_TYPE_LANGUAGE_MODEL))
#define KKC_IS_LANGUAGE_MODEL_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), KKC_TYPE_LANGUAGE_MODEL))
#define KKC_LANGUAGE_MODEL_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), KKC_TYPE_LANGUAGE_MODEL, KkcLanguageModelClass))

typedef struct _KkcLanguageModel KkcLanguageModel;
typedef struct _KkcLanguageModelClass KkcLanguageModelClass;

#define KKC_TYPE_DECODER (kkc_decoder_get_type ())
#define KKC_DECODER(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), KKC_TYPE_DECODER, KkcDecoder))
#define KKC_DECODER_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), KKC_TYPE_DECODER, KkcDecoderClass))
#define KKC_IS_DECODER(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), KKC_TYPE_DECODER))
#define KKC_IS_DECODER_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), KKC_TYPE_DECODER))
#define KKC_DECODER_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), KKC_TYPE_DECODER, KkcDecoderClass))

typedef struct _KkcDecoder KkcDecoder;
typedef struct _KkcDecoderClass KkcDecoderClass;

#define KKC_TYPE_SEGMENT_LIST (kkc_segment_list_get_type ())
#define KKC_SEGMENT_LIST(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), KKC_TYPE_SEGMENT_LIST, KkcSegmentList))
#define KKC_SEGMENT_LIST_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), KKC_TYPE_SEGMENT_LIST, KkcSegmentListClass))
#define KKC_IS_SEGMENT_LIST(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), KKC_TYPE_SEGMENT_LIST))
#define KKC_IS_SEGMENT_LIST_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), KKC_TYPE_SEGMENT_LIST))
#define KKC_SEGMENT_LIST_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), KKC_TYPE_SEGMENT_LIST, KkcSegmentListClass))

typedef struct _KkcSegmentList KkcSegmentList;
typedef struct _KkcSegmentListClass KkcSegmentListClass;

#define KKC_TYPE_CANDIDATE_LIST (kkc_candidate_list_get_type ())
#define KKC_CANDIDATE_LIST(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), KKC_TYPE_CANDIDATE_LIST, KkcCandidateList))
#define KKC_CANDIDATE_LIST_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), KKC_TYPE_CANDIDATE_LIST, KkcCandidateListClass))
#define KKC_IS_CANDIDATE_LIST(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), KKC_TYPE_CANDIDATE_LIST))
#define KKC_IS_CANDIDATE_LIST_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), KKC_TYPE_CANDIDATE_LIST))
#define KKC_CANDIDATE_LIST_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), KKC_TYPE_CANDIDATE_LIST, KkcCandidateListClass))

typedef struct _KkcCandidateList KkcCandidateList;
typedef struct _KkcCandidateListClass KkcCandidateListClass;

#define KKC_TYPE_DICTIONARY_LIST (kkc_dictionary_list_get_type ())
#define KKC_DICTIONARY_LIST(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), KKC_TYPE_DICTIONARY_LIST, KkcDictionaryList))
#define KKC_DICTIONARY_LIST_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), KKC_TYPE_DICTIONARY_LIST, KkcDictionaryListClass))
#define KKC_IS_DICTIONARY_LIST(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), KKC_TYPE_DICTIONARY_LIST))
#define KKC_IS_DICTIONARY_LIST_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), KKC_TYPE_DICTIONARY_LIST))
#define KKC_DICTIONARY_LIST_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), KKC_TYPE_DICTIONARY_LIST, KkcDictionaryListClass))

typedef struct _KkcDictionaryList KkcDictionaryList;
typedef struct _KkcDictionaryListClass KkcDictionaryListClass;

#define KKC_TYPE_ROM_KANA_CONVERTER (kkc_rom_kana_converter_get_type ())
#define KKC_ROM_KANA_CONVERTER(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), KKC_TYPE_ROM_KANA_CONVERTER, KkcRomKanaConverter))
#define KKC_ROM_KANA_CONVERTER_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), KKC_TYPE_ROM_KANA_CONVERTER, KkcRomKanaConverterClass))
#define KKC_IS_ROM_KANA_CONVERTER(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), KKC_TYPE_ROM_KANA_CONVERTER))
#define KKC_IS_ROM_KANA_CONVERTER_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), KKC_TYPE_ROM_KANA_CONVERTER))
#define KKC_ROM_KANA_CONVERTER_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), KKC_TYPE_ROM_KANA_CONVERTER, KkcRomKanaConverterClass))

typedef struct _KkcRomKanaConverter KkcRomKanaConverter;
typedef struct _KkcRomKanaConverterClass KkcRomKanaConverterClass;

#define KKC_TYPE_ROM_KANA_CHARACTER_LIST (kkc_rom_kana_character_list_get_type ())
#define KKC_ROM_KANA_CHARACTER_LIST(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), KKC_TYPE_ROM_KANA_CHARACTER_LIST, KkcRomKanaCharacterList))
#define KKC_ROM_KANA_CHARACTER_LIST_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), KKC_TYPE_ROM_KANA_CHARACTER_LIST, KkcRomKanaCharacterListClass))
#define KKC_IS_ROM_KANA_CHARACTER_LIST(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), KKC_TYPE_ROM_KANA_CHARACTER_LIST))
#define KKC_IS_ROM_KANA_CHARACTER_LIST_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), KKC_TYPE_ROM_KANA_CHARACTER_LIST))
#define KKC_ROM_KANA_CHARACTER_LIST_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), KKC_TYPE_ROM_KANA_CHARACTER_LIST, KkcRomKanaCharacterListClass))

typedef struct _KkcRomKanaCharacterList KkcRomKanaCharacterList;
typedef struct _KkcRomKanaCharacterListClass KkcRomKanaCharacterListClass;
#define _g_free0(var) (var = (g_free (var), NULL))

#define KKC_TYPE_SEGMENT (kkc_segment_get_type ())
#define KKC_SEGMENT(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), KKC_TYPE_SEGMENT, KkcSegment))
#define KKC_SEGMENT_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), KKC_TYPE_SEGMENT, KkcSegmentClass))
#define KKC_IS_SEGMENT(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), KKC_TYPE_SEGMENT))
#define KKC_IS_SEGMENT_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), KKC_TYPE_SEGMENT))
#define KKC_SEGMENT_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), KKC_TYPE_SEGMENT, KkcSegmentClass))

typedef struct _KkcSegment KkcSegment;
typedef struct _KkcSegmentClass KkcSegmentClass;
#define _g_object_unref0(var) ((var == NULL) ? NULL : (var = (g_object_unref (var), NULL)))

#define KKC_TYPE_CONVERT_SEGMENT_STATE_HANDLER (kkc_convert_segment_state_handler_get_type ())
#define KKC_CONVERT_SEGMENT_STATE_HANDLER(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), KKC_TYPE_CONVERT_SEGMENT_STATE_HANDLER, KkcConvertSegmentStateHandler))
#define KKC_CONVERT_SEGMENT_STATE_HANDLER_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), KKC_TYPE_CONVERT_SEGMENT_STATE_HANDLER, KkcConvertSegmentStateHandlerClass))
#define KKC_IS_CONVERT_SEGMENT_STATE_HANDLER(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), KKC_TYPE_CONVERT_SEGMENT_STATE_HANDLER))
#define KKC_IS_CONVERT_SEGMENT_STATE_HANDLER_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), KKC_TYPE_CONVERT_SEGMENT_STATE_HANDLER))
#define KKC_CONVERT_SEGMENT_STATE_HANDLER_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), KKC_TYPE_CONVERT_SEGMENT_STATE_HANDLER, KkcConvertSegmentStateHandlerClass))

typedef struct _KkcConvertSegmentStateHandler KkcConvertSegmentStateHandler;
typedef struct _KkcConvertSegmentStateHandlerClass KkcConvertSegmentStateHandlerClass;

#define KKC_TYPE_CONVERT_SENTENCE_STATE_HANDLER (kkc_convert_sentence_state_handler_get_type ())
#define KKC_CONVERT_SENTENCE_STATE_HANDLER(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), KKC_TYPE_CONVERT_SENTENCE_STATE_HANDLER, KkcConvertSentenceStateHandler))
#define KKC_CONVERT_SENTENCE_STATE_HANDLER_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), KKC_TYPE_CONVERT_SENTENCE_STATE_HANDLER, KkcConvertSentenceStateHandlerClass))
#define KKC_IS_CONVERT_SENTENCE_STATE_HANDLER(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), KKC_TYPE_CONVERT_SENTENCE_STATE_HANDLER))
#define KKC_IS_CONVERT_SENTENCE_STATE_HANDLER_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), KKC_TYPE_CONVERT_SENTENCE_STATE_HANDLER))
#define KKC_CONVERT_SENTENCE_STATE_HANDLER_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), KKC_TYPE_CONVERT_SENTENCE_STATE_HANDLER, KkcConvertSentenceStateHandlerClass))

typedef struct _KkcConvertSentenceStateHandler KkcConvertSentenceStateHandler;
typedef struct _KkcConvertSentenceStateHandlerClass KkcConvertSentenceStateHandlerClass;

#define KKC_TYPE_MODIFIER_TYPE (kkc_modifier_type_get_type ())

#define KKC_TYPE_ROM_KANA_CHARACTER (kkc_rom_kana_character_get_type ())
typedef struct _KkcRomKanaCharacter KkcRomKanaCharacter;

#define KKC_TYPE_KANA_MODE (kkc_kana_mode_get_type ())

#define KKC_TYPE_INPUT_MODE (kkc_input_mode_get_type ())
#define _g_string_free0(var) ((var == NULL) ? NULL : (var = (g_string_free (var, TRUE), NULL)))
#define _g_type_class_unref0(var) ((var == NULL) ? NULL : (var = (g_type_class_unref (var), NULL)))

#define KKC_TYPE_COMMAND_HANDLER (kkc_command_handler_get_type ())
#define KKC_COMMAND_HANDLER(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), KKC_TYPE_COMMAND_HANDLER, KkcCommandHandler))
#define KKC_IS_COMMAND_HANDLER(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), KKC_TYPE_COMMAND_HANDLER))
#define KKC_COMMAND_HANDLER_GET_INTERFACE(obj) (G_TYPE_INSTANCE_GET_INTERFACE ((obj), KKC_TYPE_COMMAND_HANDLER, KkcCommandHandlerIface))

typedef struct _KkcCommandHandler KkcCommandHandler;
typedef struct _KkcCommandHandlerIface KkcCommandHandlerIface;

#define KKC_INITIAL_STATE_HANDLER_TYPE_CONVERT_COMMAND_HANDLER (kkc_initial_state_handler_convert_command_handler_get_type ())
#define KKC_INITIAL_STATE_HANDLER_CONVERT_COMMAND_HANDLER(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), KKC_INITIAL_STATE_HANDLER_TYPE_CONVERT_COMMAND_HANDLER, KkcInitialStateHandlerConvertCommandHandler))
#define KKC_INITIAL_STATE_HANDLER_CONVERT_COMMAND_HANDLER_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), KKC_INITIAL_STATE_HANDLER_TYPE_CONVERT_COMMAND_HANDLER, KkcInitialStateHandlerConvertCommandHandlerClass))
#define KKC_INITIAL_STATE_HANDLER_IS_CONVERT_COMMAND_HANDLER(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), KKC_INITIAL_STATE_HANDLER_TYPE_CONVERT_COMMAND_HANDLER))
#define KKC_INITIAL_STATE_HANDLER_IS_CONVERT_COMMAND_HANDLER_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), KKC_INITIAL_STATE_HANDLER_TYPE_CONVERT_COMMAND_HANDLER))
#define KKC_INITIAL_STATE_HANDLER_CONVERT_COMMAND_HANDLER_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), KKC_INITIAL_STATE_HANDLER_TYPE_CONVERT_COMMAND_HANDLER, KkcInitialStateHandlerConvertCommandHandlerClass))

typedef struct _KkcInitialStateHandlerConvertCommandHandler KkcInitialStateHandlerConvertCommandHandler;
typedef struct _KkcInitialStateHandlerConvertCommandHandlerClass KkcInitialStateHandlerConvertCommandHandlerClass;
typedef struct _KkcInitialStateHandlerConvertCommandHandlerPrivate KkcInitialStateHandlerConvertCommandHandlerPrivate;

struct _KkcStateHandler {
	GObject parent_instance;
	KkcStateHandlerPrivate * priv;
};

struct _KkcStateHandlerClass {
	GObjectClass parent_class;
	gboolean (*process_key_event) (KkcStateHandler* self, KkcState* state, KkcKeyEvent* key);
};

struct _KkcInitialStateHandler {
	KkcStateHandler parent_instance;
	KkcInitialStateHandlerPrivate * priv;
};

struct _KkcInitialStateHandlerClass {
	KkcStateHandlerClass parent_class;
};

struct _KkcState {
	GObject parent_instance;
	KkcStatePrivate * priv;
	GType handler_type;
	KkcLanguageModel* model;
	KkcDecoder* decoder;
	KkcSegmentList* segments;
	KkcCandidateList* candidates;
	KkcDictionaryList* dictionaries;
	KkcRomKanaConverter* rom_kana_converter;
	KkcRomKanaCharacterList* input_characters;
	gint input_characters_cursor_pos;
	GString* selection;
	GString* output;
	gboolean quoted;
	KkcKeyEvent* this_command_key;
	KkcKeyEvent* last_command_key;
	gchar* overriding_input;
	GeeIterator* completion_iterator;
};

struct _KkcStateClass {
	GObjectClass parent_class;
};

typedef enum  {
	KKC_MODIFIER_TYPE_NONE = 0,
	KKC_MODIFIER_TYPE_SHIFT_MASK = 1 << 0,
	KKC_MODIFIER_TYPE_LOCK_MASK = 1 << 1,
	KKC_MODIFIER_TYPE_CONTROL_MASK = 1 << 2,
	KKC_MODIFIER_TYPE_MOD1_MASK = 1 << 3,
	KKC_MODIFIER_TYPE_MOD2_MASK = 1 << 4,
	KKC_MODIFIER_TYPE_MOD3_MASK = 1 << 5,
	KKC_MODIFIER_TYPE_MOD4_MASK = 1 << 6,
	KKC_MODIFIER_TYPE_MOD5_MASK = 1 << 7,
	KKC_MODIFIER_TYPE_LSHIFT_MASK = 1 << 22,
	KKC_MODIFIER_TYPE_RSHIFT_MASK = 1 << 23,
	KKC_MODIFIER_TYPE_SUPER_MASK = 1 << 26,
	KKC_MODIFIER_TYPE_HYPER_MASK = 1 << 27,
	KKC_MODIFIER_TYPE_META_MASK = 1 << 28,
	KKC_MODIFIER_TYPE_RELEASE_MASK = 1 << 30
} KkcModifierType;

struct _KkcRomKanaCharacter {
	gchar* output;
	gchar* input;
};

typedef enum  {
	KKC_KANA_MODE_HIRAGANA,
	KKC_KANA_MODE_KATAKANA,
	KKC_KANA_MODE_HANKAKU_KATAKANA,
	KKC_KANA_MODE_LATIN,
	KKC_KANA_MODE_WIDE_LATIN
} KkcKanaMode;

typedef enum  {
	KKC_INPUT_MODE_HIRAGANA = KKC_KANA_MODE_HIRAGANA,
	KKC_INPUT_MODE_KATAKANA = KKC_KANA_MODE_KATAKANA,
	KKC_INPUT_MODE_HANKAKU_KATAKANA = KKC_KANA_MODE_HANKAKU_KATAKANA,
	KKC_INPUT_MODE_LATIN = KKC_KANA_MODE_LATIN,
	KKC_INPUT_MODE_WIDE_LATIN = KKC_KANA_MODE_WIDE_LATIN,
	KKC_INPUT_MODE_DIRECT
} KkcInputMode;

struct _KkcCommandHandlerIface {
	GTypeInterface parent_iface;
	gboolean (*call) (KkcCommandHandler* self, const gchar* command, KkcState* state, KkcKeyEvent* key);
};

typedef gboolean (*KkcCommandCallback) (const gchar* command, KkcState* state, KkcKeyEvent* key, void* user_data);
struct _KkcInitialStateHandlerConvertCommandHandler {
	GObject parent_instance;
	KkcInitialStateHandlerConvertCommandHandlerPrivate * priv;
};

struct _KkcInitialStateHandlerConvertCommandHandlerClass {
	GObjectClass parent_class;
};

struct _KkcInitialStateHandlerConvertCommandHandlerPrivate {
	KkcKanaMode mode;
};


static gpointer kkc_initial_state_handler_parent_class = NULL;
static gpointer kkc_initial_state_handler_convert_command_handler_parent_class = NULL;
static KkcCommandHandlerIface* kkc_initial_state_handler_convert_command_handler_kkc_command_handler_parent_iface = NULL;

GType kkc_state_handler_get_type (void) G_GNUC_CONST;
GType kkc_state_get_type (void) G_GNUC_CONST;
GType kkc_key_event_get_type (void) G_GNUC_CONST;
GType kkc_initial_state_handler_get_type (void) G_GNUC_CONST;
enum  {
	KKC_INITIAL_STATE_HANDLER_DUMMY_PROPERTY
};
static gboolean kkc_initial_state_handler_do_quote (KkcInitialStateHandler* self, const gchar* command, KkcState* state, KkcKeyEvent* key);
GType kkc_language_model_get_type (void) G_GNUC_CONST;
GType kkc_decoder_get_type (void) G_GNUC_CONST;
GType kkc_segment_list_get_type (void) G_GNUC_CONST;
GType kkc_candidate_list_get_type (void) G_GNUC_CONST;
GType kkc_dictionary_list_get_type (void) G_GNUC_CONST;
GType kkc_rom_kana_converter_get_type (void) G_GNUC_CONST;
GType kkc_rom_kana_character_list_get_type (void) G_GNUC_CONST;
static gboolean kkc_initial_state_handler_do_register (KkcInitialStateHandler* self, const gchar* command, KkcState* state, KkcKeyEvent* key);
static gboolean kkc_initial_state_handler_do_abort (KkcInitialStateHandler* self, const gchar* command, KkcState* state, KkcKeyEvent* key);
gint kkc_rom_kana_character_list_get_size (KkcRomKanaCharacterList* self);
const gchar* kkc_rom_kana_converter_get_pending_output (KkcRomKanaConverter* self);
void kkc_state_reset (KkcState* self);
static gboolean kkc_initial_state_handler_do_delete (KkcInitialStateHandler* self, const gchar* command, KkcState* state, KkcKeyEvent* key);
gboolean kkc_rom_kana_converter_delete (KkcRomKanaConverter* self);
void kkc_rom_kana_character_list_remove_at (KkcRomKanaCharacterList* self, gint index);
static gboolean kkc_initial_state_handler_do_delete_forward (KkcInitialStateHandler* self, const gchar* command, KkcState* state, KkcKeyEvent* key);
static gboolean kkc_initial_state_handler_do_complete (KkcInitialStateHandler* self, const gchar* command, KkcState* state, KkcKeyEvent* key);
void kkc_state_finish_input_editing (KkcState* self);
void kkc_state_completion_start (KkcState* self, const gchar* input);
gchar* kkc_state_get_input (KkcState* self);
static gboolean kkc_initial_state_handler_do_next_candidate (KkcInitialStateHandler* self, const gchar* command, KkcState* state, KkcKeyEvent* key);
GType kkc_segment_get_type (void) G_GNUC_CONST;
KkcSegment* kkc_segment_new (const gchar* input, const gchar* output);
KkcSegment* kkc_segment_construct (GType object_type, const gchar* input, const gchar* output);
void kkc_segment_list_set_segments (KkcSegmentList* self, KkcSegment* segment);
gboolean kkc_segment_list_first_segment (KkcSegmentList* self);
void kkc_state_lookup (KkcState* self, KkcSegment* segment);
KkcSegment* kkc_segment_list_get (KkcSegmentList* self, gint index);
gint kkc_segment_list_get_cursor_pos (KkcSegmentList* self);
gboolean kkc_candidate_list_first (KkcCandidateList* self);
GType kkc_convert_segment_state_handler_get_type (void) G_GNUC_CONST;
gint kkc_segment_list_get_size (KkcSegmentList* self);
gchar* kkc_rom_kana_utils_get_hiragana (const gchar* kana);
gchar* kkc_state_lookup_single (KkcState* self, const gchar* input);
void kkc_state_convert_sentence (KkcState* self, const gchar* input, gint* constraint, int constraint_length1);
GType kkc_convert_sentence_state_handler_get_type (void) G_GNUC_CONST;
static gboolean kkc_initial_state_handler_do_next_character (KkcInitialStateHandler* self, const gchar* command, KkcState* state, KkcKeyEvent* key);
static gboolean kkc_initial_state_handler_do_previous_character (KkcInitialStateHandler* self, const gchar* command, KkcState* state, KkcKeyEvent* key);
static gboolean kkc_initial_state_handler_do_first_character (KkcInitialStateHandler* self, const gchar* command, KkcState* state, KkcKeyEvent* key);
static gboolean kkc_initial_state_handler_do_last_character (KkcInitialStateHandler* self, const gchar* command, KkcState* state, KkcKeyEvent* key);
static gboolean kkc_initial_state_handler_do_ (KkcInitialStateHandler* self, const gchar* command, KkcState* state, KkcKeyEvent* key);
GType kkc_modifier_type_get_type (void) G_GNUC_CONST;
KkcModifierType kkc_key_event_get_modifiers (KkcKeyEvent* self);
gboolean kkc_rom_kana_converter_is_valid (KkcRomKanaConverter* self, gunichar uc);
gunichar kkc_key_event_get_unicode (KkcKeyEvent* self);
gboolean kkc_rom_kana_converter_append (KkcRomKanaConverter* self, gunichar uc);
KkcRomKanaCharacterList* kkc_rom_kana_converter_get_produced (KkcRomKanaConverter* self);
void kkc_rom_kana_character_list_insert_all (KkcRomKanaCharacterList* self, gint index, KkcRomKanaCharacterList* other);
GType kkc_rom_kana_character_get_type (void) G_GNUC_CONST;
KkcRomKanaCharacter* kkc_rom_kana_character_dup (const KkcRomKanaCharacter* self);
void kkc_rom_kana_character_free (KkcRomKanaCharacter* self);
void kkc_rom_kana_character_copy (const KkcRomKanaCharacter* self, KkcRomKanaCharacter* dest);
void kkc_rom_kana_character_destroy (KkcRomKanaCharacter* self);
void kkc_rom_kana_character_list_get (KkcRomKanaCharacterList* self, gint index, KkcRomKanaCharacter* result);
void kkc_rom_kana_character_list_add_all (KkcRomKanaCharacterList* self, KkcRomKanaCharacterList* other);
void kkc_rom_kana_character_list_clear (KkcRomKanaCharacterList* self);
GType kkc_kana_mode_get_type (void) G_GNUC_CONST;
gchar* kkc_rom_kana_utils_convert_by_kana_mode (const gchar* str, KkcKanaMode mode);
GType kkc_input_mode_get_type (void) G_GNUC_CONST;
KkcInputMode kkc_state_get_input_mode (KkcState* self);
void kkc_rom_kana_character_list_insert (KkcRomKanaCharacterList* self, gint index, KkcRomKanaCharacter* character);
void kkc_rom_kana_character_list_add (KkcRomKanaCharacterList* self, KkcRomKanaCharacter* character);
static gboolean kkc_initial_state_handler_real_process_key_event (KkcStateHandler* base, KkcState* state, KkcKeyEvent* key);
gchar* kkc_state_lookup_key (KkcState* self, KkcKeyEvent* key);
gchar* kkc_rom_kana_character_list_get_input (KkcRomKanaCharacterList* self);
static GEnumValue* _g_enum_value_dup (GEnumValue* self);
void kkc_state_set_input_mode (KkcState* self, KkcInputMode value);
gboolean kkc_state_handler_dispatch_command (KkcStateHandler* self, KkcState* state, KkcKeyEvent* key);
KkcInitialStateHandler* kkc_initial_state_handler_new (void);
KkcInitialStateHandler* kkc_initial_state_handler_construct (GType object_type);
KkcStateHandler* kkc_state_handler_construct (GType object_type);
static GObject * kkc_initial_state_handler_constructor (GType type, guint n_construct_properties, GObjectConstructParam * construct_properties);
GType kkc_command_handler_get_type (void) G_GNUC_CONST;
void kkc_state_handler_register_command_handler (KkcStateHandler* self, const gchar* command, KkcCommandHandler* handler);
static KkcInitialStateHandlerConvertCommandHandler* kkc_initial_state_handler_convert_command_handler_new (KkcKanaMode mode);
static KkcInitialStateHandlerConvertCommandHandler* kkc_initial_state_handler_convert_command_handler_construct (GType object_type, KkcKanaMode mode);
static GType kkc_initial_state_handler_convert_command_handler_get_type (void) G_GNUC_CONST G_GNUC_UNUSED;
void kkc_state_handler_register_command_callback (KkcStateHandler* self, const gchar* command, KkcCommandCallback cb, void* cb_target);
static gboolean _kkc_initial_state_handler_do_abort_kkc_command_callback (const gchar* command, KkcState* state, KkcKeyEvent* key, gpointer self);
static gboolean _kkc_initial_state_handler_do_complete_kkc_command_callback (const gchar* command, KkcState* state, KkcKeyEvent* key, gpointer self);
static gboolean _kkc_initial_state_handler_do_delete_kkc_command_callback (const gchar* command, KkcState* state, KkcKeyEvent* key, gpointer self);
static gboolean _kkc_initial_state_handler_do_delete_forward_kkc_command_callback (const gchar* command, KkcState* state, KkcKeyEvent* key, gpointer self);
static gboolean _kkc_initial_state_handler_do_next_candidate_kkc_command_callback (const gchar* command, KkcState* state, KkcKeyEvent* key, gpointer self);
static gboolean _kkc_initial_state_handler_do_next_character_kkc_command_callback (const gchar* command, KkcState* state, KkcKeyEvent* key, gpointer self);
static gboolean _kkc_initial_state_handler_do_previous_character_kkc_command_callback (const gchar* command, KkcState* state, KkcKeyEvent* key, gpointer self);
static gboolean _kkc_initial_state_handler_do_first_character_kkc_command_callback (const gchar* command, KkcState* state, KkcKeyEvent* key, gpointer self);
static gboolean _kkc_initial_state_handler_do_last_character_kkc_command_callback (const gchar* command, KkcState* state, KkcKeyEvent* key, gpointer self);
static gboolean _kkc_initial_state_handler_do_quote_kkc_command_callback (const gchar* command, KkcState* state, KkcKeyEvent* key, gpointer self);
static gboolean _kkc_initial_state_handler_do_register_kkc_command_callback (const gchar* command, KkcState* state, KkcKeyEvent* key, gpointer self);
static gboolean _kkc_initial_state_handler_do__kkc_command_callback (const gchar* command, KkcState* state, KkcKeyEvent* key, gpointer self);
#define KKC_INITIAL_STATE_HANDLER_CONVERT_COMMAND_HANDLER_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), KKC_INITIAL_STATE_HANDLER_TYPE_CONVERT_COMMAND_HANDLER, KkcInitialStateHandlerConvertCommandHandlerPrivate))
enum  {
	KKC_INITIAL_STATE_HANDLER_CONVERT_COMMAND_HANDLER_DUMMY_PROPERTY
};
static gboolean kkc_initial_state_handler_convert_command_handler_real_call (KkcCommandHandler* base, const gchar* command, KkcState* state, KkcKeyEvent* key);
gchar* kkc_state_convert_rom_kana_characters_by_kana_mode (KkcState* self, KkcRomKanaCharacterList* characters, KkcKanaMode mode);
static void kkc_initial_state_handler_convert_command_handler_finalize (GObject* obj);


static gboolean kkc_initial_state_handler_do_quote (KkcInitialStateHandler* self, const gchar* command, KkcState* state, KkcKeyEvent* key) {
	gboolean result = FALSE;
	KkcState* _tmp0_ = NULL;
	g_return_val_if_fail (self != NULL, FALSE);
	g_return_val_if_fail (state != NULL, FALSE);
	g_return_val_if_fail (key != NULL, FALSE);
	_tmp0_ = state;
	_tmp0_->quoted = TRUE;
	result = TRUE;
	return result;
}


static gboolean kkc_initial_state_handler_do_register (KkcInitialStateHandler* self, const gchar* command, KkcState* state, KkcKeyEvent* key) {
	gboolean result = FALSE;
	KkcState* _tmp0_ = NULL;
	g_return_val_if_fail (self != NULL, FALSE);
	g_return_val_if_fail (state != NULL, FALSE);
	g_return_val_if_fail (key != NULL, FALSE);
	_tmp0_ = state;
	g_signal_emit_by_name (_tmp0_, "request-selection-text");
	result = TRUE;
	return result;
}


static gboolean kkc_initial_state_handler_do_abort (KkcInitialStateHandler* self, const gchar* command, KkcState* state, KkcKeyEvent* key) {
	gboolean result = FALSE;
	KkcState* _tmp0_ = NULL;
	const gchar* _tmp1_ = NULL;
	gboolean _tmp3_ = FALSE;
	KkcState* _tmp4_ = NULL;
	KkcRomKanaCharacterList* _tmp5_ = NULL;
	gint _tmp6_ = 0;
	gint _tmp7_ = 0;
	g_return_val_if_fail (self != NULL, FALSE);
	g_return_val_if_fail (state != NULL, FALSE);
	g_return_val_if_fail (key != NULL, FALSE);
	_tmp0_ = state;
	_tmp1_ = _tmp0_->overriding_input;
	if (_tmp1_ != NULL) {
		KkcState* _tmp2_ = NULL;
		_tmp2_ = state;
		_g_free0 (_tmp2_->overriding_input);
		_tmp2_->overriding_input = NULL;
		result = TRUE;
		return result;
	}
	_tmp4_ = state;
	_tmp5_ = _tmp4_->input_characters;
	_tmp6_ = kkc_rom_kana_character_list_get_size (_tmp5_);
	_tmp7_ = _tmp6_;
	if (_tmp7_ > 0) {
		_tmp3_ = TRUE;
	} else {
		KkcState* _tmp8_ = NULL;
		KkcRomKanaConverter* _tmp9_ = NULL;
		const gchar* _tmp10_ = NULL;
		const gchar* _tmp11_ = NULL;
		gint _tmp12_ = 0;
		gint _tmp13_ = 0;
		_tmp8_ = state;
		_tmp9_ = _tmp8_->rom_kana_converter;
		_tmp10_ = kkc_rom_kana_converter_get_pending_output (_tmp9_);
		_tmp11_ = _tmp10_;
		_tmp12_ = strlen (_tmp11_);
		_tmp13_ = _tmp12_;
		_tmp3_ = _tmp13_ > 0;
	}
	if (_tmp3_) {
		KkcState* _tmp14_ = NULL;
		_tmp14_ = state;
		kkc_state_reset (_tmp14_);
		result = TRUE;
		return result;
	}
	result = FALSE;
	return result;
}


static gboolean kkc_initial_state_handler_do_delete (KkcInitialStateHandler* self, const gchar* command, KkcState* state, KkcKeyEvent* key) {
	gboolean result = FALSE;
	KkcState* _tmp0_ = NULL;
	const gchar* _tmp1_ = NULL;
	KkcState* _tmp3_ = NULL;
	KkcRomKanaConverter* _tmp4_ = NULL;
	gboolean _tmp5_ = FALSE;
	KkcState* _tmp6_ = NULL;
	gint _tmp7_ = 0;
	KkcState* _tmp16_ = NULL;
	KkcRomKanaCharacterList* _tmp17_ = NULL;
	gint _tmp18_ = 0;
	gint _tmp19_ = 0;
	g_return_val_if_fail (self != NULL, FALSE);
	g_return_val_if_fail (state != NULL, FALSE);
	g_return_val_if_fail (key != NULL, FALSE);
	_tmp0_ = state;
	_tmp1_ = _tmp0_->overriding_input;
	if (_tmp1_ != NULL) {
		KkcState* _tmp2_ = NULL;
		_tmp2_ = state;
		_g_free0 (_tmp2_->overriding_input);
		_tmp2_->overriding_input = NULL;
		result = TRUE;
		return result;
	}
	_tmp3_ = state;
	_tmp4_ = _tmp3_->rom_kana_converter;
	_tmp5_ = kkc_rom_kana_converter_delete (_tmp4_);
	if (_tmp5_) {
		result = TRUE;
		return result;
	}
	_tmp6_ = state;
	_tmp7_ = _tmp6_->input_characters_cursor_pos;
	if (_tmp7_ >= 0) {
		KkcState* _tmp8_ = NULL;
		gint _tmp9_ = 0;
		_tmp8_ = state;
		_tmp9_ = _tmp8_->input_characters_cursor_pos;
		if (_tmp9_ > 0) {
			KkcState* _tmp10_ = NULL;
			KkcRomKanaCharacterList* _tmp11_ = NULL;
			KkcState* _tmp12_ = NULL;
			KkcState* _tmp13_ = NULL;
			gint _tmp14_ = 0;
			gint _tmp15_ = 0;
			_tmp10_ = state;
			_tmp11_ = _tmp10_->input_characters;
			_tmp12_ = state;
			_tmp13_ = state;
			_tmp14_ = _tmp13_->input_characters_cursor_pos;
			_tmp13_->input_characters_cursor_pos = _tmp14_ - 1;
			_tmp15_ = _tmp13_->input_characters_cursor_pos;
			kkc_rom_kana_character_list_remove_at (_tmp11_, _tmp15_);
		}
		result = TRUE;
		return result;
	}
	_tmp16_ = state;
	_tmp17_ = _tmp16_->input_characters;
	_tmp18_ = kkc_rom_kana_character_list_get_size (_tmp17_);
	_tmp19_ = _tmp18_;
	if (_tmp19_ > 0) {
		KkcState* _tmp20_ = NULL;
		KkcRomKanaCharacterList* _tmp21_ = NULL;
		KkcState* _tmp22_ = NULL;
		KkcRomKanaCharacterList* _tmp23_ = NULL;
		gint _tmp24_ = 0;
		gint _tmp25_ = 0;
		_tmp20_ = state;
		_tmp21_ = _tmp20_->input_characters;
		_tmp22_ = state;
		_tmp23_ = _tmp22_->input_characters;
		_tmp24_ = kkc_rom_kana_character_list_get_size (_tmp23_);
		_tmp25_ = _tmp24_;
		kkc_rom_kana_character_list_remove_at (_tmp21_, _tmp25_ - 1);
		result = TRUE;
		return result;
	}
	result = FALSE;
	return result;
}


static gboolean kkc_initial_state_handler_do_delete_forward (KkcInitialStateHandler* self, const gchar* command, KkcState* state, KkcKeyEvent* key) {
	gboolean result = FALSE;
	gboolean _tmp0_ = FALSE;
	KkcState* _tmp1_ = NULL;
	gint _tmp2_ = 0;
	g_return_val_if_fail (self != NULL, FALSE);
	g_return_val_if_fail (state != NULL, FALSE);
	g_return_val_if_fail (key != NULL, FALSE);
	_tmp1_ = state;
	_tmp2_ = _tmp1_->input_characters_cursor_pos;
	if (_tmp2_ >= 0) {
		KkcState* _tmp3_ = NULL;
		gint _tmp4_ = 0;
		KkcState* _tmp5_ = NULL;
		KkcRomKanaCharacterList* _tmp6_ = NULL;
		gint _tmp7_ = 0;
		gint _tmp8_ = 0;
		_tmp3_ = state;
		_tmp4_ = _tmp3_->input_characters_cursor_pos;
		_tmp5_ = state;
		_tmp6_ = _tmp5_->input_characters;
		_tmp7_ = kkc_rom_kana_character_list_get_size (_tmp6_);
		_tmp8_ = _tmp7_;
		_tmp0_ = _tmp4_ < _tmp8_;
	} else {
		_tmp0_ = FALSE;
	}
	if (_tmp0_) {
		KkcState* _tmp9_ = NULL;
		KkcRomKanaCharacterList* _tmp10_ = NULL;
		KkcState* _tmp11_ = NULL;
		gint _tmp12_ = 0;
		KkcState* _tmp13_ = NULL;
		gint _tmp14_ = 0;
		KkcState* _tmp15_ = NULL;
		KkcRomKanaCharacterList* _tmp16_ = NULL;
		gint _tmp17_ = 0;
		gint _tmp18_ = 0;
		_tmp9_ = state;
		_tmp10_ = _tmp9_->input_characters;
		_tmp11_ = state;
		_tmp12_ = _tmp11_->input_characters_cursor_pos;
		kkc_rom_kana_character_list_remove_at (_tmp10_, _tmp12_);
		_tmp13_ = state;
		_tmp14_ = _tmp13_->input_characters_cursor_pos;
		_tmp15_ = state;
		_tmp16_ = _tmp15_->input_characters;
		_tmp17_ = kkc_rom_kana_character_list_get_size (_tmp16_);
		_tmp18_ = _tmp17_;
		if (_tmp14_ == _tmp18_) {
			KkcState* _tmp19_ = NULL;
			_tmp19_ = state;
			_tmp19_->input_characters_cursor_pos = -1;
		}
		result = TRUE;
		return result;
	}
	result = FALSE;
	return result;
}


static gboolean kkc_initial_state_handler_do_complete (KkcInitialStateHandler* self, const gchar* command, KkcState* state, KkcKeyEvent* key) {
	gboolean result = FALSE;
	KkcState* _tmp0_ = NULL;
	KkcState* _tmp1_ = NULL;
	KkcRomKanaCharacterList* _tmp2_ = NULL;
	gint _tmp3_ = 0;
	gint _tmp4_ = 0;
	g_return_val_if_fail (self != NULL, FALSE);
	g_return_val_if_fail (state != NULL, FALSE);
	g_return_val_if_fail (key != NULL, FALSE);
	_tmp0_ = state;
	kkc_state_finish_input_editing (_tmp0_);
	_tmp1_ = state;
	_tmp2_ = _tmp1_->input_characters;
	_tmp3_ = kkc_rom_kana_character_list_get_size (_tmp2_);
	_tmp4_ = _tmp3_;
	if (_tmp4_ > 0) {
		KkcState* _tmp5_ = NULL;
		GeeIterator* _tmp6_ = NULL;
		KkcState* _tmp11_ = NULL;
		GeeIterator* _tmp12_ = NULL;
		_tmp5_ = state;
		_tmp6_ = _tmp5_->completion_iterator;
		if (_tmp6_ == NULL) {
			KkcState* _tmp7_ = NULL;
			KkcState* _tmp8_ = NULL;
			gchar* _tmp9_ = NULL;
			gchar* _tmp10_ = NULL;
			_tmp7_ = state;
			_tmp8_ = state;
			_tmp9_ = kkc_state_get_input (_tmp8_);
			_tmp10_ = _tmp9_;
			kkc_state_completion_start (_tmp7_, _tmp10_);
			_g_free0 (_tmp10_);
		}
		_tmp11_ = state;
		_tmp12_ = _tmp11_->completion_iterator;
		if (_tmp12_ != NULL) {
			KkcState* _tmp13_ = NULL;
			KkcState* _tmp14_ = NULL;
			GeeIterator* _tmp15_ = NULL;
			gpointer _tmp16_ = NULL;
			KkcState* _tmp17_ = NULL;
			GeeIterator* _tmp18_ = NULL;
			gboolean _tmp19_ = FALSE;
			_tmp13_ = state;
			_tmp14_ = state;
			_tmp15_ = _tmp14_->completion_iterator;
			_tmp16_ = gee_iterator_get (_tmp15_);
			_g_free0 (_tmp13_->overriding_input);
			_tmp13_->overriding_input = (gchar*) _tmp16_;
			_tmp17_ = state;
			_tmp18_ = _tmp17_->completion_iterator;
			_tmp19_ = gee_iterator_has_next (_tmp18_);
			if (_tmp19_) {
				KkcState* _tmp20_ = NULL;
				GeeIterator* _tmp21_ = NULL;
				_tmp20_ = state;
				_tmp21_ = _tmp20_->completion_iterator;
				gee_iterator_next (_tmp21_);
			}
		}
		result = TRUE;
		return result;
	}
	result = FALSE;
	return result;
}


static gboolean kkc_initial_state_handler_do_next_candidate (KkcInitialStateHandler* self, const gchar* command, KkcState* state, KkcKeyEvent* key) {
	gboolean result = FALSE;
	KkcState* _tmp0_ = NULL;
	KkcState* _tmp1_ = NULL;
	KkcRomKanaCharacterList* _tmp2_ = NULL;
	gint _tmp3_ = 0;
	gint _tmp4_ = 0;
	KkcState* _tmp5_ = NULL;
	GString* _tmp6_ = NULL;
	gssize _tmp7_ = 0L;
	KkcState* _tmp34_ = NULL;
	KkcSegmentList* _tmp35_ = NULL;
	gint _tmp36_ = 0;
	gint _tmp37_ = 0;
	g_return_val_if_fail (self != NULL, FALSE);
	g_return_val_if_fail (state != NULL, FALSE);
	g_return_val_if_fail (key != NULL, FALSE);
	_tmp0_ = state;
	kkc_state_finish_input_editing (_tmp0_);
	_tmp1_ = state;
	_tmp2_ = _tmp1_->input_characters;
	_tmp3_ = kkc_rom_kana_character_list_get_size (_tmp2_);
	_tmp4_ = _tmp3_;
	if (_tmp4_ == 0) {
		result = FALSE;
		return result;
	}
	_tmp5_ = state;
	_tmp6_ = _tmp5_->selection;
	_tmp7_ = _tmp6_->len;
	if (_tmp7_ > ((gssize) 0)) {
		gchar* input = NULL;
		KkcState* _tmp8_ = NULL;
		gchar* _tmp9_ = NULL;
		KkcSegment* segment = NULL;
		const gchar* _tmp10_ = NULL;
		KkcState* _tmp11_ = NULL;
		GString* _tmp12_ = NULL;
		const gchar* _tmp13_ = NULL;
		KkcSegment* _tmp14_ = NULL;
		KkcState* _tmp15_ = NULL;
		GString* _tmp16_ = NULL;
		KkcState* _tmp17_ = NULL;
		KkcSegmentList* _tmp18_ = NULL;
		KkcSegment* _tmp19_ = NULL;
		KkcState* _tmp20_ = NULL;
		KkcSegmentList* _tmp21_ = NULL;
		KkcState* _tmp22_ = NULL;
		KkcState* _tmp23_ = NULL;
		KkcSegmentList* _tmp24_ = NULL;
		KkcState* _tmp25_ = NULL;
		KkcSegmentList* _tmp26_ = NULL;
		gint _tmp27_ = 0;
		gint _tmp28_ = 0;
		KkcSegment* _tmp29_ = NULL;
		KkcSegment* _tmp30_ = NULL;
		KkcState* _tmp31_ = NULL;
		KkcCandidateList* _tmp32_ = NULL;
		KkcState* _tmp33_ = NULL;
		_tmp8_ = state;
		_tmp9_ = kkc_state_get_input (_tmp8_);
		input = _tmp9_;
		_tmp10_ = input;
		_tmp11_ = state;
		_tmp12_ = _tmp11_->selection;
		_tmp13_ = _tmp12_->str;
		_tmp14_ = kkc_segment_new (_tmp10_, _tmp13_);
		segment = _tmp14_;
		_tmp15_ = state;
		_tmp16_ = _tmp15_->selection;
		g_string_erase (_tmp16_, (gssize) 0, (gssize) (-1));
		_tmp17_ = state;
		_tmp18_ = _tmp17_->segments;
		_tmp19_ = segment;
		kkc_segment_list_set_segments (_tmp18_, _tmp19_);
		_tmp20_ = state;
		_tmp21_ = _tmp20_->segments;
		kkc_segment_list_first_segment (_tmp21_);
		_tmp22_ = state;
		_tmp23_ = state;
		_tmp24_ = _tmp23_->segments;
		_tmp25_ = state;
		_tmp26_ = _tmp25_->segments;
		_tmp27_ = kkc_segment_list_get_cursor_pos (_tmp26_);
		_tmp28_ = _tmp27_;
		_tmp29_ = kkc_segment_list_get (_tmp24_, _tmp28_);
		_tmp30_ = _tmp29_;
		kkc_state_lookup (_tmp22_, _tmp30_);
		_g_object_unref0 (_tmp30_);
		_tmp31_ = state;
		_tmp32_ = _tmp31_->candidates;
		kkc_candidate_list_first (_tmp32_);
		_tmp33_ = state;
		_tmp33_->handler_type = KKC_TYPE_CONVERT_SEGMENT_STATE_HANDLER;
		result = TRUE;
		_g_object_unref0 (segment);
		_g_free0 (input);
		return result;
	}
	_tmp34_ = state;
	_tmp35_ = _tmp34_->segments;
	_tmp36_ = kkc_segment_list_get_size (_tmp35_);
	_tmp37_ = _tmp36_;
	if (_tmp37_ == 0) {
		KkcState* _tmp38_ = NULL;
		gchar* input = NULL;
		KkcState* _tmp39_ = NULL;
		gchar* _tmp40_ = NULL;
		gchar* _tmp41_ = NULL;
		gchar* _tmp42_ = NULL;
		gchar* _tmp43_ = NULL;
		gchar* output = NULL;
		KkcState* _tmp44_ = NULL;
		const gchar* _tmp45_ = NULL;
		gchar* _tmp46_ = NULL;
		const gchar* _tmp47_ = NULL;
		KkcState* _tmp56_ = NULL;
		KkcSegmentList* _tmp57_ = NULL;
		KkcState* _tmp58_ = NULL;
		_tmp38_ = state;
		kkc_state_finish_input_editing (_tmp38_);
		_tmp39_ = state;
		_tmp40_ = kkc_state_get_input (_tmp39_);
		_tmp41_ = _tmp40_;
		_tmp42_ = kkc_rom_kana_utils_get_hiragana (_tmp41_);
		_tmp43_ = _tmp42_;
		_g_free0 (_tmp41_);
		input = _tmp43_;
		_tmp44_ = state;
		_tmp45_ = input;
		_tmp46_ = kkc_state_lookup_single (_tmp44_, _tmp45_);
		output = _tmp46_;
		_tmp47_ = output;
		if (_tmp47_ != NULL) {
			KkcSegment* segment = NULL;
			const gchar* _tmp48_ = NULL;
			const gchar* _tmp49_ = NULL;
			KkcSegment* _tmp50_ = NULL;
			KkcState* _tmp51_ = NULL;
			KkcSegmentList* _tmp52_ = NULL;
			KkcSegment* _tmp53_ = NULL;
			_tmp48_ = input;
			_tmp49_ = output;
			_tmp50_ = kkc_segment_new (_tmp48_, _tmp49_);
			segment = _tmp50_;
			_tmp51_ = state;
			_tmp52_ = _tmp51_->segments;
			_tmp53_ = segment;
			kkc_segment_list_set_segments (_tmp52_, _tmp53_);
			_g_object_unref0 (segment);
		} else {
			KkcState* _tmp54_ = NULL;
			const gchar* _tmp55_ = NULL;
			_tmp54_ = state;
			_tmp55_ = input;
			kkc_state_convert_sentence (_tmp54_, _tmp55_, NULL, 0);
		}
		_tmp56_ = state;
		_tmp57_ = _tmp56_->segments;
		kkc_segment_list_first_segment (_tmp57_);
		_tmp58_ = state;
		_tmp58_->handler_type = KKC_TYPE_CONVERT_SENTENCE_STATE_HANDLER;
		result = TRUE;
		_g_free0 (output);
		_g_free0 (input);
		return result;
	}
	result = TRUE;
	return result;
}


static gboolean kkc_initial_state_handler_do_next_character (KkcInitialStateHandler* self, const gchar* command, KkcState* state, KkcKeyEvent* key) {
	gboolean result = FALSE;
	KkcState* _tmp0_ = NULL;
	KkcState* _tmp1_ = NULL;
	KkcRomKanaCharacterList* _tmp2_ = NULL;
	gint _tmp3_ = 0;
	gint _tmp4_ = 0;
	KkcState* _tmp5_ = NULL;
	gint _tmp6_ = 0;
	KkcState* _tmp7_ = NULL;
	KkcRomKanaCharacterList* _tmp8_ = NULL;
	gint _tmp9_ = 0;
	gint _tmp10_ = 0;
	g_return_val_if_fail (self != NULL, FALSE);
	g_return_val_if_fail (state != NULL, FALSE);
	g_return_val_if_fail (key != NULL, FALSE);
	_tmp0_ = state;
	kkc_state_finish_input_editing (_tmp0_);
	_tmp1_ = state;
	_tmp2_ = _tmp1_->input_characters;
	_tmp3_ = kkc_rom_kana_character_list_get_size (_tmp2_);
	_tmp4_ = _tmp3_;
	if (_tmp4_ == 0) {
		result = FALSE;
		return result;
	}
	_tmp5_ = state;
	_tmp6_ = _tmp5_->input_characters_cursor_pos;
	_tmp7_ = state;
	_tmp8_ = _tmp7_->input_characters;
	_tmp9_ = kkc_rom_kana_character_list_get_size (_tmp8_);
	_tmp10_ = _tmp9_;
	if (_tmp6_ == (_tmp10_ - 1)) {
		KkcState* _tmp11_ = NULL;
		_tmp11_ = state;
		_tmp11_->input_characters_cursor_pos = -1;
	} else {
		gboolean _tmp12_ = FALSE;
		KkcState* _tmp13_ = NULL;
		gint _tmp14_ = 0;
		_tmp13_ = state;
		_tmp14_ = _tmp13_->input_characters_cursor_pos;
		if (_tmp14_ >= 0) {
			KkcState* _tmp15_ = NULL;
			gint _tmp16_ = 0;
			KkcState* _tmp17_ = NULL;
			KkcRomKanaCharacterList* _tmp18_ = NULL;
			gint _tmp19_ = 0;
			gint _tmp20_ = 0;
			_tmp15_ = state;
			_tmp16_ = _tmp15_->input_characters_cursor_pos;
			_tmp17_ = state;
			_tmp18_ = _tmp17_->input_characters;
			_tmp19_ = kkc_rom_kana_character_list_get_size (_tmp18_);
			_tmp20_ = _tmp19_;
			_tmp12_ = _tmp16_ < (_tmp20_ - 1);
		} else {
			_tmp12_ = FALSE;
		}
		if (_tmp12_) {
			KkcState* _tmp21_ = NULL;
			gint _tmp22_ = 0;
			_tmp21_ = state;
			_tmp22_ = _tmp21_->input_characters_cursor_pos;
			_tmp21_->input_characters_cursor_pos = _tmp22_ + 1;
		}
	}
	result = TRUE;
	return result;
}


static gboolean kkc_initial_state_handler_do_previous_character (KkcInitialStateHandler* self, const gchar* command, KkcState* state, KkcKeyEvent* key) {
	gboolean result = FALSE;
	KkcState* _tmp0_ = NULL;
	KkcState* _tmp1_ = NULL;
	KkcRomKanaCharacterList* _tmp2_ = NULL;
	gint _tmp3_ = 0;
	gint _tmp4_ = 0;
	KkcState* _tmp5_ = NULL;
	gint _tmp6_ = 0;
	KkcState* _tmp13_ = NULL;
	gint _tmp14_ = 0;
	g_return_val_if_fail (self != NULL, FALSE);
	g_return_val_if_fail (state != NULL, FALSE);
	g_return_val_if_fail (key != NULL, FALSE);
	_tmp0_ = state;
	kkc_state_finish_input_editing (_tmp0_);
	_tmp1_ = state;
	_tmp2_ = _tmp1_->input_characters;
	_tmp3_ = kkc_rom_kana_character_list_get_size (_tmp2_);
	_tmp4_ = _tmp3_;
	if (_tmp4_ == 0) {
		result = FALSE;
		return result;
	}
	_tmp5_ = state;
	_tmp6_ = _tmp5_->input_characters_cursor_pos;
	if (_tmp6_ < 0) {
		KkcState* _tmp7_ = NULL;
		KkcState* _tmp8_ = NULL;
		KkcState* _tmp9_ = NULL;
		KkcRomKanaCharacterList* _tmp10_ = NULL;
		gint _tmp11_ = 0;
		gint _tmp12_ = 0;
		_tmp7_ = state;
		kkc_state_finish_input_editing (_tmp7_);
		_tmp8_ = state;
		_tmp9_ = state;
		_tmp10_ = _tmp9_->input_characters;
		_tmp11_ = kkc_rom_kana_character_list_get_size (_tmp10_);
		_tmp12_ = _tmp11_;
		_tmp8_->input_characters_cursor_pos = _tmp12_ - 1;
		result = TRUE;
		return result;
	}
	_tmp13_ = state;
	_tmp14_ = _tmp13_->input_characters_cursor_pos;
	if (_tmp14_ > 0) {
		KkcState* _tmp15_ = NULL;
		gint _tmp16_ = 0;
		_tmp15_ = state;
		_tmp16_ = _tmp15_->input_characters_cursor_pos;
		_tmp15_->input_characters_cursor_pos = _tmp16_ - 1;
	}
	result = TRUE;
	return result;
}


static gboolean kkc_initial_state_handler_do_first_character (KkcInitialStateHandler* self, const gchar* command, KkcState* state, KkcKeyEvent* key) {
	gboolean result = FALSE;
	KkcState* _tmp0_ = NULL;
	KkcState* _tmp1_ = NULL;
	KkcRomKanaCharacterList* _tmp2_ = NULL;
	gint _tmp3_ = 0;
	gint _tmp4_ = 0;
	KkcState* _tmp5_ = NULL;
	g_return_val_if_fail (self != NULL, FALSE);
	g_return_val_if_fail (state != NULL, FALSE);
	g_return_val_if_fail (key != NULL, FALSE);
	_tmp0_ = state;
	kkc_state_finish_input_editing (_tmp0_);
	_tmp1_ = state;
	_tmp2_ = _tmp1_->input_characters;
	_tmp3_ = kkc_rom_kana_character_list_get_size (_tmp2_);
	_tmp4_ = _tmp3_;
	if (_tmp4_ == 0) {
		result = FALSE;
		return result;
	}
	_tmp5_ = state;
	_tmp5_->input_characters_cursor_pos = 0;
	result = TRUE;
	return result;
}


static gboolean kkc_initial_state_handler_do_last_character (KkcInitialStateHandler* self, const gchar* command, KkcState* state, KkcKeyEvent* key) {
	gboolean result = FALSE;
	KkcState* _tmp0_ = NULL;
	KkcState* _tmp1_ = NULL;
	KkcRomKanaCharacterList* _tmp2_ = NULL;
	gint _tmp3_ = 0;
	gint _tmp4_ = 0;
	KkcState* _tmp5_ = NULL;
	KkcState* _tmp6_ = NULL;
	KkcRomKanaCharacterList* _tmp7_ = NULL;
	gint _tmp8_ = 0;
	gint _tmp9_ = 0;
	g_return_val_if_fail (self != NULL, FALSE);
	g_return_val_if_fail (state != NULL, FALSE);
	g_return_val_if_fail (key != NULL, FALSE);
	_tmp0_ = state;
	kkc_state_finish_input_editing (_tmp0_);
	_tmp1_ = state;
	_tmp2_ = _tmp1_->input_characters;
	_tmp3_ = kkc_rom_kana_character_list_get_size (_tmp2_);
	_tmp4_ = _tmp3_;
	if (_tmp4_ == 0) {
		result = FALSE;
		return result;
	}
	_tmp5_ = state;
	_tmp6_ = state;
	_tmp7_ = _tmp6_->input_characters;
	_tmp8_ = kkc_rom_kana_character_list_get_size (_tmp7_);
	_tmp9_ = _tmp8_;
	_tmp5_->input_characters_cursor_pos = _tmp9_ - 1;
	result = TRUE;
	return result;
}


static gpointer _g_object_ref0 (gpointer self) {
	return self ? g_object_ref (self) : NULL;
}


static gchar* g_unichar_to_string (gunichar self) {
	gchar* result = NULL;
	gchar* str = NULL;
	gchar* _tmp0_ = NULL;
	const gchar* _tmp1_ = NULL;
	_tmp0_ = g_new0 (gchar, 7);
	str = (gchar*) _tmp0_;
	_tmp1_ = str;
	g_unichar_to_utf8 (self, _tmp1_);
	result = str;
	return result;
}


static gboolean kkc_initial_state_handler_do_ (KkcInitialStateHandler* self, const gchar* command, KkcState* state, KkcKeyEvent* key) {
	gboolean result = FALSE;
	gboolean retval = FALSE;
	KkcState* _tmp0_ = NULL;
	const gchar* _tmp1_ = NULL;
	gboolean _tmp9_ = FALSE;
	KkcKeyEvent* _tmp10_ = NULL;
	KkcModifierType _tmp11_ = 0;
	KkcModifierType _tmp12_ = 0;
	gchar* last_input = NULL;
	KkcState* _tmp112_ = NULL;
	gchar* _tmp113_ = NULL;
	KkcState* _tmp114_ = NULL;
	gchar* input = NULL;
	KkcState* _tmp115_ = NULL;
	gchar* _tmp116_ = NULL;
	KkcState* _tmp117_ = NULL;
	GString* _tmp118_ = NULL;
	const gchar* _tmp119_ = NULL;
	KkcState* _tmp120_ = NULL;
	gboolean _tmp121_ = FALSE;
	gboolean _tmp122_ = FALSE;
	gboolean _tmp123_ = FALSE;
	g_return_val_if_fail (self != NULL, FALSE);
	g_return_val_if_fail (state != NULL, FALSE);
	g_return_val_if_fail (key != NULL, FALSE);
	retval = FALSE;
	_tmp0_ = state;
	_tmp1_ = _tmp0_->overriding_input;
	if (_tmp1_ != NULL) {
		KkcState* _tmp2_ = NULL;
		GString* _tmp3_ = NULL;
		KkcState* _tmp4_ = NULL;
		gchar* _tmp5_ = NULL;
		gchar* _tmp6_ = NULL;
		KkcState* _tmp7_ = NULL;
		KkcState* _tmp8_ = NULL;
		_tmp2_ = state;
		_tmp3_ = _tmp2_->output;
		_tmp4_ = state;
		_tmp5_ = kkc_state_get_input (_tmp4_);
		_tmp6_ = _tmp5_;
		g_string_append (_tmp3_, _tmp6_);
		_g_free0 (_tmp6_);
		_tmp7_ = state;
		_g_free0 (_tmp7_->overriding_input);
		_tmp7_->overriding_input = NULL;
		_tmp8_ = state;
		kkc_state_reset (_tmp8_);
		retval = TRUE;
	}
	_tmp10_ = key;
	_tmp11_ = kkc_key_event_get_modifiers (_tmp10_);
	_tmp12_ = _tmp11_;
	if (_tmp12_ == 0) {
		_tmp9_ = TRUE;
	} else {
		KkcKeyEvent* _tmp13_ = NULL;
		KkcModifierType _tmp14_ = 0;
		KkcModifierType _tmp15_ = 0;
		_tmp13_ = key;
		_tmp14_ = kkc_key_event_get_modifiers (_tmp13_);
		_tmp15_ = _tmp14_;
		_tmp9_ = _tmp15_ == KKC_MODIFIER_TYPE_SHIFT_MASK;
	}
	if (_tmp9_) {
		KkcState* _tmp16_ = NULL;
		KkcRomKanaConverter* _tmp17_ = NULL;
		KkcKeyEvent* _tmp18_ = NULL;
		gunichar _tmp19_ = 0U;
		gunichar _tmp20_ = 0U;
		gboolean _tmp21_ = FALSE;
		_tmp16_ = state;
		_tmp17_ = _tmp16_->rom_kana_converter;
		_tmp18_ = key;
		_tmp19_ = kkc_key_event_get_unicode (_tmp18_);
		_tmp20_ = _tmp19_;
		_tmp21_ = kkc_rom_kana_converter_is_valid (_tmp17_, _tmp20_);
		if (_tmp21_) {
			KkcState* _tmp22_ = NULL;
			KkcRomKanaConverter* _tmp23_ = NULL;
			KkcKeyEvent* _tmp24_ = NULL;
			gunichar _tmp25_ = 0U;
			gunichar _tmp26_ = 0U;
			KkcState* _tmp27_ = NULL;
			KkcRomKanaConverter* _tmp28_ = NULL;
			KkcRomKanaCharacterList* _tmp29_ = NULL;
			KkcRomKanaCharacterList* _tmp30_ = NULL;
			gint _tmp31_ = 0;
			gint _tmp32_ = 0;
			_tmp22_ = state;
			_tmp23_ = _tmp22_->rom_kana_converter;
			_tmp24_ = key;
			_tmp25_ = kkc_key_event_get_unicode (_tmp24_);
			_tmp26_ = _tmp25_;
			kkc_rom_kana_converter_append (_tmp23_, _tmp26_);
			_tmp27_ = state;
			_tmp28_ = _tmp27_->rom_kana_converter;
			_tmp29_ = kkc_rom_kana_converter_get_produced (_tmp28_);
			_tmp30_ = _tmp29_;
			_tmp31_ = kkc_rom_kana_character_list_get_size (_tmp30_);
			_tmp32_ = _tmp31_;
			if (_tmp32_ > 0) {
				KkcState* _tmp33_ = NULL;
				gint _tmp34_ = 0;
				KkcState* _tmp69_ = NULL;
				KkcRomKanaConverter* _tmp70_ = NULL;
				KkcRomKanaCharacterList* _tmp71_ = NULL;
				KkcRomKanaCharacterList* _tmp72_ = NULL;
				_tmp33_ = state;
				_tmp34_ = _tmp33_->input_characters_cursor_pos;
				if (_tmp34_ >= 0) {
					KkcState* _tmp35_ = NULL;
					KkcRomKanaCharacterList* _tmp36_ = NULL;
					KkcState* _tmp37_ = NULL;
					gint _tmp38_ = 0;
					KkcState* _tmp39_ = NULL;
					KkcRomKanaConverter* _tmp40_ = NULL;
					KkcRomKanaCharacterList* _tmp41_ = NULL;
					KkcRomKanaCharacterList* _tmp42_ = NULL;
					_tmp35_ = state;
					_tmp36_ = _tmp35_->input_characters;
					_tmp37_ = state;
					_tmp38_ = _tmp37_->input_characters_cursor_pos;
					_tmp39_ = state;
					_tmp40_ = _tmp39_->rom_kana_converter;
					_tmp41_ = kkc_rom_kana_converter_get_produced (_tmp40_);
					_tmp42_ = _tmp41_;
					kkc_rom_kana_character_list_insert_all (_tmp36_, _tmp38_, _tmp42_);
					{
						KkcRomKanaCharacterList* _c_list = NULL;
						KkcState* _tmp43_ = NULL;
						KkcRomKanaConverter* _tmp44_ = NULL;
						KkcRomKanaCharacterList* _tmp45_ = NULL;
						KkcRomKanaCharacterList* _tmp46_ = NULL;
						KkcRomKanaCharacterList* _tmp47_ = NULL;
						gint _c_size = 0;
						KkcRomKanaCharacterList* _tmp48_ = NULL;
						gint _tmp49_ = 0;
						gint _tmp50_ = 0;
						gint _c_index = 0;
						_tmp43_ = state;
						_tmp44_ = _tmp43_->rom_kana_converter;
						_tmp45_ = kkc_rom_kana_converter_get_produced (_tmp44_);
						_tmp46_ = _tmp45_;
						_tmp47_ = _g_object_ref0 (_tmp46_);
						_c_list = _tmp47_;
						_tmp48_ = _c_list;
						_tmp49_ = kkc_rom_kana_character_list_get_size (_tmp48_);
						_tmp50_ = _tmp49_;
						_c_size = _tmp50_;
						_c_index = -1;
						while (TRUE) {
							gint _tmp51_ = 0;
							gint _tmp52_ = 0;
							gint _tmp53_ = 0;
							KkcRomKanaCharacter c = {0};
							KkcRomKanaCharacterList* _tmp54_ = NULL;
							gint _tmp55_ = 0;
							KkcRomKanaCharacter _tmp56_ = {0};
							KkcState* _tmp57_ = NULL;
							KkcState* _tmp58_ = NULL;
							gint _tmp59_ = 0;
							KkcRomKanaCharacter _tmp60_ = {0};
							const gchar* _tmp61_ = NULL;
							gint _tmp62_ = 0;
							_tmp51_ = _c_index;
							_c_index = _tmp51_ + 1;
							_tmp52_ = _c_index;
							_tmp53_ = _c_size;
							if (!(_tmp52_ < _tmp53_)) {
								break;
							}
							_tmp54_ = _c_list;
							_tmp55_ = _c_index;
							kkc_rom_kana_character_list_get (_tmp54_, _tmp55_, &_tmp56_);
							c = _tmp56_;
							_tmp57_ = state;
							_tmp58_ = state;
							_tmp59_ = _tmp58_->input_characters_cursor_pos;
							_tmp60_ = c;
							_tmp61_ = _tmp60_.output;
							_tmp62_ = g_utf8_strlen (_tmp61_, (gssize) (-1));
							_tmp58_->input_characters_cursor_pos = _tmp59_ + _tmp62_;
							kkc_rom_kana_character_destroy (&c);
						}
						_g_object_unref0 (_c_list);
					}
				} else {
					KkcState* _tmp63_ = NULL;
					KkcRomKanaCharacterList* _tmp64_ = NULL;
					KkcState* _tmp65_ = NULL;
					KkcRomKanaConverter* _tmp66_ = NULL;
					KkcRomKanaCharacterList* _tmp67_ = NULL;
					KkcRomKanaCharacterList* _tmp68_ = NULL;
					_tmp63_ = state;
					_tmp64_ = _tmp63_->input_characters;
					_tmp65_ = state;
					_tmp66_ = _tmp65_->rom_kana_converter;
					_tmp67_ = kkc_rom_kana_converter_get_produced (_tmp66_);
					_tmp68_ = _tmp67_;
					kkc_rom_kana_character_list_add_all (_tmp64_, _tmp68_);
				}
				_tmp69_ = state;
				_tmp70_ = _tmp69_->rom_kana_converter;
				_tmp71_ = kkc_rom_kana_converter_get_produced (_tmp70_);
				_tmp72_ = _tmp71_;
				kkc_rom_kana_character_list_clear (_tmp72_);
			}
			result = TRUE;
			return result;
		} else {
			gboolean _tmp73_ = FALSE;
			KkcKeyEvent* _tmp74_ = NULL;
			gunichar _tmp75_ = 0U;
			gunichar _tmp76_ = 0U;
			_tmp74_ = key;
			_tmp75_ = kkc_key_event_get_unicode (_tmp74_);
			_tmp76_ = _tmp75_;
			if (((gunichar) 0x21) <= _tmp76_) {
				KkcKeyEvent* _tmp77_ = NULL;
				gunichar _tmp78_ = 0U;
				gunichar _tmp79_ = 0U;
				_tmp77_ = key;
				_tmp78_ = kkc_key_event_get_unicode (_tmp77_);
				_tmp79_ = _tmp78_;
				_tmp73_ = _tmp79_ <= ((gunichar) 0x7E);
			} else {
				_tmp73_ = FALSE;
			}
			if (_tmp73_) {
				KkcState* _tmp80_ = NULL;
				KkcRomKanaCharacter c = {0};
				KkcKeyEvent* _tmp81_ = NULL;
				gunichar _tmp82_ = 0U;
				gunichar _tmp83_ = 0U;
				gchar* _tmp84_ = NULL;
				gchar* _tmp85_ = NULL;
				KkcState* _tmp86_ = NULL;
				KkcInputMode _tmp87_ = 0;
				KkcInputMode _tmp88_ = 0;
				gchar* _tmp89_ = NULL;
				KkcKeyEvent* _tmp90_ = NULL;
				gunichar _tmp91_ = 0U;
				gunichar _tmp92_ = 0U;
				gchar* _tmp93_ = NULL;
				KkcRomKanaCharacter _tmp94_ = {0};
				KkcRomKanaCharacter _tmp95_ = {0};
				KkcState* _tmp96_ = NULL;
				gint _tmp97_ = 0;
				KkcState* _tmp108_ = NULL;
				KkcRomKanaConverter* _tmp109_ = NULL;
				KkcRomKanaCharacterList* _tmp110_ = NULL;
				KkcRomKanaCharacterList* _tmp111_ = NULL;
				_tmp80_ = state;
				kkc_state_finish_input_editing (_tmp80_);
				_tmp81_ = key;
				_tmp82_ = kkc_key_event_get_unicode (_tmp81_);
				_tmp83_ = _tmp82_;
				_tmp84_ = g_unichar_to_string (_tmp83_);
				_tmp85_ = _tmp84_;
				_tmp86_ = state;
				_tmp87_ = kkc_state_get_input_mode (_tmp86_);
				_tmp88_ = _tmp87_;
				_tmp89_ = kkc_rom_kana_utils_convert_by_kana_mode (_tmp85_, (KkcKanaMode) _tmp88_);
				_tmp90_ = key;
				_tmp91_ = kkc_key_event_get_unicode (_tmp90_);
				_tmp92_ = _tmp91_;
				_tmp93_ = g_unichar_to_string (_tmp92_);
				memset (&_tmp94_, 0, sizeof (KkcRomKanaCharacter));
				_g_free0 (_tmp94_.output);
				_tmp94_.output = _tmp89_;
				_g_free0 (_tmp94_.input);
				_tmp94_.input = _tmp93_;
				_tmp95_ = _tmp94_;
				_g_free0 (_tmp85_);
				c = _tmp95_;
				_tmp96_ = state;
				_tmp97_ = _tmp96_->input_characters_cursor_pos;
				if (_tmp97_ >= 0) {
					KkcState* _tmp98_ = NULL;
					KkcRomKanaCharacterList* _tmp99_ = NULL;
					KkcState* _tmp100_ = NULL;
					gint _tmp101_ = 0;
					KkcRomKanaCharacter _tmp102_ = {0};
					KkcState* _tmp103_ = NULL;
					gint _tmp104_ = 0;
					_tmp98_ = state;
					_tmp99_ = _tmp98_->input_characters;
					_tmp100_ = state;
					_tmp101_ = _tmp100_->input_characters_cursor_pos;
					_tmp102_ = c;
					kkc_rom_kana_character_list_insert (_tmp99_, _tmp101_, &_tmp102_);
					_tmp103_ = state;
					_tmp104_ = _tmp103_->input_characters_cursor_pos;
					_tmp103_->input_characters_cursor_pos = _tmp104_ + 1;
				} else {
					KkcState* _tmp105_ = NULL;
					KkcRomKanaCharacterList* _tmp106_ = NULL;
					KkcRomKanaCharacter _tmp107_ = {0};
					_tmp105_ = state;
					_tmp106_ = _tmp105_->input_characters;
					_tmp107_ = c;
					kkc_rom_kana_character_list_add (_tmp106_, &_tmp107_);
				}
				_tmp108_ = state;
				_tmp109_ = _tmp108_->rom_kana_converter;
				_tmp110_ = kkc_rom_kana_converter_get_produced (_tmp109_);
				_tmp111_ = _tmp110_;
				kkc_rom_kana_character_list_clear (_tmp111_);
				result = TRUE;
				kkc_rom_kana_character_destroy (&c);
				return result;
			}
		}
	}
	_tmp112_ = state;
	_tmp113_ = kkc_state_get_input (_tmp112_);
	last_input = _tmp113_;
	_tmp114_ = state;
	kkc_state_finish_input_editing (_tmp114_);
	_tmp115_ = state;
	_tmp116_ = kkc_state_get_input (_tmp115_);
	input = _tmp116_;
	_tmp117_ = state;
	_tmp118_ = _tmp117_->output;
	_tmp119_ = input;
	g_string_append (_tmp118_, _tmp119_);
	_tmp120_ = state;
	kkc_state_reset (_tmp120_);
	_tmp123_ = retval;
	if (_tmp123_) {
		_tmp122_ = TRUE;
	} else {
		const gchar* _tmp124_ = NULL;
		gint _tmp125_ = 0;
		gint _tmp126_ = 0;
		_tmp124_ = input;
		_tmp125_ = strlen (_tmp124_);
		_tmp126_ = _tmp125_;
		_tmp122_ = _tmp126_ > 0;
	}
	if (_tmp122_) {
		_tmp121_ = TRUE;
	} else {
		const gchar* _tmp127_ = NULL;
		const gchar* _tmp128_ = NULL;
		_tmp127_ = last_input;
		_tmp128_ = input;
		_tmp121_ = g_strcmp0 (_tmp127_, _tmp128_) != 0;
	}
	result = _tmp121_;
	_g_free0 (input);
	_g_free0 (last_input);
	return result;
}


static gchar* string_slice (const gchar* self, glong start, glong end) {
	gchar* result = NULL;
	glong string_length = 0L;
	gint _tmp0_ = 0;
	gint _tmp1_ = 0;
	glong _tmp2_ = 0L;
	glong _tmp5_ = 0L;
	gboolean _tmp8_ = FALSE;
	glong _tmp9_ = 0L;
	gboolean _tmp12_ = FALSE;
	glong _tmp13_ = 0L;
	glong _tmp16_ = 0L;
	glong _tmp17_ = 0L;
	glong _tmp18_ = 0L;
	glong _tmp19_ = 0L;
	glong _tmp20_ = 0L;
	gchar* _tmp21_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = strlen (self);
	_tmp1_ = _tmp0_;
	string_length = (glong) _tmp1_;
	_tmp2_ = start;
	if (_tmp2_ < ((glong) 0)) {
		glong _tmp3_ = 0L;
		glong _tmp4_ = 0L;
		_tmp3_ = string_length;
		_tmp4_ = start;
		start = _tmp3_ + _tmp4_;
	}
	_tmp5_ = end;
	if (_tmp5_ < ((glong) 0)) {
		glong _tmp6_ = 0L;
		glong _tmp7_ = 0L;
		_tmp6_ = string_length;
		_tmp7_ = end;
		end = _tmp6_ + _tmp7_;
	}
	_tmp9_ = start;
	if (_tmp9_ >= ((glong) 0)) {
		glong _tmp10_ = 0L;
		glong _tmp11_ = 0L;
		_tmp10_ = start;
		_tmp11_ = string_length;
		_tmp8_ = _tmp10_ <= _tmp11_;
	} else {
		_tmp8_ = FALSE;
	}
	g_return_val_if_fail (_tmp8_, NULL);
	_tmp13_ = end;
	if (_tmp13_ >= ((glong) 0)) {
		glong _tmp14_ = 0L;
		glong _tmp15_ = 0L;
		_tmp14_ = end;
		_tmp15_ = string_length;
		_tmp12_ = _tmp14_ <= _tmp15_;
	} else {
		_tmp12_ = FALSE;
	}
	g_return_val_if_fail (_tmp12_, NULL);
	_tmp16_ = start;
	_tmp17_ = end;
	g_return_val_if_fail (_tmp16_ <= _tmp17_, NULL);
	_tmp18_ = start;
	_tmp19_ = end;
	_tmp20_ = start;
	_tmp21_ = g_strndup (((gchar*) self) + _tmp18_, (gsize) (_tmp19_ - _tmp20_));
	result = _tmp21_;
	return result;
}


static GEnumValue* _g_enum_value_dup (GEnumValue* self) {
	GEnumValue* dup;
	dup = g_new0 (GEnumValue, 1);
	memcpy (dup, self, sizeof (GEnumValue));
	return dup;
}


static gpointer __g_enum_value_dup0 (gpointer self) {
	return self ? _g_enum_value_dup (self) : NULL;
}


static gboolean kkc_initial_state_handler_real_process_key_event (KkcStateHandler* base, KkcState* state, KkcKeyEvent* key) {
	KkcInitialStateHandler * self;
	gboolean result = FALSE;
	gchar* command = NULL;
	KkcState* _tmp0_ = NULL;
	KkcKeyEvent* _tmp1_ = NULL;
	gchar* _tmp2_ = NULL;
	KkcState* _tmp3_ = NULL;
	KkcKeyEvent* _tmp4_ = NULL;
	gboolean _tmp34_ = FALSE;
	const gchar* _tmp35_ = NULL;
	KkcState* _tmp67_ = NULL;
	KkcInputMode _tmp68_ = 0;
	KkcInputMode _tmp69_ = 0;
	gboolean _tmp70_ = FALSE;
	KkcState* _tmp71_ = NULL;
	gboolean _tmp72_ = FALSE;
	KkcState* _tmp94_ = NULL;
	KkcKeyEvent* _tmp95_ = NULL;
	gboolean _tmp96_ = FALSE;
	self = (KkcInitialStateHandler*) base;
	g_return_val_if_fail (state != NULL, FALSE);
	g_return_val_if_fail (key != NULL, FALSE);
	_tmp0_ = state;
	_tmp1_ = key;
	_tmp2_ = kkc_state_lookup_key (_tmp0_, _tmp1_);
	command = _tmp2_;
	_tmp3_ = state;
	_tmp4_ = _tmp3_->last_command_key;
	if (_tmp4_ != NULL) {
		gchar* last_command = NULL;
		KkcState* _tmp5_ = NULL;
		KkcState* _tmp6_ = NULL;
		KkcKeyEvent* _tmp7_ = NULL;
		gchar* _tmp8_ = NULL;
		gboolean _tmp9_ = FALSE;
		const gchar* _tmp10_ = NULL;
		_tmp5_ = state;
		_tmp6_ = state;
		_tmp7_ = _tmp6_->last_command_key;
		_tmp8_ = kkc_state_lookup_key (_tmp5_, _tmp7_);
		last_command = _tmp8_;
		_tmp10_ = last_command;
		if (g_strcmp0 (_tmp10_, "complete") == 0) {
			const gchar* _tmp11_ = NULL;
			_tmp11_ = command;
			_tmp9_ = g_strcmp0 (_tmp11_, "complete") != 0;
		} else {
			_tmp9_ = FALSE;
		}
		if (_tmp9_) {
			KkcState* _tmp12_ = NULL;
			const gchar* _tmp13_ = NULL;
			KkcState* _tmp32_ = NULL;
			KkcState* _tmp33_ = NULL;
			_tmp12_ = state;
			_tmp13_ = _tmp12_->overriding_input;
			if (_tmp13_ != NULL) {
				GString* builder = NULL;
				GString* _tmp14_ = NULL;
				GString* _tmp15_ = NULL;
				KkcState* _tmp16_ = NULL;
				KkcRomKanaCharacterList* _tmp17_ = NULL;
				gchar* _tmp18_ = NULL;
				gchar* _tmp19_ = NULL;
				KkcState* _tmp20_ = NULL;
				KkcRomKanaCharacterList* _tmp21_ = NULL;
				KkcState* _tmp22_ = NULL;
				KkcRomKanaCharacterList* _tmp23_ = NULL;
				KkcState* _tmp24_ = NULL;
				const gchar* _tmp25_ = NULL;
				gchar* _tmp26_ = NULL;
				GString* _tmp27_ = NULL;
				const gchar* _tmp28_ = NULL;
				gchar* _tmp29_ = NULL;
				KkcRomKanaCharacter _tmp30_ = {0};
				KkcRomKanaCharacter _tmp31_ = {0};
				_tmp14_ = g_string_new ("");
				builder = _tmp14_;
				_tmp15_ = builder;
				_tmp16_ = state;
				_tmp17_ = _tmp16_->input_characters;
				_tmp18_ = kkc_rom_kana_character_list_get_input (_tmp17_);
				_tmp19_ = _tmp18_;
				g_string_append (_tmp15_, _tmp19_);
				_g_free0 (_tmp19_);
				_tmp20_ = state;
				_tmp21_ = _tmp20_->input_characters;
				kkc_rom_kana_character_list_clear (_tmp21_);
				_tmp22_ = state;
				_tmp23_ = _tmp22_->input_characters;
				_tmp24_ = state;
				_tmp25_ = _tmp24_->overriding_input;
				_tmp26_ = g_strdup (_tmp25_);
				_tmp27_ = builder;
				_tmp28_ = _tmp27_->str;
				_tmp29_ = g_strdup (_tmp28_);
				memset (&_tmp30_, 0, sizeof (KkcRomKanaCharacter));
				_g_free0 (_tmp30_.output);
				_tmp30_.output = _tmp26_;
				_g_free0 (_tmp30_.input);
				_tmp30_.input = _tmp29_;
				_tmp31_ = _tmp30_;
				kkc_rom_kana_character_list_add (_tmp23_, &_tmp31_);
				kkc_rom_kana_character_destroy (&_tmp31_);
				_g_string_free0 (builder);
			}
			_tmp32_ = state;
			_g_free0 (_tmp32_->overriding_input);
			_tmp32_->overriding_input = NULL;
			_tmp33_ = state;
			_g_object_unref0 (_tmp33_->completion_iterator);
			_tmp33_->completion_iterator = NULL;
		}
		_g_free0 (last_command);
	}
	_tmp35_ = command;
	if (_tmp35_ != NULL) {
		const gchar* _tmp36_ = NULL;
		gboolean _tmp37_ = FALSE;
		_tmp36_ = command;
		_tmp37_ = g_str_has_prefix (_tmp36_, "set-input-mode-");
		_tmp34_ = _tmp37_;
	} else {
		_tmp34_ = FALSE;
	}
	if (_tmp34_) {
		GEnumClass* enum_class = NULL;
		GTypeClass* _tmp38_ = NULL;
		GEnumValue* enum_value = NULL;
		GEnumClass* _tmp39_ = NULL;
		const gchar* _tmp40_ = NULL;
		gint _tmp41_ = 0;
		gint _tmp42_ = 0;
		const gchar* _tmp43_ = NULL;
		gint _tmp44_ = 0;
		gint _tmp45_ = 0;
		gchar* _tmp46_ = NULL;
		gchar* _tmp47_ = NULL;
		GEnumValue* _tmp48_ = NULL;
		GEnumValue* _tmp49_ = NULL;
		GEnumValue* _tmp50_ = NULL;
		GEnumValue* _tmp51_ = NULL;
		_tmp38_ = g_type_class_ref (KKC_TYPE_INPUT_MODE);
		enum_class = (GEnumClass*) _tmp38_;
		_tmp39_ = enum_class;
		_tmp40_ = command;
		_tmp41_ = strlen ("set-input-mode-");
		_tmp42_ = _tmp41_;
		_tmp43_ = command;
		_tmp44_ = strlen (_tmp43_);
		_tmp45_ = _tmp44_;
		_tmp46_ = string_slice (_tmp40_, (glong) _tmp42_, (glong) _tmp45_);
		_tmp47_ = _tmp46_;
		_tmp48_ = g_enum_get_value_by_nick (_tmp39_, _tmp47_);
		_tmp49_ = __g_enum_value_dup0 (_tmp48_);
		_tmp50_ = _tmp49_;
		_g_free0 (_tmp47_);
		enum_value = _tmp50_;
		_tmp51_ = enum_value;
		if (_tmp51_ != NULL) {
			KkcState* _tmp52_ = NULL;
			GString* _tmp53_ = NULL;
			KkcState* _tmp54_ = NULL;
			KkcState* _tmp55_ = NULL;
			GEnumValue* _tmp56_ = NULL;
			gint _tmp57_ = 0;
			KkcState* _tmp58_ = NULL;
			KkcInputMode _tmp59_ = 0;
			KkcInputMode _tmp60_ = 0;
			_tmp52_ = state;
			_tmp53_ = _tmp52_->selection;
			g_string_erase (_tmp53_, (gssize) 0, (gssize) (-1));
			_tmp54_ = state;
			kkc_state_finish_input_editing (_tmp54_);
			_tmp55_ = state;
			_tmp56_ = enum_value;
			_tmp57_ = (*_tmp56_).value;
			kkc_state_set_input_mode (_tmp55_, (KkcInputMode) _tmp57_);
			_tmp58_ = state;
			_tmp59_ = kkc_state_get_input_mode (_tmp58_);
			_tmp60_ = _tmp59_;
			if (_tmp60_ == KKC_INPUT_MODE_DIRECT) {
				gchar* input = NULL;
				KkcState* _tmp61_ = NULL;
				gchar* _tmp62_ = NULL;
				KkcState* _tmp63_ = NULL;
				GString* _tmp64_ = NULL;
				const gchar* _tmp65_ = NULL;
				KkcState* _tmp66_ = NULL;
				_tmp61_ = state;
				_tmp62_ = kkc_state_get_input (_tmp61_);
				input = _tmp62_;
				_tmp63_ = state;
				_tmp64_ = _tmp63_->output;
				_tmp65_ = input;
				g_string_append (_tmp64_, _tmp65_);
				_tmp66_ = state;
				kkc_state_reset (_tmp66_);
				_g_free0 (input);
			}
			result = TRUE;
			_g_free0 (enum_value);
			_g_type_class_unref0 (enum_class);
			_g_free0 (command);
			return result;
		}
		_g_free0 (enum_value);
		_g_type_class_unref0 (enum_class);
	}
	_tmp67_ = state;
	_tmp68_ = kkc_state_get_input_mode (_tmp67_);
	_tmp69_ = _tmp68_;
	if (_tmp69_ == KKC_INPUT_MODE_DIRECT) {
		result = FALSE;
		_g_free0 (command);
		return result;
	}
	_tmp71_ = state;
	_tmp72_ = _tmp71_->quoted;
	if (_tmp72_) {
		gboolean _tmp73_ = FALSE;
		KkcKeyEvent* _tmp74_ = NULL;
		KkcModifierType _tmp75_ = 0;
		KkcModifierType _tmp76_ = 0;
		_tmp74_ = key;
		_tmp75_ = kkc_key_event_get_modifiers (_tmp74_);
		_tmp76_ = _tmp75_;
		if (_tmp76_ == 0) {
			_tmp73_ = TRUE;
		} else {
			KkcKeyEvent* _tmp77_ = NULL;
			KkcModifierType _tmp78_ = 0;
			KkcModifierType _tmp79_ = 0;
			_tmp77_ = key;
			_tmp78_ = kkc_key_event_get_modifiers (_tmp77_);
			_tmp79_ = _tmp78_;
			_tmp73_ = _tmp79_ == KKC_MODIFIER_TYPE_SHIFT_MASK;
		}
		_tmp70_ = _tmp73_;
	} else {
		_tmp70_ = FALSE;
	}
	if (_tmp70_) {
		KkcState* _tmp80_ = NULL;
		KkcState* _tmp81_ = NULL;
		KkcRomKanaCharacterList* _tmp82_ = NULL;
		KkcKeyEvent* _tmp83_ = NULL;
		gunichar _tmp84_ = 0U;
		gunichar _tmp85_ = 0U;
		gchar* _tmp86_ = NULL;
		KkcKeyEvent* _tmp87_ = NULL;
		gunichar _tmp88_ = 0U;
		gunichar _tmp89_ = 0U;
		gchar* _tmp90_ = NULL;
		KkcRomKanaCharacter _tmp91_ = {0};
		KkcRomKanaCharacter _tmp92_ = {0};
		KkcState* _tmp93_ = NULL;
		_tmp80_ = state;
		kkc_state_finish_input_editing (_tmp80_);
		_tmp81_ = state;
		_tmp82_ = _tmp81_->input_characters;
		_tmp83_ = key;
		_tmp84_ = kkc_key_event_get_unicode (_tmp83_);
		_tmp85_ = _tmp84_;
		_tmp86_ = g_unichar_to_string (_tmp85_);
		_tmp87_ = key;
		_tmp88_ = kkc_key_event_get_unicode (_tmp87_);
		_tmp89_ = _tmp88_;
		_tmp90_ = g_unichar_to_string (_tmp89_);
		memset (&_tmp91_, 0, sizeof (KkcRomKanaCharacter));
		_g_free0 (_tmp91_.output);
		_tmp91_.output = _tmp86_;
		_g_free0 (_tmp91_.input);
		_tmp91_.input = _tmp90_;
		_tmp92_ = _tmp91_;
		kkc_rom_kana_character_list_add (_tmp82_, &_tmp92_);
		kkc_rom_kana_character_destroy (&_tmp92_);
		_tmp93_ = state;
		_tmp93_->quoted = FALSE;
		result = TRUE;
		_g_free0 (command);
		return result;
	}
	_tmp94_ = state;
	_tmp95_ = key;
	_tmp96_ = kkc_state_handler_dispatch_command ((KkcStateHandler*) self, _tmp94_, _tmp95_);
	result = _tmp96_;
	_g_free0 (command);
	return result;
}


KkcInitialStateHandler* kkc_initial_state_handler_construct (GType object_type) {
	KkcInitialStateHandler * self = NULL;
	self = (KkcInitialStateHandler*) kkc_state_handler_construct (object_type);
	return self;
}


KkcInitialStateHandler* kkc_initial_state_handler_new (void) {
	return kkc_initial_state_handler_construct (KKC_TYPE_INITIAL_STATE_HANDLER);
}


static gboolean _kkc_initial_state_handler_do_abort_kkc_command_callback (const gchar* command, KkcState* state, KkcKeyEvent* key, gpointer self) {
	gboolean result;
	result = kkc_initial_state_handler_do_abort ((KkcInitialStateHandler*) self, command, state, key);
	return result;
}


static gboolean _kkc_initial_state_handler_do_complete_kkc_command_callback (const gchar* command, KkcState* state, KkcKeyEvent* key, gpointer self) {
	gboolean result;
	result = kkc_initial_state_handler_do_complete ((KkcInitialStateHandler*) self, command, state, key);
	return result;
}


static gboolean _kkc_initial_state_handler_do_delete_kkc_command_callback (const gchar* command, KkcState* state, KkcKeyEvent* key, gpointer self) {
	gboolean result;
	result = kkc_initial_state_handler_do_delete ((KkcInitialStateHandler*) self, command, state, key);
	return result;
}


static gboolean _kkc_initial_state_handler_do_delete_forward_kkc_command_callback (const gchar* command, KkcState* state, KkcKeyEvent* key, gpointer self) {
	gboolean result;
	result = kkc_initial_state_handler_do_delete_forward ((KkcInitialStateHandler*) self, command, state, key);
	return result;
}


static gboolean _kkc_initial_state_handler_do_next_candidate_kkc_command_callback (const gchar* command, KkcState* state, KkcKeyEvent* key, gpointer self) {
	gboolean result;
	result = kkc_initial_state_handler_do_next_candidate ((KkcInitialStateHandler*) self, command, state, key);
	return result;
}


static gboolean _kkc_initial_state_handler_do_next_character_kkc_command_callback (const gchar* command, KkcState* state, KkcKeyEvent* key, gpointer self) {
	gboolean result;
	result = kkc_initial_state_handler_do_next_character ((KkcInitialStateHandler*) self, command, state, key);
	return result;
}


static gboolean _kkc_initial_state_handler_do_previous_character_kkc_command_callback (const gchar* command, KkcState* state, KkcKeyEvent* key, gpointer self) {
	gboolean result;
	result = kkc_initial_state_handler_do_previous_character ((KkcInitialStateHandler*) self, command, state, key);
	return result;
}


static gboolean _kkc_initial_state_handler_do_first_character_kkc_command_callback (const gchar* command, KkcState* state, KkcKeyEvent* key, gpointer self) {
	gboolean result;
	result = kkc_initial_state_handler_do_first_character ((KkcInitialStateHandler*) self, command, state, key);
	return result;
}


static gboolean _kkc_initial_state_handler_do_last_character_kkc_command_callback (const gchar* command, KkcState* state, KkcKeyEvent* key, gpointer self) {
	gboolean result;
	result = kkc_initial_state_handler_do_last_character ((KkcInitialStateHandler*) self, command, state, key);
	return result;
}


static gboolean _kkc_initial_state_handler_do_quote_kkc_command_callback (const gchar* command, KkcState* state, KkcKeyEvent* key, gpointer self) {
	gboolean result;
	result = kkc_initial_state_handler_do_quote ((KkcInitialStateHandler*) self, command, state, key);
	return result;
}


static gboolean _kkc_initial_state_handler_do_register_kkc_command_callback (const gchar* command, KkcState* state, KkcKeyEvent* key, gpointer self) {
	gboolean result;
	result = kkc_initial_state_handler_do_register ((KkcInitialStateHandler*) self, command, state, key);
	return result;
}


static gboolean _kkc_initial_state_handler_do__kkc_command_callback (const gchar* command, KkcState* state, KkcKeyEvent* key, gpointer self) {
	gboolean result;
	result = kkc_initial_state_handler_do_ ((KkcInitialStateHandler*) self, command, state, key);
	return result;
}


static GObject * kkc_initial_state_handler_constructor (GType type, guint n_construct_properties, GObjectConstructParam * construct_properties) {
	GObject * obj;
	GObjectClass * parent_class;
	KkcInitialStateHandler * self;
	GEnumClass* enum_class = NULL;
	GTypeClass* _tmp0_ = NULL;
	parent_class = G_OBJECT_CLASS (kkc_initial_state_handler_parent_class);
	obj = parent_class->constructor (type, n_construct_properties, construct_properties);
	self = G_TYPE_CHECK_INSTANCE_CAST (obj, KKC_TYPE_INITIAL_STATE_HANDLER, KkcInitialStateHandler);
	_tmp0_ = g_type_class_ref (KKC_TYPE_KANA_MODE);
	enum_class = (GEnumClass*) _tmp0_;
	{
		gint i = 0;
		GEnumClass* _tmp1_ = NULL;
		gint _tmp2_ = 0;
		_tmp1_ = enum_class;
		_tmp2_ = _tmp1_->minimum;
		i = _tmp2_;
		{
			gboolean _tmp3_ = FALSE;
			_tmp3_ = TRUE;
			while (TRUE) {
				gint _tmp5_ = 0;
				GEnumClass* _tmp6_ = NULL;
				gint _tmp7_ = 0;
				GEnumValue* enum_value = NULL;
				GEnumClass* _tmp8_ = NULL;
				gint _tmp9_ = 0;
				GEnumValue* _tmp10_ = NULL;
				GEnumValue* _tmp11_ = NULL;
				GEnumValue* _tmp12_ = NULL;
				if (!_tmp3_) {
					gint _tmp4_ = 0;
					_tmp4_ = i;
					i = _tmp4_ + 1;
				}
				_tmp3_ = FALSE;
				_tmp5_ = i;
				_tmp6_ = enum_class;
				_tmp7_ = _tmp6_->maximum;
				if (!(_tmp5_ <= _tmp7_)) {
					break;
				}
				_tmp8_ = enum_class;
				_tmp9_ = i;
				_tmp10_ = g_enum_get_value (_tmp8_, _tmp9_);
				_tmp11_ = __g_enum_value_dup0 (_tmp10_);
				enum_value = _tmp11_;
				_tmp12_ = enum_value;
				if (_tmp12_ != NULL) {
					GEnumValue* _tmp13_ = NULL;
					const gchar* _tmp14_ = NULL;
					gchar* _tmp15_ = NULL;
					gchar* _tmp16_ = NULL;
					GEnumValue* _tmp17_ = NULL;
					gint _tmp18_ = 0;
					KkcInitialStateHandlerConvertCommandHandler* _tmp19_ = NULL;
					KkcInitialStateHandlerConvertCommandHandler* _tmp20_ = NULL;
					_tmp13_ = enum_value;
					_tmp14_ = (*_tmp13_).value_nick;
					_tmp15_ = g_strconcat ("convert-", _tmp14_, NULL);
					_tmp16_ = _tmp15_;
					_tmp17_ = enum_value;
					_tmp18_ = (*_tmp17_).value;
					_tmp19_ = kkc_initial_state_handler_convert_command_handler_new ((KkcKanaMode) _tmp18_);
					_tmp20_ = _tmp19_;
					kkc_state_handler_register_command_handler ((KkcStateHandler*) self, _tmp16_, (KkcCommandHandler*) _tmp20_);
					_g_object_unref0 (_tmp20_);
					_g_free0 (_tmp16_);
				}
				_g_free0 (enum_value);
			}
		}
	}
	kkc_state_handler_register_command_callback ((KkcStateHandler*) self, "abort", _kkc_initial_state_handler_do_abort_kkc_command_callback, self);
	kkc_state_handler_register_command_callback ((KkcStateHandler*) self, "complete", _kkc_initial_state_handler_do_complete_kkc_command_callback, self);
	kkc_state_handler_register_command_callback ((KkcStateHandler*) self, "delete", _kkc_initial_state_handler_do_delete_kkc_command_callback, self);
	kkc_state_handler_register_command_callback ((KkcStateHandler*) self, "delete-forward", _kkc_initial_state_handler_do_delete_forward_kkc_command_callback, self);
	kkc_state_handler_register_command_callback ((KkcStateHandler*) self, "next-candidate", _kkc_initial_state_handler_do_next_candidate_kkc_command_callback, self);
	kkc_state_handler_register_command_callback ((KkcStateHandler*) self, "next-segment", _kkc_initial_state_handler_do_next_character_kkc_command_callback, self);
	kkc_state_handler_register_command_callback ((KkcStateHandler*) self, "previous-segment", _kkc_initial_state_handler_do_previous_character_kkc_command_callback, self);
	kkc_state_handler_register_command_callback ((KkcStateHandler*) self, "first-segment", _kkc_initial_state_handler_do_first_character_kkc_command_callback, self);
	kkc_state_handler_register_command_callback ((KkcStateHandler*) self, "last-segment", _kkc_initial_state_handler_do_last_character_kkc_command_callback, self);
	kkc_state_handler_register_command_callback ((KkcStateHandler*) self, "quote", _kkc_initial_state_handler_do_quote_kkc_command_callback, self);
	kkc_state_handler_register_command_callback ((KkcStateHandler*) self, "register", _kkc_initial_state_handler_do_register_kkc_command_callback, self);
	kkc_state_handler_register_command_callback ((KkcStateHandler*) self, NULL, _kkc_initial_state_handler_do__kkc_command_callback, self);
	_g_type_class_unref0 (enum_class);
	return obj;
}


static KkcInitialStateHandlerConvertCommandHandler* kkc_initial_state_handler_convert_command_handler_construct (GType object_type, KkcKanaMode mode) {
	KkcInitialStateHandlerConvertCommandHandler * self = NULL;
	KkcKanaMode _tmp0_ = 0;
	self = (KkcInitialStateHandlerConvertCommandHandler*) g_object_new (object_type, NULL);
	_tmp0_ = mode;
	self->priv->mode = _tmp0_;
	return self;
}


static KkcInitialStateHandlerConvertCommandHandler* kkc_initial_state_handler_convert_command_handler_new (KkcKanaMode mode) {
	return kkc_initial_state_handler_convert_command_handler_construct (KKC_INITIAL_STATE_HANDLER_TYPE_CONVERT_COMMAND_HANDLER, mode);
}


static gboolean kkc_initial_state_handler_convert_command_handler_real_call (KkcCommandHandler* base, const gchar* command, KkcState* state, KkcKeyEvent* key) {
	KkcInitialStateHandlerConvertCommandHandler * self;
	gboolean result = FALSE;
	KkcState* _tmp0_ = NULL;
	KkcState* _tmp1_ = NULL;
	KkcRomKanaCharacterList* _tmp2_ = NULL;
	gint _tmp3_ = 0;
	gint _tmp4_ = 0;
	self = (KkcInitialStateHandlerConvertCommandHandler*) base;
	g_return_val_if_fail (state != NULL, FALSE);
	g_return_val_if_fail (key != NULL, FALSE);
	_tmp0_ = state;
	kkc_state_finish_input_editing (_tmp0_);
	_tmp1_ = state;
	_tmp2_ = _tmp1_->input_characters;
	_tmp3_ = kkc_rom_kana_character_list_get_size (_tmp2_);
	_tmp4_ = _tmp3_;
	if (_tmp4_ > 0) {
		KkcState* _tmp5_ = NULL;
		GString* _tmp6_ = NULL;
		KkcState* _tmp7_ = NULL;
		KkcState* _tmp8_ = NULL;
		KkcState* _tmp9_ = NULL;
		KkcRomKanaCharacterList* _tmp10_ = NULL;
		KkcKanaMode _tmp11_ = 0;
		gchar* _tmp12_ = NULL;
		_tmp5_ = state;
		_tmp6_ = _tmp5_->selection;
		g_string_erase (_tmp6_, (gssize) 0, (gssize) (-1));
		_tmp7_ = state;
		_tmp8_ = state;
		_tmp9_ = state;
		_tmp10_ = _tmp9_->input_characters;
		_tmp11_ = self->priv->mode;
		_tmp12_ = kkc_state_convert_rom_kana_characters_by_kana_mode (_tmp8_, _tmp10_, _tmp11_);
		_g_free0 (_tmp7_->overriding_input);
		_tmp7_->overriding_input = _tmp12_;
		result = TRUE;
		return result;
	}
	result = FALSE;
	return result;
}


static void kkc_initial_state_handler_convert_command_handler_class_init (KkcInitialStateHandlerConvertCommandHandlerClass * klass) {
	kkc_initial_state_handler_convert_command_handler_parent_class = g_type_class_peek_parent (klass);
	g_type_class_add_private (klass, sizeof (KkcInitialStateHandlerConvertCommandHandlerPrivate));
	G_OBJECT_CLASS (klass)->finalize = kkc_initial_state_handler_convert_command_handler_finalize;
}


static void kkc_initial_state_handler_convert_command_handler_kkc_command_handler_interface_init (KkcCommandHandlerIface * iface) {
	kkc_initial_state_handler_convert_command_handler_kkc_command_handler_parent_iface = g_type_interface_peek_parent (iface);
	iface->call = (gboolean (*)(KkcCommandHandler*, const gchar*, KkcState*, KkcKeyEvent*)) kkc_initial_state_handler_convert_command_handler_real_call;
}


static void kkc_initial_state_handler_convert_command_handler_instance_init (KkcInitialStateHandlerConvertCommandHandler * self) {
	self->priv = KKC_INITIAL_STATE_HANDLER_CONVERT_COMMAND_HANDLER_GET_PRIVATE (self);
}


static void kkc_initial_state_handler_convert_command_handler_finalize (GObject* obj) {
	KkcInitialStateHandlerConvertCommandHandler * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (obj, KKC_INITIAL_STATE_HANDLER_TYPE_CONVERT_COMMAND_HANDLER, KkcInitialStateHandlerConvertCommandHandler);
	G_OBJECT_CLASS (kkc_initial_state_handler_convert_command_handler_parent_class)->finalize (obj);
}


static GType kkc_initial_state_handler_convert_command_handler_get_type (void) {
	static volatile gsize kkc_initial_state_handler_convert_command_handler_type_id__volatile = 0;
	if (g_once_init_enter (&kkc_initial_state_handler_convert_command_handler_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (KkcInitialStateHandlerConvertCommandHandlerClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) kkc_initial_state_handler_convert_command_handler_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (KkcInitialStateHandlerConvertCommandHandler), 0, (GInstanceInitFunc) kkc_initial_state_handler_convert_command_handler_instance_init, NULL };
		static const GInterfaceInfo kkc_command_handler_info = { (GInterfaceInitFunc) kkc_initial_state_handler_convert_command_handler_kkc_command_handler_interface_init, (GInterfaceFinalizeFunc) NULL, NULL};
		GType kkc_initial_state_handler_convert_command_handler_type_id;
		kkc_initial_state_handler_convert_command_handler_type_id = g_type_register_static (G_TYPE_OBJECT, "KkcInitialStateHandlerConvertCommandHandler", &g_define_type_info, 0);
		g_type_add_interface_static (kkc_initial_state_handler_convert_command_handler_type_id, KKC_TYPE_COMMAND_HANDLER, &kkc_command_handler_info);
		g_once_init_leave (&kkc_initial_state_handler_convert_command_handler_type_id__volatile, kkc_initial_state_handler_convert_command_handler_type_id);
	}
	return kkc_initial_state_handler_convert_command_handler_type_id__volatile;
}


static void kkc_initial_state_handler_class_init (KkcInitialStateHandlerClass * klass) {
	kkc_initial_state_handler_parent_class = g_type_class_peek_parent (klass);
	((KkcStateHandlerClass *) klass)->process_key_event = kkc_initial_state_handler_real_process_key_event;
	G_OBJECT_CLASS (klass)->constructor = kkc_initial_state_handler_constructor;
}


static void kkc_initial_state_handler_instance_init (KkcInitialStateHandler * self) {
}


GType kkc_initial_state_handler_get_type (void) {
	static volatile gsize kkc_initial_state_handler_type_id__volatile = 0;
	if (g_once_init_enter (&kkc_initial_state_handler_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (KkcInitialStateHandlerClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) kkc_initial_state_handler_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (KkcInitialStateHandler), 0, (GInstanceInitFunc) kkc_initial_state_handler_instance_init, NULL };
		GType kkc_initial_state_handler_type_id;
		kkc_initial_state_handler_type_id = g_type_register_static (KKC_TYPE_STATE_HANDLER, "KkcInitialStateHandler", &g_define_type_info, 0);
		g_once_init_leave (&kkc_initial_state_handler_type_id__volatile, kkc_initial_state_handler_type_id);
	}
	return kkc_initial_state_handler_type_id__volatile;
}



